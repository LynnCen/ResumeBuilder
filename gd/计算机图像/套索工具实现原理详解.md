# 套索工具实现原理详解

> **教学目标：** 深入理解套索工具的实现原理，从路径收集到贝塞尔曲线平滑，从虚线动画到蒙版生成的完整流程

## 📚 目录

1. [什么是套索工具](#一什么是套索工具)
2. [完整工作流程](#二完整工作流程)
3. [核心实现原理](#三核心实现原理)
4. [贝塞尔曲线平滑原理](#四贝塞尔曲线平滑原理)
5. [虚线动画原理](#五虚线动画原理)
6. [坐标转换的深度解析](#六坐标转换的深度解析)
7. [性能优化与最佳实践](#七性能优化与最佳实践)

---

## 一、什么是套索工具？

### 1.1 用户视角的体验

想象你在用Photoshop或其他图像编辑软件，想要选中一个不规则的区域（比如一朵云、一条河流、一个复杂轮廓的物体）：

**传统矩形选框：** 只能选矩形，不灵活
**魔棒工具：** 基于颜色相似度，可能选不准
**主体选择：** AI自动识别，但有时候AI理解不了你的意图

而**套索工具**提供了最直接的体验：

- 鼠标按下，开始绘制
- 沿着想要的轮廓移动鼠标
- 鼠标抬起，自动闭合路径
- 选区生成完毕

**这就像用笔在纸上画圈——你想选什么，就画什么。**

### 1.2 技术本质

套索工具本质上是一个**自由路径绘制工具**，它的核心能力是：

1. **路径收集**：实时记录鼠标移动轨迹，形成点集
2. **路径平滑**：将离散的点集转换为平滑的曲线
3. **路径闭合**：自动连接起点和终点，形成封闭区域
4. **蒙版生成**：将闭合路径填充，生成选区蒙版

**关键洞察：** 不是"直接画线"，而是"记录点 → 插值平滑 → 生成路径"。

### 1.3 在项目中的角色

在AI改图功能中，套索是三个选区工具之一：

- **主体选择**：AI辅助，快速但依赖AI理解
- **套索工具（本文）**：手动绘制，自由但需要技巧
- **画笔工具**：涂抹式，精细但速度慢

**套索的优势：**

- 比主体选择更灵活（你说了算）
- 比画笔工具更快速（一笔成形）
- 适合轮廓清晰的不规则物体

---

## 二、完整工作流程

### 2.1 宏观流程图

```
┌─────────────────────────────────────────────────────────┐
│  阶段一：路径收集（鼠标按下到鼠标抬起）                    │
├─────────────────────────────────────────────────────────┤
│  1. 鼠标按下（mousedown）                                │
│     ├─ 清空之前的路径点数组                               │
│     ├─ 记录起始点                                        │
│     └─ 监听mousemove和mouseup事件                        │
│  2. 鼠标移动（mousemove）                                │
│     ├─ 获取canvas坐标（考虑变换）                         │
│     ├─ 添加点到路径数组                                  │
│     └─ 实时绘制预览路径（在selectionCanvas上）           │
│  3. 鼠标抬起（mouseup）                                  │
│     ├─ 停止监听mousemove                                 │
│     ├─ 闭合路径（连接终点到起点）                         │
│     └─ 进入下一阶段                                      │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  阶段二：蒙版生成（路径 → mask图像）                      │
├─────────────────────────────────────────────────────────┤
│  4. 坐标转换                                             │
│     └─ canvas坐标 → 图像坐标                             │
│  5. 创建临时canvas                                       │
│     └─ 尺寸 = 图像原始尺寸                                │
│  6. 绘制闭合路径并填充                                    │
│     ├─ 使用fill()填充路径                                │
│     └─ 生成黑白mask                                      │
│  7. 更新maskCanvas                                       │
│     └─ 触发maskResultChange回调                          │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  阶段三：视觉反馈（实时预览）                             │
├─────────────────────────────────────────────────────────┤
│  8. 路径平滑处理                                         │
│     ├─ 使用贝塞尔曲线插值                                │
│     └─ 生成平滑的SVG路径                                 │
│  9. 虚线动画效果                                         │
│     ├─ 使用strokeDasharray实现虚线                       │
│     └─ 使用strokeDashoffset实现动画                      │
│  10. 在selectionCanvas上实时绘制                         │
│     └─ 每次mousemove都重绘                               │
└─────────────────────────────────────────────────────────┘
```

### 2.2 核心文件路径

```
domains/editor/packages/common/drawing-masks/src/
├── hooks/
│   ├── use-lasso-masks.ts       # 套索工具核心逻辑
│   └── use-draw-masks.ts        # 主控制器，处理蒙版合并
├── utils/
│   ├── path.ts                  # 路径平滑算法
│   ├── coordinate.ts            # 坐标转换
│   └── canvas.ts                # Canvas工具函数
└── constants.ts                 # 常量定义
```

### 2.3 数据流转

```typescript
// 1. 原始数据：鼠标事件
MouseEvent { clientX: 150, clientY: 200 }
    ↓
// 2. Canvas坐标：经过DPI和变换矩阵转换
Point { x: 300, y: 400 } // canvas坐标系
    ↓
// 3. 路径点数组：实时累积
points = [
    { x: 300, y: 400 },
    { x: 302, y: 402 },
    { x: 305, y: 408 },
    ...
]
    ↓
// 4. 平滑路径：贝塞尔曲线插值
smoothPath = "M 300 400 Q 301 401 302 402 Q 303 405 305 408 ..."
    ↓
// 5. 图像坐标：转换到原始图像尺寸
imagePoints = [
    { x: 600, y: 800 },  // 假设图像是canvas的2倍大
    { x: 604, y: 804 },
    ...
]
    ↓
// 6. 蒙版canvas：填充闭合路径
maskCanvas: HTMLCanvasElement // 白色填充区域 = 选中，黑色 = 未选中
```

---

## 三、核心实现原理

### 3.1 路径收集：捕捉鼠标轨迹

#### 步骤1：初始化与事件绑定

```typescript
// use-lasso-masks.ts (核心代码)
const points = ref<Point[]>([]); // 存储路径点
let transform: DOMMatrix | null = null; // canvas变换矩阵

const onMouseDown = (e: MouseEvent) => {
  if (!enabled.value) return;

  points.value = []; // 清空之前的路径
  transform = null; // 重置变换矩阵

  // 监听移动和抬起事件
  document.addEventListener('mousemove', onMouseMove);
  document.addEventListener('mouseup', onMouseUp);
};
```

**为什么在document上监听，而不是canvas？**

```
在canvas上监听：
- 鼠标移出canvas区域，事件停止触发
- 用户快速移动时可能"画不连续"

在document上监听：
- 即使鼠标移出canvas，依然能捕捉
- 用户可以"画出边界"再回来
- 体验更友好
```

**为什么要清空points和重置transform？**

```typescript
points.value = []; // 每次新笔触，重新开始
transform = null; // 重新计算变换矩阵（canvas可能被缩放/旋转）
```

如果不清空，新路径会连接到旧路径，形成奇怪的图形。

#### 步骤2：实时路径收集

```typescript
const onMouseMove = throttle((e: MouseEvent) => {
  if (!enabled.value || !selectionCanvas.value) return;

  // 获取或初始化变换矩阵
  if (!transform) {
    transform = getCanvasTransform(selectionCanvas.value);
  }

  // 转换坐标：屏幕坐标 → canvas坐标
  const { x, y } = getCanvasOffsetPoint(selectionCanvas.value, e, transform);

  // 添加点到路径数组
  points.value.push({ x, y });

  // 实时绘制预览
  drawLasso();
}, 1000 / 30); // 节流：30fps
```

**为什么要节流（throttle）？**

```
不节流：
- mousemove触发频率：100-200次/秒
- 每次都绘制路径：性能开销大
- 可能导致卡顿、掉帧

节流到30fps：
- 每秒只处理30次
- 人眼感知不到延迟（电影是24fps）
- 性能大幅提升
```

**为什么要缓存transform？**

```typescript
if (!transform) {
  transform = getCanvasTransform(selectionCanvas.value);
}
```

`getCanvasTransform`需要计算canvas的变换矩阵（旋转、缩放、偏移），这是一个相对昂贵的操作。在同一笔触中，变换矩阵不会变，所以缓存起来复用。

**性能对比：**

```
不缓存：每次mousemove都计算（30次/秒 × 1ms = 30ms）
缓存：只计算一次（1ms）
```

#### 步骤3：结束路径收集

```typescript
const onMouseUp = () => {
  if (!enabled.value || points.value.length < 2) return;

  // 停止监听（避免内存泄漏）
  document.removeEventListener('mousemove', onMouseMove);
  document.removeEventListener('mouseup', onMouseUp);

  // 通知父组件：路径完成，生成蒙版
  emit('complete', points.value);

  // 清空selectionCanvas（预览完成）
  const ctx = selectionCanvas.value?.getContext('2d');
  ctx?.clearRect(0, 0, selectionCanvas.value.width, selectionCanvas.value.height);
};
```

**为什么要检查points.value.length < 2？**

```
至少需要2个点才能形成路径：
- 1个点：无法绘制线段
- 2个点：可以形成一条线
- 3个以上：形成有意义的选区
```

如果用户只是"点了一下"（没有移动），不应该生成选区。

**为什么要removeEventListener？**

如果不移除监听器，每次mousedown都会添加新的监听器，导致：

- 内存泄漏
- 事件重复触发
- 性能下降

### 3.2 实时预览绘制

#### 为什么需要实时预览？

**没有预览的体验：**

```
用户：我画了什么？看不到啊！
系统：等你松开鼠标再说
用户：那我怎么知道画得对不对？
```

**有预览的体验：**

```
用户：我要选这个区域...（看着路径在移动）
系统：你看，就是这条路径
用户：嗯，看起来不错（或者：不对，我重新画）
```

实时预览是良好用户体验的关键。

#### 预览绘制的核心逻辑

```typescript
const drawLasso = () => {
  if (!selectionCanvas.value || points.value.length < 2) return;

  const ctx = selectionCanvas.value.getContext('2d')!;
  const { width, height } = selectionCanvas.value;

  // 1. 清空上一帧的内容
  ctx.clearRect(0, 0, width, height);

  // 2. 生成平滑路径
  const smoothPath = createSmoothPathWithQuadratic(points.value);
  if (!smoothPath) return;

  // 3. 设置样式
  ctx.save();
  ctx.strokeStyle = '#33C8E6'; // 青色
  ctx.lineWidth = 2;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';

  // 4. 应用虚线动画效果
  ctx.setLineDash([5, 3]); // 5px实线，3px间隔
  ctx.lineDashOffset = -animationOffset.value; // 动画偏移

  // 5. 绘制路径
  const path2d = new Path2D(smoothPath);
  ctx.stroke(path2d);

  ctx.restore();
};
```

**为什么要clearRect？**

```
不清空：
- 新路径会叠加在旧路径上
- 形成"残影"效果
- 用户看到一团乱线

清空再画：
- 每次都是干净的画面
- 只显示当前路径
- 视觉清晰
```

**为什么要save()和restore()？**

```typescript
ctx.save(); // 保存当前状态
// ... 修改样式 ...
ctx.restore(); // 恢复之前的状态
```

这是Canvas编程的最佳实践：

- `save()`：保存当前所有样式（颜色、线宽、变换等）
- 修改样式：只影响当前绘制
- `restore()`：恢复到之前的状态，不污染后续绘制

类比：进入函数前保存变量，退出函数后恢复（作用域隔离）。

### 3.3 路径闭合与蒙版生成

#### 从路径到蒙版：关键转换

用户绘制的路径是"开放"的（起点和终点不连接），但选区必须是"封闭"的。

**路径闭合策略：**

```typescript
// 方案1：自动连接起点和终点（本项目采用）
function closePathAutomatically(points: Point[]): Point[] {
  if (points.length < 2) return points;

  const firstPoint = points[0];
  const lastPoint = points[points.length - 1];

  // 检查是否已经闭合（起点和终点很近）
  const distance = Math.sqrt(
    Math.pow(lastPoint.x - firstPoint.x, 2) + Math.pow(lastPoint.y - firstPoint.y, 2),
  );

  if (distance > 5) {
    // 距离>5px，不算闭合
    points.push(firstPoint); // 添加起点到末尾
  }

  return points;
}

// 方案2：用直线连接（Photoshop的做法）
function closePathWithLine(ctx: CanvasRenderingContext2D, points: Point[]) {
  // 绘制完所有点后
  ctx.lineTo(points[0].x, points[0].y); // 回到起点
  ctx.closePath(); // Canvas的closePath()方法
}
```

**两种方案的区别：**

| 特性     | 自动添加起点             | Canvas closePath() |
| -------- | ------------------------ | ------------------ |
| 实现     | 手动添加点               | 调用API            |
| 路径数据 | 修改points数组           | 不修改数据         |
| 灵活性   | 高（可以自定义闭合方式） | 低（固定行为）     |
| 适用场景 | 需要保存路径数据         | 只需要绘制效果     |

本项目采用方案1，因为需要保存路径点数据用于后续处理。

#### 蒙版生成的详细步骤

```typescript
function generateMaskFromPath(points: Point[], imageSize: { width: number; height: number }) {
  // 1. 坐标转换：canvas坐标 → 图像坐标
  const imagePoints = points.map((p) => {
    return {
      x: p.x * (imageSize.width / canvasSize.width),
      y: p.y * (imageSize.height / canvasSize.height),
    };
  });

  // 2. 创建临时canvas（尺寸 = 图像原始尺寸）
  const maskCanvas = document.createElement('canvas');
  maskCanvas.width = imageSize.width;
  maskCanvas.height = imageSize.height;
  const ctx = maskCanvas.getContext('2d')!;

  // 3. 设置填充样式
  ctx.fillStyle = '#FFFFFF'; // 白色 = 选中区域
  ctx.globalCompositeOperation = 'source-over';

  // 4. 创建闭合路径
  ctx.beginPath();
  ctx.moveTo(imagePoints[0].x, imagePoints[0].y);

  for (let i = 1; i < imagePoints.length; i++) {
    ctx.lineTo(imagePoints[i].x, imagePoints[i].y);
  }

  ctx.closePath(); // 自动闭合
  ctx.fill(); // 填充路径

  return maskCanvas;
}
```

**为什么要转换到图像坐标？**

```
canvas尺寸（显示）：500×500px
图像尺寸（实际）：2000×2000px

如果直接使用canvas坐标：
- 在500px的canvas上点击(100, 100)
- 对应图像的(100, 100)
- 但实际应该对应(400, 400)
- 选区偏移！

转换后：
- canvas(100, 100) → 图像(400, 400)
- 选区准确
```

**为什么要创建临时canvas？**

不能直接在maskCanvas上绘制，因为：

- maskCanvas可能已有内容（之前的选区）
- 需要先在临时canvas上生成新mask
- 然后决定如何合并（覆盖/加选/减选）

**为什么用fill()而不是stroke()？**

```
fill()：填充路径内部
- 生成区域蒙版
- 适合选区

stroke()：描绘路径边界
- 只有边框，内部是空的
- 不适合选区
```

---

## 四、贝塞尔曲线平滑原理

### 4.1 为什么需要平滑？

#### 问题：直接连接点会产生锯齿

如果直接用直线连接鼠标轨迹的点：

```typescript
// 糟糕的做法：直线连接
ctx.moveTo(points[0].x, points[0].y);
for (let i = 1; i < points.length; i++) {
  ctx.lineTo(points[i].x, points[i].y);
}
```

**视觉效果：**

```
期望：一条平滑的曲线 ~~~~~~~~
实际：一堆折线段    /\/\/\/\
```

**为什么会这样？**

鼠标移动轨迹是离散采样的：

```
每隔约16ms（60fps）采样一次
即使人手很稳，也会有微小抖动
点之间用直线连接，会放大这些抖动
```

**类比理解：**

想象你在沙滩上走路，脚印是离散的点。如果用直尺连接每个脚印，会得到一条折线；但你实际走的路径是平滑的曲线。

### 4.2 贝塞尔曲线：数学的魔法

#### 什么是贝塞尔曲线？

贝塞尔曲线（Bézier Curve）是一种通过控制点定义的平滑曲线，广泛应用于：

- 图形设计（Illustrator、Figma的钢笔工具）
- 动画（CSS动画的缓动函数）
- 字体设计（TrueType字体）
- 路径规划（机器人运动轨迹）

**核心思想：** 不是直接连接点，而是用"控制点"引导曲线走向。

#### 二次贝塞尔曲线（Quadratic Bézier）

**定义：** 由3个点确定的曲线

- P0：起点
- P1：控制点（曲线靠近但不经过这个点）
- P2：终点

**数学公式：**

```
B(t) = (1-t)² * P0 + 2(1-t)t * P1 + t² * P2
其中 t ∈ [0, 1]
```

**通俗理解：**

```
t=0：B(0) = P0（起点）
t=0.5：B(0.5) = 靠近P1的某个点
t=1：B(1) = P2（终点）
```

想象一根弹性绳，两端固定在P0和P2，中间被P1"拉"向一侧，形成的弧线就是贝塞尔曲线。

#### 在Canvas中使用

```typescript
// Canvas API：quadraticCurveTo
ctx.moveTo(P0.x, P0.y);
ctx.quadraticCurveTo(P1.x, P1.y, P2.x, P2.y);
ctx.stroke();
```

**SVG路径格式：**

```typescript
const path = `M ${P0.x} ${P0.y} Q ${P1.x} ${P1.y} ${P2.x} ${P2.y}`;
// M = MoveTo（移动到起点）
// Q = Quadratic Bézier（二次贝塞尔曲线）
```

### 4.3 路径平滑算法实现

#### 核心算法：滑动窗口 + 中点插值

```typescript
function createSmoothPathWithQuadratic(points: Point[]): string {
  if (points.length < 2) return '';

  // 起点
  let path = `M ${points[0].x} ${points[0].y}`;

  // 如果只有2个点，用直线
  if (points.length === 2) {
    path += ` L ${points[1].x} ${points[1].y}`;
    return path;
  }

  // 3个以上点，使用贝塞尔曲线
  for (let i = 1; i < points.length - 1; i++) {
    const current = points[i]; // 当前点
    const next = points[i + 1]; // 下一个点

    // 计算中点（作为曲线终点）
    const midX = (current.x + next.x) / 2;
    const midY = (current.y + next.y) / 2;

    // Q: 以current为控制点，mid为终点
    path += ` Q ${current.x} ${current.y} ${midX} ${midY}`;
  }

  // 最后一段：直接连接到终点
  const last = points[points.length - 1];
  path += ` L ${last.x} ${last.y}`;

  return path;
}
```

#### 算法原理详解

**为什么要计算中点？**

```
假设有3个点：A、B、C

直接连接：
A ----直线---- B ----直线---- C
效果：两个折角

使用贝塞尔曲线（以B为控制点，mid(B,C)为终点）：
A ~~~~曲线~~~~ mid(B,C)
效果：A到中点的平滑曲线

然后继续：
mid(B,C) ~~~~曲线~~~~ mid(C,D)
效果：整体平滑
```

**为什么这样就平滑了？**

关键在于：**相邻曲线段在连接点处自然相切**

想象一条铁轨：
- 如果是折线连接，火车会"咔咔咔"地颠簸
- 如果是曲线连接，火车会平滑地滑过

贝塞尔曲线通过控制点和中点的组合，确保了：
1. 每段曲线都是平滑的（无折角）
2. 相邻曲线段在连接点处切线方向一致（无突变）
3. 整体路径连续且平滑

**数学原理（可选阅读）：**

对于三个连续点 A、B、C：
- 第一段曲线：从 A 到 mid(A,B)，控制点是 A
- 第二段曲线：从 mid(A,B) 到 mid(B,C)，控制点是 B
- 在 mid(A,B) 处：
  - 第一段曲线的终点切线方向：指向 B
  - 第二段曲线的起点切线方向：也指向 B
  - 两个切线方向一致 → 平滑连接

#### 视觉对比

```
原始点（离散采样）：
●-----●---●-------●-●---●

直线连接（锯齿）：
●─────●───●───────●─●───●
      /   \       \/\

贝塞尔平滑（流畅）：
●~~~~~●~~~●~~~~~~~●~●~~~●
```

### 4.4 平滑算法的变种与优化

#### 变种1：三次贝塞尔曲线（Cubic Bézier）

```typescript
// 使用两个控制点，平滑度更高
function createSmoothPathWithCubic(points: Point[]): string {
  let path = `M ${points[0].x} ${points[0].y}`;

  for (let i = 1; i < points.length - 2; i++) {
    const p0 = points[i - 1];
    const p1 = points[i];
    const p2 = points[i + 1];

    // 计算两个控制点
    const cp1x = p0.x + (p1.x - p0.x) / 3;
    const cp1y = p0.y + (p1.y - p0.y) / 3;
    const cp2x = p1.x + (p2.x - p1.x) / 3;
    const cp2y = p1.y + (p2.y - p1.y) / 3;

    path += ` C ${cp1x} ${cp1y} ${cp2x} ${cp2y} ${p1.x} ${p1.y}`;
  }

  return path;
}
```

**三次 vs 二次贝塞尔：**

| 特性 | 二次贝塞尔 | 三次贝塞尔 |
|------|-----------|-----------|
| 控制点数量 | 1个 | 2个 |
| 平滑度 | 好 | 更好 |
| 计算复杂度 | 低 | 较高 |
| 路径长度 | 较短 | 较长 |
| 适用场景 | 快速绘制 | 精细设计 |

**本项目选择二次贝塞尔的原因：**
- 性能更好（实时绘制）
- 平滑度已足够（用户感知不到差异）
- 代码更简单

#### 优化1：点抽稀（Simplification）

如果鼠标移动很慢，会采集大量密集的点，影响性能：

```typescript
// 问题：点太多
points = [
  { x: 100, y: 100 },
  { x: 101, y: 100 },  // 距离上一个点只有1px
  { x: 102, y: 100 },  // 太密集了！
  { x: 103, y: 100 },
  ...
]
```

**解决方案：Douglas-Peucker 算法**

```typescript
function simplifyPath(points: Point[], tolerance: number = 2): Point[] {
  if (points.length < 3) return points;

  // 找到距离起点-终点连线最远的点
  let maxDistance = 0;
  let maxIndex = 0;

  for (let i = 1; i < points.length - 1; i++) {
    const distance = perpendicularDistance(points[i], points[0], points[points.length - 1]);
    if (distance > maxDistance) {
      maxDistance = distance;
      maxIndex = i;
    }
  }

  // 如果最大距离小于容差，简化为直线
  if (maxDistance < tolerance) {
    return [points[0], points[points.length - 1]];
  }

  // 递归简化左右两段
  const left = simplifyPath(points.slice(0, maxIndex + 1), tolerance);
  const right = simplifyPath(points.slice(maxIndex), tolerance);

  return left.slice(0, -1).concat(right);
}
```

**效果对比：**

```
原始：1000个点 → 平滑处理耗时 20ms
简化后：100个点 → 平滑处理耗时 2ms
视觉效果：几乎无差异
```

#### 优化2：增量更新而非全量重绘

```typescript
// 糟糕：每次mousemove都重新计算整个路径
const onMouseMove = () => {
  points.push(newPoint);
  const smoothPath = createSmoothPath(points); // 重新计算所有点
  drawPath(smoothPath);
};

// 优化：只计算新增的部分
let lastDrawnIndex = 0;
const onMouseMove = () => {
  points.push(newPoint);

  // 只处理新增的点
  if (points.length - lastDrawnIndex > 5) {
    const newSegment = createSmoothPath(points.slice(lastDrawnIndex - 1));
    appendPath(newSegment); // 追加而不是重绘
    lastDrawnIndex = points.length - 1;
  }
};
```

**性能提升：**

```
全量重绘：O(n)，n = 当前所有点数
增量更新：O(k)，k = 新增点数（通常 k << n）

实际效果：
- 开始绘制：2ms vs 2ms（无差异）
- 中途绘制：10ms vs 2ms（快5倍）
- 结束绘制：20ms vs 2ms（快10倍）
```

---

## 五、虚线动画原理

### 5.1 为什么需要虚线动画？

#### 用户体验的考量

**静态实线的问题：**

```
用户绘制路径时：
- 看到一条静态的线
- 不确定这是"正在绘制"还是"已经完成"
- 缺少视觉反馈
```

**虚线动画的优势：**

```
用户看到动态的虚线：
- 明确知道"正在绘制中"
- 视觉上更吸引人
- 类似Photoshop的"行军蚁"效果
- 提升专业感
```

**类比理解：**

就像进度条的转圈动画，虚线的流动告诉用户"系统正在工作"。

### 5.2 虚线的Canvas实现

#### 基础：setLineDash

```typescript
const ctx = canvas.getContext('2d')!;

// 设置虚线模式
ctx.setLineDash([5, 3]);
// [5, 3] = 5px实线，3px间隔，然后重复

// 绘制路径
ctx.beginPath();
ctx.moveTo(0, 0);
ctx.lineTo(200, 200);
ctx.stroke(); // 会显示为虚线
```

**setLineDash的参数规则：**

```typescript
ctx.setLineDash([5]); // [5, 5] = 5px实线，5px间隔
ctx.setLineDash([5, 3]); // 5px实线，3px间隔
ctx.setLineDash([5, 3, 2]); // 5px实线，3px间隔，2px实线，5px间隔...（循环）
ctx.setLineDash([10, 5, 2, 5]); // 复杂模式
```

**视觉效果：**

```
[5, 5]:  ━━━━━     ━━━━━     ━━━━━
[5, 3]:  ━━━━━   ━━━━━   ━━━━━
[10, 2]: ━━━━━━━━━━  ━━━━━━━━━━
[5, 3, 2, 3]: ━━━━━   ━━   ━━━━━   ━━
```

### 5.3 虚线动画：lineDashOffset的魔法

#### 原理：偏移虚线模式

`lineDashOffset` 控制虚线模式的起始位置：

```typescript
ctx.setLineDash([5, 3]); // 虚线模式
ctx.lineDashOffset = 0; // 从第0个像素开始

// 如果改变offset：
ctx.lineDashOffset = -2; // 整个模式向左偏移2px
```

**视觉效果：**

```
offset = 0:  ━━━━━   ━━━━━   ━━━━━
offset = -1: ━━━━ ━  ━━━━ ━  ━━━━ ━
offset = -2: ━━━ ━━  ━━━ ━━  ━━━ ━━
offset = -3: ━━ ━━━  ━━ ━━━  ━━ ━━━
```

**关键洞察：** 通过**连续改变offset**，虚线会"流动"起来！

#### 动画实现

```typescript
const animationOffset = ref(0);

// 方案1：使用 requestAnimationFrame
function animate() {
  animationOffset.value += 0.5; // 每帧偏移0.5px
  if (animationOffset.value > 8) {
    animationOffset.value = 0; // 循环（8 = 5 + 3）
  }

  drawLasso(); // 重绘路径
  requestAnimationFrame(animate);
}

animate(); // 启动动画

// 方案2：使用 setInterval（本项目采用）
const timer = setInterval(() => {
  animationOffset.value += 0.5;
  if (animationOffset.value > 8) {
    animationOffset.value = 0;
  }
  drawLasso();
}, 16); // 约60fps
```

**为什么offset要循环？**

```
虚线模式：[5, 3] = 总长度 8px

offset = 0:   ━━━━━   ━━━━━   ━━━━━
offset = -8:  ━━━━━   ━━━━━   ━━━━━  （视觉上和0相同）

所以 offset 超过 8 时重置为 0，视觉无缝衔接
```

**为什么要加负号？**

```typescript
ctx.lineDashOffset = -animationOffset.value;
```

负号决定动画方向：
- 正值：虚线向右移动（逆着绘制方向）
- 负值：虚线向左移动（顺着绘制方向）

顺着绘制方向的动画更符合用户直觉（就像水流）。

### 5.4 动画的性能优化

#### 问题：频繁重绘导致性能下降

```
动画需求：60fps（每秒60帧）
每帧操作：
1. 更新offset
2. 清空canvas
3. 重新绘制路径
4. 应用虚线样式

如果路径很复杂（1000个点）：
- 每帧5ms
- 60帧 × 5ms = 300ms/秒
- 性能开销巨大！
```

#### 优化方案1：降低动画帧率

```typescript
// 从60fps降到30fps
const timer = setInterval(() => {
  animationOffset.value += 1; // 步长加倍（保持速度）
  // ...
}, 33); // 33ms ≈ 30fps
```

**效果：**
- 性能开销减半
- 视觉上几乎无差异（30fps已经很流畅）

#### 优化方案2：只在绘制时启动动画

```typescript
const onMouseDown = () => {
  // 启动动画
  startAnimation();
};

const onMouseUp = () => {
  // 停止动画
  stopAnimation();
};

function startAnimation() {
  if (animationTimer) return; // 避免重复启动
  animationTimer = setInterval(() => {
    // ... 动画逻辑
  }, 33);
}

function stopAnimation() {
  if (animationTimer) {
    clearInterval(animationTimer);
    animationTimer = null;
  }
}
```

**效果：**
- 不绘制时不消耗性能
- 用户松开鼠标后立即停止动画

#### 优化方案3：使用CSS动画（高级）

如果使用SVG路径而不是Canvas，可以用CSS动画：

```css
.lasso-path {
  stroke-dasharray: 5 3;
  animation: dash-animation 0.5s linear infinite;
}

@keyframes dash-animation {
  to {
    stroke-dashoffset: -8;
  }
}
```

**优势：**
- GPU加速，性能更好
- 不需要JavaScript定时器
- 代码更简洁

**劣势：**
- 需要使用SVG而不是Canvas
- Canvas更灵活，SVG更适合静态图形

### 5.5 虚线样式的设计考量

#### 不同虚线模式的视觉效果

```typescript
// 1. 快速虚线（醒目）
ctx.setLineDash([5, 3]);
// 效果：━━━━━   ━━━━━   ━━━━━
// 适合：需要强调的路径

// 2. 密集虚线（精细）
ctx.setLineDash([2, 2]);
// 效果：━━  ━━  ━━  ━━  ━━
// 适合：精细控制，不遮挡内容

// 3. 长短虚线（节奏感）
ctx.setLineDash([10, 5, 2, 5]);
// 效果：━━━━━━━━━━     ━━     ━━━━━━━━━━
// 适合：特殊场景，区分不同类型的路径

// 4. 点线混合（经典）
ctx.setLineDash([8, 3, 2, 3]);
// 效果：━━━━━━━━   ━━   ━━━━━━━━
// 适合：Photoshop风格
```

**本项目选择 [5, 3] 的原因：**
- 5px实线：足够醒目，但不过分
- 3px间隔：节奏适中，不会太密集或太稀疏
- 总长度8px：动画循环周期短，流畅感强

#### 颜色与粗细的搭配

```typescript
// 青色 + 细线 = 清爽专业
ctx.strokeStyle = '#33C8E6';
ctx.lineWidth = 2;

// 白色 + 粗线 = 醒目但可能遮挡
ctx.strokeStyle = '#FFFFFF';
ctx.lineWidth = 3;

// 黄色 + 中等 = 高对比度（暗色背景）
ctx.strokeStyle = '#FFD700';
ctx.lineWidth = 2.5;
```

**选择原则：**
1. 颜色要与背景对比度高（容易看见）
2. 线宽要适中（太细看不清，太粗遮挡内容）
3. 与品牌色保持一致（本项目用青色）

---

## 六、坐标转换的深度解析

### 6.1 为什么坐标转换如此重要？

#### 多个坐标系统的挑战

在套索工具中，涉及到**至少3个坐标系统**：

```
1. 屏幕坐标系（Screen Coordinates）
   - 原点：浏览器窗口左上角
   - 单位：CSS像素
   - 来源：MouseEvent.clientX/Y

2. Canvas坐标系（Canvas Coordinates）
   - 原点：canvas元素左上角
   - 单位：canvas像素（考虑DPI）
   - 用途：绘制预览路径

3. 图像坐标系（Image Coordinates）
   - 原点：原始图像左上角
   - 单位：图像像素
   - 用途：生成最终蒙版
```

**如果不转换会怎样？**

```
用户在屏幕上点击(100, 100)：

不转换：
- 直接用(100, 100)生成mask
- 但实际图像可能是2000×2000
- 选区位置完全错误！

正确转换：
- 屏幕(100, 100) → canvas(200, 200) → 图像(800, 800)
- 选区位置准确
```

### 6.2 坐标转换的完整流程

#### 第一步：屏幕坐标 → Canvas坐标

```typescript
function getCanvasOffsetPoint(
  canvas: HTMLCanvasElement,
  event: MouseEvent,
  transform: DOMMatrix | null,
): Point {
  // 1. 获取canvas的边界
  const rect = canvas.getBoundingClientRect();

  // 2. 计算相对于canvas左上角的偏移
  const offsetX = event.clientX - rect.left;
  const offsetY = event.clientY - rect.top;

  // 3. 考虑DPI缩放
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;

  let x = offsetX * scaleX;
  let y = offsetY * scaleY;

  // 4. 应用变换矩阵（如果有旋转/缩放）
  if (transform) {
    const inverse = transform.inverse();
    const point = new DOMPoint(x, y);
    const transformed = point.matrixTransform(inverse);
    x = transformed.x;
    y = transformed.y;
  }

  return { x, y };
}
```

**详细解析：**

**步骤1-2：处理canvas位置**

```
浏览器窗口：
┌──────────────────────────────┐
│                              │
│    ┌──────canvas──────┐     │
│    │                  │     │
│    │   鼠标点这里 ●    │     │
│    │                  │     │
│    └──────────────────┘     │
│                              │
└──────────────────────────────┘

event.clientX = 150  (相对窗口)
rect.left = 50       (canvas距离窗口左边)
offsetX = 150 - 50 = 100  (相对canvas)
```

**步骤3：处理DPI缩放**

```
canvas.width = 1000px  (实际像素)
rect.width = 500px     (CSS显示宽度)
scaleX = 1000 / 500 = 2

offsetX = 100
x = 100 × 2 = 200  (canvas坐标)
```

**为什么需要DPI缩放？**

```
高DPI屏幕（Retina）：
- CSS：500×500px
- Canvas：1000×1000px（2倍）

如果不缩放：
- 用户点击CSS的(100, 100)
- 直接用canvas的(100, 100)
- 实际应该是(200, 200)
- 选区偏移！
```

**步骤4：应用变换矩阵**

```
如果canvas被旋转45度：
- 用户点击(200, 200)
- 需要逆变换回原始坐标系
- 否则路径会"倾斜"
```

#### 第二步：Canvas坐标 → 图像坐标

```typescript
function getImageCoordinate(
  canvasPoint: Point,
  canvasSize: { width: number; height: number },
  imageSize: { width: number; height: number },
): Point {
  return {
    x: canvasPoint.x * (imageSize.width / canvasSize.width),
    y: canvasPoint.y * (imageSize.height / canvasSize.height),
  };
}
```

**原理：简单的比例缩放**

```
canvas: 500×500px
image:  2000×2000px
scale = 2000 / 500 = 4

canvas点(100, 100)
→ 图像点(100×4, 100×4) = (400, 400)
```

### 6.3 变换矩阵的深度理解

#### 什么是变换矩阵？

变换矩阵（Transform Matrix）是描述坐标变换的数学工具，包括：

- 平移（Translation）
- 缩放（Scaling）
- 旋转（Rotation）
- 倾斜（Skew）

**数学表示（2D变换）：**

```
[a c e]   [x]   [ax + cy + e]
[b d f] × [y] = [bx + dy + f]
[0 0 1]   [1]   [1]

其中：
a, d: 缩放
b, c: 旋转/倾斜
e, f: 平移
```

#### Canvas的变换矩阵

```typescript
const ctx = canvas.getContext('2d')!;

// 获取当前变换矩阵
const transform = ctx.getTransform();
// 返回 DOMMatrix 对象

// DOMMatrix 包含6个参数
transform.a; // x方向缩放
transform.b; // y方向倾斜
transform.c; // x方向倾斜
transform.d; // y方向缩放
transform.e; // x方向平移
transform.f; // y方向平移
```

#### 逆变换的原理

**问题：** 用户点击变换后的canvas，如何找到原始坐标？

**解决：** 使用逆矩阵

```typescript
const inverse = transform.inverse();
const original = transformedPoint.matrixTransform(inverse);
```

**类比理解：**

```
正向变换：原始图像 → 旋转45度 → 显示
逆向变换：鼠标点击 → 反向旋转45度 → 原始坐标

就像：
1. 你把地图旋转了45度
2. 在旋转后的地图上指了一个位置
3. 需要"反向旋转"才能找到实际地理位置
```

#### 实际应用场景

```typescript
// 场景1：用户旋转了canvas
ctx.rotate(Math.PI / 4); // 旋转45度
ctx.drawImage(image, 0, 0);

// 用户点击时，需要逆变换
const inverse = ctx.getTransform().inverse();
const original = point.matrixTransform(inverse);

// 场景2：用户缩放了canvas
ctx.scale(1.5, 1.5);
ctx.drawImage(image, 0, 0);

// 点击坐标需要除以缩放比例
const original = {
  x: point.x / 1.5,
  y: point.y / 1.5,
};
```

### 6.4 坐标转换的常见陷阱

#### 陷阱1：忘记DPI缩放

```typescript
// 错误
const x = event.clientX - canvas.offsetLeft;

// 正确
const rect = canvas.getBoundingClientRect();
const x = (event.clientX - rect.left) * (canvas.width / rect.width);
```

#### 陷阱2：混淆不同坐标系

```typescript
// 错误：用canvas坐标生成图像mask
maskCtx.fillRect(canvasX, canvasY, 10, 10);

// 正确：先转换到图像坐标
const imageX = canvasX * (imageWidth / canvasWidth);
const imageY = canvasY * (imageHeight / canvasHeight);
maskCtx.fillRect(imageX, imageY, 10, 10);
```

#### 陷阱3：缓存过期的变换矩阵

```typescript
// 错误：变换矩阵可能已经变化
let transform = ctx.getTransform();
// ... 用户可能缩放了canvas ...
// transform已经过期了！

// 正确：每次使用时重新获取
const getTransform = () => ctx.getTransform();
```

---

## 七、性能优化与最佳实践

### 7.1 性能瓶颈分析

#### 瓶颈1：频繁的路径平滑计算

```
问题：
- mousemove 触发频率：100-200次/秒
- 每次都重新计算整个平滑路径
- 路径点数可能达到数百个
- 计算开销：O(n)，n = 点数

实测数据：
- 100个点：2ms
- 500个点：10ms
- 1000个点：20ms
```

**优化方案：**

```typescript
// 1. 节流（已实现）
const onMouseMove = throttle((e) => {
  // ...
}, 1000 / 30); // 30fps

// 2. 增量计算（建议）
let lastCalculatedIndex = 0;
function calculateSmoothPath() {
  if (points.length - lastCalculatedIndex < 5) {
    return; // 点数太少，不值得重新计算
  }

  const newSegment = smoothPath(points.slice(lastCalculatedIndex - 1));
  appendToPath(newSegment);
  lastCalculatedIndex = points.length - 1;
}

// 3. Web Worker（高级）
const worker = new Worker('smooth-path-worker.js');
worker.postMessage(points);
worker.onmessage = (e) => {
  const smoothPath = e.data;
  drawPath(smoothPath);
};
```

#### 瓶颈2：Canvas重绘

```
问题：
- 每次drawLasso都要clearRect + stroke
- 对于大尺寸canvas（如2000×2000），clearRect很慢
- stroke复杂路径也很慢

实测数据：
- clearRect(1000×1000): 1ms
- stroke(100个点): 1ms
- clearRect(2000×2000): 3ms
- stroke(1000个点): 5ms
```

**优化方案：**

```typescript
// 1. 脏矩形（Dirty Rectangle）
let dirtyRect = { x: 0, y: 0, width: 0, height: 0 };

function updateDirtyRect(point: Point) {
  dirtyRect.x = Math.min(dirtyRect.x, point.x - lineWidth);
  dirtyRect.y = Math.min(dirtyRect.y, point.y - lineWidth);
  dirtyRect.width = Math.max(dirtyRect.width, point.x + lineWidth);
  dirtyRect.height = Math.max(dirtyRect.height, point.y + lineWidth);
}

function drawLasso() {
  // 只清空变化的区域
  ctx.clearRect(dirtyRect.x, dirtyRect.y, dirtyRect.width, dirtyRect.height);
  // ... 绘制
}

// 2. 双缓冲（Double Buffering）
const offscreenCanvas = document.createElement('canvas');
const offscreenCtx = offscreenCanvas.getContext('2d')!;

// 在离屏canvas上绘制
offscreenCtx.clearRect(0, 0, width, height);
offscreenCtx.stroke(path);

// 一次性复制到显示canvas
ctx.drawImage(offscreenCanvas, 0, 0);
```

#### 瓶颈3：内存泄漏

```
问题：
- 每次mousedown创建新的事件监听器
- 如果忘记移除，会累积
- 路径点数组不清空，内存增长

表现：
- 内存占用持续增长
- 页面越用越卡
- 最终可能崩溃
```

**优化方案：**

```typescript
// 1. 始终配对添加和移除监听器
const onMouseDown = () => {
  document.addEventListener('mousemove', onMouseMove);
  document.addEventListener('mouseup', onMouseUp);
};

const onMouseUp = () => {
  document.removeEventListener('mousemove', onMouseMove);
  document.removeEventListener('mouseup', onMouseUp);
};

// 2. 组件销毁时清理
onUnmounted(() => {
  document.removeEventListener('mousemove', onMouseMove);
  document.removeEventListener('mouseup', onMouseUp);
  clearInterval(animationTimer);
  points.value = [];
});

// 3. 限制路径点数
const MAX_POINTS = 1000;
const onMouseMove = () => {
  if (points.value.length >= MAX_POINTS) {
    // 移除最旧的点
    points.value.shift();
  }
  points.value.push(newPoint);
};
```

### 7.2 代码组织最佳实践

#### 1. 关注点分离

```
// 好的组织
hooks/
  use-lasso-masks.ts          # 业务逻辑
utils/
  path.ts                     # 路径平滑算法
  coordinate.ts               # 坐标转换
  canvas.ts                   # Canvas工具函数

// 不好的组织
lasso.ts                      # 所有代码混在一起（1000+行）
```

#### 2. 类型安全

```typescript
// 定义清晰的类型
interface Point {
  x: number;
  y: number;
}

interface LassoOptions {
  canvas: HTMLCanvasElement;
  imageSize: { width: number; height: number };
  onComplete: (mask: HTMLCanvasElement) => void;
}

// 避免any
function smoothPath(points: Point[]): string {
  // 明确的输入输出类型
}
```

#### 3. 错误处理

```typescript
// 处理边界情况
function smoothPath(points: Point[]): string {
  if (!points || points.length < 2) {
    console.warn('路径点数不足，无法平滑');
    return '';
  }

  // ... 正常逻辑
}

// 处理异常
try {
  const mask = generateMask(points);
  onComplete(mask);
} catch (error) {
  console.error('生成蒙版失败:', error);
  showToast('选区生成失败，请重试');
}
```

### 7.3 用户体验优化

#### 1. 视觉反馈

```typescript
// 鼠标样式
canvas.style.cursor = 'crosshair'; // 绘制时

// 最小路径提示
if (points.length < 3) {
  showToast('请绘制更大的选区');
  return;
}

// 闭合提示
if (distance < 10) {
  canvas.style.cursor = 'pointer'; // 靠近起点时提示可以闭合
}
```

#### 2. 性能监控

```typescript
// 开发环境监控
if (import.meta.env.DEV) {
  let startTime = 0;

  const onMouseDown = () => {
    startTime = performance.now();
  };

  const onMouseUp = () => {
    const duration = performance.now() - startTime;
    console.log(`绘制耗时: ${duration.toFixed(2)}ms`);
    console.log(`路径点数: ${points.value.length}`);
  };
}
```

#### 3. 键盘快捷键

```typescript
// Esc键：取消当前绘制
useEventListener(document, 'keydown', (e) => {
  if (e.key === 'Escape' && points.value.length > 0) {
    points.value = [];
    clearCanvas();
  }
});

// Enter键：强制完成
useEventListener(document, 'keydown', (e) => {
  if (e.key === 'Enter' && points.value.length >= 3) {
    onMouseUp(); // 模拟鼠标抬起
  }
});
```

---

## 总结

### 核心要点回顾

1. **套索工具 = 路径收集 + 平滑处理 + 蒙版生成**
   - 路径收集：实时捕捉鼠标轨迹
   - 平滑处理：贝塞尔曲线插值
   - 蒙版生成：填充闭合路径

2. **完整流程**
   - mousedown：清空路径，开始监听
   - mousemove：添加点，实时预览
   - mouseup：闭合路径，生成蒙版

3. **贝塞尔曲线平滑**
   - 二次贝塞尔曲线：3个点定义一条曲线
   - 中点插值法：确保相邻曲线平滑连接
   - 相比直线连接，视觉更自然流畅

4. **虚线动画**
   - setLineDash：定义虚线模式
   - lineDashOffset：控制偏移实现动画
   - 连续改变offset，虚线"流动"起来

5. **坐标转换**
   - 屏幕坐标 → Canvas坐标：处理DPI和变换
   - Canvas坐标 → 图像坐标：比例缩放
   - 逆变换矩阵：处理旋转/缩放

6. **性能优化**
   - 节流：限制mousemove频率
   - 增量计算：只处理新增部分
   - 点抽稀：减少冗余点
   - 内存管理：及时清理监听器

### 技术亮点

- **实时反馈**：虚线动画提供即时视觉反馈
- **平滑算法**：贝塞尔曲线让路径自然流畅
- **坐标转换**：精确处理多个坐标系统
- **性能优化**：多种策略确保流畅体验
- **用户友好**：快捷键、鼠标样式、错误提示

### 延伸思考

**问题1：能否自动检测闭合路径？**

可以：
```typescript
function isPathClosed(points: Point[]): boolean {
  const first = points[0];
  const last = points[points.length - 1];
  const distance = Math.sqrt(
    Math.pow(last.x - first.x, 2) + Math.pow(last.y - first.y, 2)
  );
  return distance < 10; // 距离小于10px算闭合
}
```

**问题2：如何实现磁性套索（智能吸附）？**

思路：
- 检测图像边缘（Canny算法）
- 鼠标移动时，查找附近的边缘点
- 自动调整路径点到最近的边缘
- 难点：实时边缘检测性能开销大

**问题3：如何支持多边形套索？**

与自由套索的区别：
- 自由套索：连续路径，大量点
- 多边形套索：点击定点，直线连接
- 实现更简单，适合规则形状

---

**文档结束。希望这份详解能帮助你完全理解套索工具的实现原理！**
