# 基座化插件机制：从解析到页面展示

本文说明编辑器基座（Foundation）的插件机制核心流程，以 `init-editor.ts` 中第 93–95 行的 **auto-layout-resizing** 扩展为例，从「配置定义 → 解析加载 → 注册入口 → 页面展示」串联全链路。

---

## 一、你写的那几行在干什么

```93:95:domains/editor/apps/design/insmind-ai-plus/src/init/init-editor.ts
            () => {
                return defineExtensionConfig(import('@design/extension-auto-layout-resizing'));
            },
```

- **`() => ...`**：一个**工厂函数**，在真正要加载扩展时才执行，实现按需/懒加载。
- **`import('@design/extension-auto-layout-resizing')`**：动态 import，返回的是 **Promise\<模块\>**，不会在首屏就拉取该扩展的 chunk。
- **`defineExtensionConfig(...)`**：把「模块 Promise + 可选 options」封装成基座约定的 **扩展配置项**，即 `[config, options]` 的二元组（见下）。

也就是说：这里只是在 **声明**「要加载哪个扩展、用啥参数」，还没有加载代码，也没有渲染任何 UI。

---

## 二、配置是怎么进基座的

### 2.1 入口：`installDesign`

应用入口会调用：

```ts
await installDesign('#app', 'agent', {
    apis: await getApisConfig(),
    env,
    permissions: { ... },
    extensionConfig: [  // 你写的配置数组
        () => defineExtensionConfig(import('@design/extension-auto-layout-resizing')),
        () => defineExtensionConfig(import('@design/extension-batch-design'), { ... }),
        // ...
    ],
    editorConfig: { ... },
});
```

- `extensionConfig` 是 **函数数组**，每个函数返回 `defineExtensionConfig(...)` 的结果。
- `installDesign` 内部会创建 KernelBuilder、注册一堆服务，其中关键一步是 **创建 init-design 扩展** 并传入整个 `options`。

### 2.2 init-design 激活：把 extensionConfig 存到服务里

`createInitDesignExtension(options)` 在 **init-design 服务** 的 `activate` 里会做：

```ts
// kernel-x-services init-design/activate.ts
const extensionConfigService = new ExtensionConfigService();
if (!new URLSearchParams(window.location.search).get('thread_id')) {
    extensionConfigService.config = options.extensionConfig;  // 存起来
}
// ... 后续通过 getExtensionConfigService() 暴露给布局层
```

也就是说：**extensionConfig 被保存在 ExtensionConfigService 里**，还没有在这里做「解析」或「加载」。

### 2.3 布局扩展把「配置服务」注入到组件层

在 **agent 布局**（insmind-ai-plus 用的就是 agent 布局）里：

```ts
// kernel-x design-components extensions/agent-layout/index.ts
async activate(context) {
    const initDesignApi = await context.services.get(InitDesignServiceToken);
    const extensionConfigService = initDesignApi.getExtensionConfigService();
    setConfig({ extensionConfigService, editorConfigService });  // 注入到 design-components 的 config
}
```

这样，所有使用 `extensionConfigService` 的地方（例如 init-design 组合式逻辑、resource-station 等）拿到的都是**同一份** extensionConfig 引用。

---

## 三、解析与加载：何时、何地、如何

### 3.1 触发时机：左侧边栏挂载时

扩展**不是**在 `installDesign` 里就加载的，而是在 **左侧边栏（aside）挂载** 时触发第一次加载：

```ts
// design-components compositions/init-design.ts
async function onPartMounted(part: 'aside' | 'header' | 'right') {
    if (part === 'aside') {
        asideMounted.value = true;
        await loadExtension(extensionConfigService.config);  // 这里才真正解析 + 加载
        registerHeaderEntry();
        runCommand();
    }
    // ...
}
```

另外在「画布加载完成」后还会再调一次 `loadExtension(extensionConfigService.config)`（不 await），用于保证未在 aside 路径里加载到的扩展也能被加载。

### 3.2 defineExtensionConfig 的形态

`defineExtensionConfig` 定义在 `@design/kernel-x-foundation`（install-compat.ts）：

```ts
export function defineExtensionConfig<T>(config: BaseExtensionConfig<T>, options?: T) {
    return [config, options] as ExtensionInfoConfig;  // 即 [模块或 Promise<模块>, options?]
}
```

- **config**：可以是「扩展模块」或 **Promise<扩展模块>**（你写的 `import(...)` 就是 Promise）。
- **options**：可选，会一路传到扩展的 `main` / `beforeRegister` 等。

所以每一格 extensionConfig 在「执行工厂函数之后」都变成：**`[Promise<ExtensionInfo>, options?]`**。

### 3.3 ExtensionManager.load：解析配置、实例化 Extension

`loadExtension(config)` 内部会：

1. 拿到单例 **ExtensionManager**；
2. 调用 **manager.load(config)**；
3. 再调用 **manager.register()**。

`load` 的核心逻辑（extension 包里的 extension-manager.ts）：

```ts
async load(extensionConfigs?: ExtensionConfig[]) {
    if (!extensionConfigs) return;
    // 1. 执行每个配置：若是函数则执行，得到 [extensionInfo, options] 或 Promise
    const extensionInfos = await Promise.all(
        extensionConfigs.map((config) => (typeof config === 'function' ? config() : config)),
    );
    // 2. 解析二元组，若 extensionInfo 是 Promise 则 await
    const extensions = await Promise.all(
        extensionInfos.map(async (extensionInfoConfig) => {
            let [extensionInfo, options] = Array.isArray(extensionInfoConfig)
                ? extensionInfoConfig
                : [extensionInfoConfig];
            if (extensionInfo instanceof Promise) extensionInfo = await extensionInfo;
            if (!extensionInfo?.manifest) return;
            const manifest = mergeManifest(extensionInfo.manifest);
            return new Extension(manifest, options);
        }),
    );
    // 3. 按顺序塞进 Map，保证注册顺序
    extensions.forEach((ext) => ext && !this.hasExtension(ext.id) && this.extensions.set(ext.id, ext));
}
```

对应到你写的这一项：

- 工厂执行 → `defineExtensionConfig(import(...))` → 得到 `[Promise<模块>, undefined]`；
- Promise resolve 后得到模块对象，上面要有 **manifest**（及可选的 main、entries 等）；
- 用 `manifest + options`  new 出 **Extension** 实例，并放入 ExtensionManager。

也就是说：**解析**发生在 `ExtensionManager.load`，这里把「配置项」变成了「Extension 实例」，但还没挂 UI。

### 3.4 ExtensionManager.register：注册入口（决定哪里会出 UI）

`load` 完成后会调用 **manager.register()**，对每个已加载的 Extension 调用 **extension.register()**。

Extension 的 **register()** 只做一件事：**registerEntry()**。即根据 manifest 的 **entries**，把「入口」注册到基座的各种 Store 里（左侧资源栏、右侧属性面板、菜单、导出入口等）：

```ts
// extension core/extension.ts
register() {
    this.status = 'register';
    this.registerEntry();
}

private registerEntry() {
    if (!this.manifest.entries) return;
    const apiContext = this.createOrGetApiContext();  // ExtensionApi 封装
    this.manifest.beforeRegister?.(apiContext, this.options);

    // 左侧资源/活动栏
    if (this.manifest.entries[EntryTypes.ResourceActivityBar]?.length)
        apiContext.registerResourceStation(...);
    // 右侧属性/设置面板
    if (this.manifest.entries[EntryTypes.SettingContainer]?.length)
        apiContext.registerSettingContainer(...);
    // 其他入口：文件菜单、导出、画板菜单等
    Object.entries(this.manifest.entries).forEach(([key, entries]) => {
        if (key 不是上述几种) {
            const menus = entries.map(...);  // 转成 Menu，带 command、title、icon 等
            apiContext.registerEntry(key as EntryTypes, menus);
        }
    });
    this.manifest.afterRegister?.(apiContext, this.options);
}
```

以 **auto-layout-resizing** 为例，其 manifest 里定义了：

- `entries['editor/file-menu']`、`entries['editor/export-action']`、`entries['editor/page-more-menu']`、`entries['editor/canvas-size-panel']` 等。

这些 key 对应基座里的 **EntryTypes**（文件菜单、导出入口、画板更多操作、右侧尺寸面板等）。**registerEntry** 会把菜单项/按钮信息写入 **useExtensionStore** 等，供布局和菜单组件消费。所以：**「解析到页面展示」的桥梁，就是 registerEntry + 各种 registerXxx 写进 Store**。

---

## 四、页面展示：Store → 布局/菜单/面板

- **左侧资源栏 / 活动栏**：`registerResourceStation` → 左侧栏的 schema/列表数据来自对应 Store，Vue 组件根据这些数据渲染 tab、图标、标题。
- **右侧属性/设置面板**：`registerSettingContainer` → 右侧面板的 tab 列表和「点击后展示哪个 Vue 组件」由 Store 里的 schema 决定，组件通过 `useSettingContainerStore` 等读取。
- **文件菜单 / 导出 / 画板更多菜单等**：`registerEntry(key, menus)` → 菜单组件从 **useExtensionStore**（或等价 Store）按 `EntryTypes` 取 entries，渲染成菜单项或按钮；用户点击时触发 **command**。

扩展的 **真正业务 UI**（例如尺寸延展的弹窗、侧边栏里的表单）不是在 register 时就挂上的，而是在用户**第一次触发**该扩展的某个 command 时：

- 会调用 **extension.run(command, ...args)**；
- 若扩展还未 bootstrap，会先 **extension.bootstrap()** → 执行 **manifest.main(options)** 加载扩展代码并 **activate(apiContext, options)**；
- 之后 **apiContext.triggerCommand(command, ...)** 执行扩展内部注册的 command，这时才打开弹窗/面板或执行具体逻辑。

所以：

- **解析**：在 **ExtensionManager.load** 里，把 `extensionConfig` 变成 **Extension 实例**。
- **注册入口**：在 **ExtensionManager.register** → **extension.registerEntry()**，把 manifest.entries 写进各 Store。
- **页面展示**：布局和菜单组件**读 Store** 渲染入口（图标、菜单项、tab）；用户点击后再 **run → bootstrap → triggerCommand**，扩展的 UI 才真正出现。

---

## 五、流程串联（针对 93–95 行）

1. **定义**：`extensionConfig` 里有一项工厂 `() => defineExtensionConfig(import('@design/extension-auto-layout-resizing'))`，不传 options。
2. **注入基座**：`installDesign` 把整个 options 交给 **createInitDesignExtension**，init-design 的 activate 里把 **options.extensionConfig** 赋给 **ExtensionConfigService.config**，再通过 **getExtensionConfigService()** 暴露给 agent-layout，layout 通过 **setConfig** 注入到 design-components 的 config。
3. **解析**：左侧 aside 挂载时调用 **loadExtension(extensionConfigService.config)** → **ExtensionManager.load** 执行该工厂，得到 `[Promise<模块>, undefined]`，await 后读 **manifest**，new **Extension(manifest, options)** 并放入 manager。
4. **注册**：**ExtensionManager.register()** 对每个 extension 调用 **extension.register()** → **registerEntry()**，根据 auto-layout-resizing 的 **manifest.entries** 调用 **registerEntry('editor/file-menu', ...)** 等，菜单/导出/画板更多/尺寸面板等入口被写入 Store。
5. **展示**：布局和菜单组件从 Store 读取 entries，渲染「尺寸延展」等菜单项和按钮；用户点击后 **extension.run('open', ...)** → 如需则先 bootstrap（加载 `main`、activate）→ 再执行 command，打开尺寸延展的 UI。

如果你要排查「配置写了但页面上没有」，可以按顺序查：extensionConfig 是否传进 installDesign → init-design 是否把 config 赋给 extensionConfigService → aside 挂载时是否调用了 loadExtension → 该扩展的 manifest 是否有对应 entries → 对应 EntryTypes 的 Store 是否被正确写入并在布局里被使用。

---

## 六、完整示例：从 Promise 组件到 Aside 展示

下面以 **AI+ 我的面板**（`extension-ai-plus-my-panel`）为例，把「输入的 Promise 组件 → 解析 manifest → 左侧 Aside 出现 Tab → 点击后加载对应页面」的整条链路按步骤走一遍，并附带关键代码位置。

### 6.1 输入：Promise 组件在配置里长什么样

在 `init-editor.ts` 里有一项：

```ts
() => {
    return defineExtensionConfig(import('@design/extension-ai-plus-my-panel'), {
        enableSimpleMode: true,
    });
},
```

- **`import('@design/extension-ai-plus-my-panel')`**：动态 import，得到的是 **Promise\<Module\>**。该模块的默认导出不用，基座只认模块上的 **manifest**（及 **main**、**ui** 等）。
- **defineExtensionConfig(Promise, options)** 返回 **`[Promise<Module>, { enableSimpleMode: true }]`**，即 ExtensionInfoConfig。

此时还没有请求该 chunk，也没有读 manifest。

### 6.2 配置进基座、Aside 挂载时触发加载

- **installDesign** 把包含上述工厂的 **extensionConfig** 传给 **createInitDesignExtension** → 在 init-design 的 **activate** 里赋给 **ExtensionConfigService.config**。
- Agent 布局 **activate** 时通过 **getExtensionConfigService()** 拿到该 config，再 **setConfig({ extensionConfigService })** 注入到 design-components。
- 左侧 **Aside** 挂载时（`onPartMounted('aside')`）执行：

```ts
await loadExtension(extensionConfigService.config);
```

于是 **loadExtension** 被调用，参数就是那一串「工厂函数数组」。

### 6.3 解析：从 Promise 到 Manifest

**loadExtension** 内部调用 **ExtensionManager.load(extensionConfigs)**：

1. **执行工厂**：对每一项执行 `config()`。对 ai-plus-my-panel 这一项得到：
   - `[Promise<Module>, { enableSimpleMode: true }]`

2. **await Promise**：等待 `import('@design/extension-ai-plus-my-panel')` resolve，得到**模块对象**，例如：
   - `module.manifest`：扩展描述
   - `module.main`：可选，入口函数

3. **读取 manifest**：  
   扩展包里的定义大致如下（简化）：

```ts
// extensions/ai-plus-my-panel/src/index.ts
export const manifest: Manifest = {
    ...materialPanelManifest,   // id、name、title 等来自 manifest.json
    main: () => import('.'),
    beforeRegister(_ctx, options) { /* 合并 options，如 enableSimpleMode */ },
    entries: {
        'resource/activity-bar': [    // 即 EntryTypes.ResourceActivityBar
            {
                id: 'ai-plus-user',
                title: $tsl('我的'),
                iconComponent: IconUserCircle,
                group: 'agentTab',
                position: 2,
            },
        ],
    },
    ui: {
        [EntryTypes.ResourceActivityBar]: async () => {
            return import('./views/my-panel.vue').then((comp) => ({
                ResourceStationView: comp.default,
            }));
        },
    },
};
```

4. **mergeManifest(extensionInfo.manifest)**：把 JSON 里的字段和运行时 manifest 合并，得到最终 **manifest**。

5. **new Extension(manifest, options)**：用该 manifest 和 `{ enableSimpleMode: true }` 创建 **Extension** 实例，并 **extensions.set(ext.id, ext)** 放入 Manager。  
   至此：**Promise 已解析，manifest 已读出，Extension 实例已存在**，但尚未往任何 Store 写入口。

### 6.4 注册入口：manifest.entries 写进哪里

**load** 结束后会 **manager.register()**，对每个 Extension 执行 **extension.register()** → **registerEntry()**。

对 ai-plus-my-panel，**manifest.entries** 里只有 **`EntryTypes.ResourceActivityBar`**（即 `'resource/activity-bar'`），没有 file-menu、SettingContainer 等，因此会走「左侧资源栏」这一条：

1. **registerEntry()** 里判断：
   - `this.manifest.entries[EntryTypes.ResourceActivityBar]` 存在且长度为 1（上面那个「我的」entry）。

2. 调用 **apiContext.registerResourceStation(resourceStationEntries)**。  
   在 **ExtensionApi** 里，**registerResourceStation** 会调用 **useAddEntry** 的 **addActivityBar**。

3. **addActivityBar(entry, manifest)** 里会：
   - 用 **useResourceStationStore(pinia)** 拿到左侧栏的 Store；
   - 根据 entry 和 manifest 拼出一个 **schema**（包含 `key`、`label`、`extensionId`、`extensionCommand`、`icon`、`position`、**component: defineAsyncComponent(...)** 等）；
   - 其中 **component** 的 loader 会：若存在 **manifest.ui[EntryTypes.ResourceActivityBar]**，则 **await manifest.ui[EntryTypes.ResourceActivityBar]()**，得到 **{ ResourceStationView }**，再包成 Vue 组件；
   - 最后执行 **stationStore.addSchema(schema)**，把该 Tab 的配置推进 **resource-station** 的 schema 列表。

于是：**manifest 里的「我的」入口已经转成左侧栏 Store 里的一条 schema**，key 一般为 `manifest.alias || ${manifest.id}:${entry.command}`，extensionId 为 `manifest.id`（如 `ai-plus-my-panel`）。

### 6.5 Aside 如何加载并展示「对应页面」

左侧栏的 UI 是 **resource-station.vue**（或 Agent 布局下的等价组件）：

1. **数据来源**：  
   - 内置 Tab（模板、文字、图片等）由 **addSchema()**（schema.ts）在初始化时 **stationStore.addSchema(schema)** 写入；  
   - 扩展的 Tab（如「我的」）由上一步 **registerResourceStation → addActivityBar → stationStore.addSchema(schema)** 写入。  
   - 组件通过 **stationStore.schema**、**schemaGroups** 等计算属性拿到当前要展示的 Tab 列表。

2. **渲染 Tab 列表**：  
   - 用 **stationStore.schema** / **schemaGroups** 做 **v-for**，渲染左侧一排 Tab（图标 + 文案）。  
   - 每个 Tab 对应 schema 里记录的 **key**、**extensionId**、**label**、**icon** 等。

3. **点击某个 Tab（例如「我的」）时**：  
   - 会设置 **stationStore.currentTabName** 为当前 schema 的 key。  
   - 组件里通常有 **watch(currentTabName, ...)**：  
     - 先 **await loadExtension(extensionConfigService.config)**，保证扩展已 load（若已 load 则复用）；  
     - 再根据 **stationStore.schema[currentTabName]** 取到 **extensionId**，执行 **getExtensionManager().run(extensionId)**。  

4. **manager.run(extensionId)**：  
   - 若该扩展尚未 **bootstrap**，会先 **extension.bootstrap()** → 执行 **manifest.main(options)**（即 `import('.')`），加载扩展业务代码并 **activate(apiContext, options)**；  
   - 然后 **apiContext.triggerCommand** 或等价逻辑，让扩展准备好 UI。  
   - 左侧栏内容区会根据当前 schema 的 **component** 渲染：  
     - 该 **component** 是 **defineAsyncComponent**，loader 里会 **await manifest.ui[EntryTypes.ResourceActivityBar]()**，即加载 **my-panel.vue**，得到 **ResourceStationView**；  
     - 最终在 Aside 内容区挂载的就是 **my-panel.vue** 对应的视图。  

所以：**「对应页面」= 该 Tab 的 schema 里 component 的 loader 所加载的 Vue 组件（如 my-panel.vue）**，在用户点击「我的」Tab 后，通过 **run(extensionId)** + 异步 component 加载，显示在左侧栏内容区。

### 6.6 小结：一条线串起来

| 步骤 | 发生位置 | 输入 → 输出 |
|------|----------|--------------|
| 1. 输入 | init-editor.ts | 工厂 `() => defineExtensionConfig(import('@design/extension-ai-plus-my-panel'), { enableSimpleMode: true })` |
| 2. 进基座 | init-design activate | options.extensionConfig → ExtensionConfigService.config |
| 3. 触发加载 | onPartMounted('aside') | loadExtension(extensionConfigService.config) |
| 4. 解析 Promise | ExtensionManager.load | 执行工厂 → 得到 [Promise, options] → await Promise → 读 module.manifest |
| 5. 解析 manifest | 同上 | mergeManifest(manifest) → new Extension(manifest, options) → extensions.set(id, ext) |
| 6. 注册入口 | extension.registerEntry | entries[ResourceActivityBar] → registerResourceStation → addActivityBar → stationStore.addSchema(schema) |
| 7. Aside 展示 Tab | resource-station.vue | 读 stationStore.schema / schemaGroups → 渲染 Tab 列表，「我的」出现 |
| 8. 点击 Tab 加载页面 | watch(currentTabName) + run(extensionId) | bootstrap（main）→ schema.component 的 loader 执行 → manifest.ui[ResourceActivityBar]() → 加载 my-panel.vue → 内容区挂载 ResourceStationView |

这样，从「输入的 Promise 组件」到「manifest 被解析」再到「Aside 加载并展示对应页面」的完整流程就闭环了。
