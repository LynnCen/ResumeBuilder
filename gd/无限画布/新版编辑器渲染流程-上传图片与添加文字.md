# 新版编辑器渲染流程：上传图片与添加文字如何被加载

本文说明**新版渲染引擎**（Surface Renderer / 无限画布）下，「上传一张图片」或「添加一个文字」从用户操作到画布显示的完整链路。适用于 `enableSurfaceRender === true` 的平面/Agent 编辑器。

---

## 一、整体架构回顾

新版渲染采用 **Model → ViewModel → View** 的分离架构：

```
┌─────────────────────────────────────────────────────────────────┐
│  编辑器数据层 (Editor Model)                                      │
│  Page / Layout / Element (JSON 结构，存在 YDoc 中)                  │
└─────────────────────────────────────────────────────────────────┘
                              │
                    makeSnapshot / base.afterApply
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  渲染引擎 (Surface)                                               │
│  commit(action) → Processor.process(action)                      │
└─────────────────────────────────────────────────────────────────┘
                              │
                    vmEngine.buildVm(model)
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  ViewModel 层 (VmEngine)                                         │
│  ImageVm / TextVm / LayoutVm / PageVm … 与 Model 一一对应         │
└─────────────────────────────────────────────────────────────────┘
                              │
                    init / update / 纹理加载 / TypeTool 排版
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  View 层 (PixiJS / PISO 显示对象)                                 │
│  Sprite、Container、Canvas 等，挂到 Viewport 的 stage 上           │
└─────────────────────────────────────────────────────────────────┘
```

**关键点**：数据只存在编辑器侧（Model）；渲染侧不存业务数据，只根据 **commit 过来的 action** 增删改 ViewModel，再根据 Model 的当前值更新纹理/排版并绘制到 Canvas。

---

## 二、上传/添加图片的完整流程

### 2.1 业务侧：创建并添加图片元素

无论是「上传图片」还是「从素材库/AI 结果添加图片」，最终都会走到编辑器的统一 API：

```ts
// 典型用法（见 contents-loader、background msg-handler、use-editor-operations 等）
const imageElement = editor.createElement({
    type: 'image',
    url,           // 图片地址（上传后得到的 URL）
    width,
    height,
    metaInfo: { ... },
});
// 可选：bin-packing 等做位置计算
editor.plugins.invokeCommand('bin-packing:putByAlign', imageElement, { margin, maxColumns });
editor.addElement(imageElement, targetParent);
```

- **createElement**：只根据参数 new 出对应的 **ElementModel**（如 ImageElementModel），并做基础校验/默认值，**尚未加入画布**。
- **addElement**：把该 model **挂到父节点**（如当前 Layout）的 `elements` 数组里，并触发**快照与渲染同步**。

### 2.2 编辑器内核：addElement 与快照

`ElementService.addElement`（framework 的 element service）会：

1. 若传入的是纯数据（没有 `$id`/uuid），先 **createElement** 再当作 model 使用。
2. 把 **element** 插入 **parent.elements**（splice 或 push），并调用 `parent.linkChild` / `element.linkChild` 维护父子关系。
3. 调用 **makeSnapshot** 记录一次操作：

```ts
this._coreAPI.editor?.makeSnapshot({
    tag: 'add_element',
    element,
    parent,
    index,
});
```

之后在同一个「事务」里还会做 **buildElementMap**、增加 **elementMapUpdatePointer** 等，用于依赖 elementMap 的模块（如选区、连线）得到最新树结构。

### 2.3 快照应用与 base.afterApply

**makeSnapshot** 内部会：

1. 把这次操作转换成 YJS 的增量更新，写入 YDoc（若开启协同）。
2. 在「应用完本次变更」之后，派发事件：

```ts
this.$events.$emit('base.afterApply', action, transaction);
```

其中 `action` 即 `{ tag: 'add_element', element, parent, index }`。  
**base.afterApply** 的语义是：**数据已经更新完成，可以安全地根据最新 Model 去更新视图**。

### 2.4 渲染侧：core-plugin 监听并 commit

**useCommit**（core-plugin 的 hooks）在插件初始化时订阅了 `base.afterApply`：

```ts
editor.$events.$on('base.afterApply', onBaseCommitAction);
```

在 **onBaseCommitAction** 里根据 `action.tag` 把「编辑器语义」转成「渲染引擎语义」：

```ts
case 'add_element': {
    app.commit({
        type: 'add_element',
        parent: action.parent,
        element: action.element,
        index: action.index,
    });
    break;
}
```

这里的 **app** 即 **BoardSurface / PosterSurface**（设计态平面画布）。  
**commit** 会调用当前 Surface 的 **processor.process(action)**。

### 2.5 Processor：processAddElement

以 **BoardProcessor**（海报/平面模式同构）为例：

```ts
processAddElement(action: AddElement) {
    const { parent, element, index } = action;
    const parentVm = this.vmEngine.getVm(parent);   // 父节点对应的 ViewModel（如 LayoutVm）
    if (!parentVm) return;

    const elementVm = this.vmEngine.buildVm(element); // 为当前 element 创建或复用 ViewModel
    if (typeof index === 'number') {
        parentVm.addChildAt(elementVm, index);
    } else {
        parentVm.addChild(elementVm);
    }
}
```

- **getVm(parent)**：从 VmEngine 的 **elementMap / pageMap** 里取父节点已经存在的 ViewModel。
- **buildVm(element)**：若该 model 已有对应 ViewModel（按 uuid 缓存）则直接返回；否则 **createElement → generateElement → init**，并把 (model.uuid, elementVm) 写入 **elementMap**，子节点递归 **buildElement**（若有）。

也就是说：**每执行一次 add_element，就会在渲染树里多一个与 ImageElementModel 对应的 ViewModel 节点，并挂到父 ViewModel 的 children 上**。

### 2.6 VmEngine：从 Model 类型到 ViewModel 类型

**generateElement(model)** 根据 **model.type** 决定具体 ViewModel 类：

```ts
switch (model.type) {
    case 'mask':
    case 'image':
        element = new ImageVm();  // 图片（含 mask）→ ImageVm
        break;
    case 'video':
        element = new VideoVm();
        break;
    // ... text → TextVm, layout → LayoutVm, group → GroupVm 等
}
```

**createElement** 里会：

- **element.setModel(model)**  
- **element.init(model, context)**  
- 若有子节点且为父类型，再 **createElement** 子节点并 **addChild**。

所以「添加一张图片」在渲染侧就是：**new ImageVm() → setModel(imageModel) → init(model, context)**，然后被 **addChild** 到当前画板对应的 LayoutVm 下。

### 2.7 ImageVm / DynamicImage：图片如何被「加载」并画到画布

- **ImageVm** 继承自 **DynamicImage**（再继承 DynamicSprite 等），内部持有 **Texture**、**imageUrl**、**effectedResult** 等。
- **init(model, context)** 及后续 **update** 会根据 **model** 的当前属性（如 **url / imageUrl**、宽高、滤镜、特效等）决定：
  - 用 **url** 直接加载纹理，或  
  - 用 **imageUrl**（结果图）、**effectedResult** 等做特效/滤镜渲染后再生成纹理。  
- 纹理加载多为**异步**；加载完成后会 **complete()**，并触发 **element.loaded** 等事件，业务可监听。
- 渲染引擎会做**虚拟化**：只有进入视口或即将进入视口的元素才会真正去加载纹理、上传 GPU；移出视口的可能被回收或降级，以控制内存和性能。

所以「加载」的含义是：**ViewModel 根据 Model 的 url/imageUrl 等发起纹理加载，加载完成后把纹理画到对应的 Pixi 显示对象上，由 Ticker 驱动每帧绘制到 Canvas**。

---

## 三、添加文字的完整流程

### 3.1 业务侧：创建并添加文字元素

典型入口（如 **editorAddTextElement**、移动端 **addBasicTextElementToCanvas**、AI 的 **insertTextElement**）：

```ts
const item = scaleTextElement(editor, {
    type: 'text',
    content: i18n.$tsl('双击编辑文字'),
    fontFamily, fontWeight, fontSize, textAlign, color, width, height,
    contents: [ { fontFamily, content, ... } ],
    metaInfo: { materials: [ font ] },
    ...
});
const elem = editor.createElement(item);
const targetParent = calculateElementPlacement(editor, elem, enablePositionAdjustment);
editor.addElement(elem, targetParent);
editor.focusElement(element);
// 若需要，再 showElementEditor(element) 打开文字编辑器
```

- 若 **editor.enableSurfaceRender** 为 true，会先 **await getTypeTool()** 预加载 TypeTool，避免首字渲染闪动。
- **addElement** 与图片路径完全一致：写入 parent.elements → **makeSnapshot({ tag: 'add_element', ... })**。

### 3.2 从 add_element 到 TextVm 的创建

与图片相同：

1. **base.afterApply** 触发 → **onBaseCommitAction** → **app.commit({ type: 'add_element', parent, element, index })**  
2. **Processor.processAddElement** → **vmEngine.buildVm(element)**  
3. **generateElement(model)** 中 **model.type === 'text'** → **element = new TextVm()**  
4. **setModel** + **init(model, context)**，再 **parentVm.addChild(elementVm)**  

文字元素在渲染树里就对应一个 **TextVm** 节点。

### 3.3 TextVm：文字如何被「排版」并绘制

- **TextVm** 的 **updateText(model)** 会：
  - 通过 **context.modelAdaptor.transformTextModel(model)** 把编辑器的 Text 模型转成 TypeTool 所需的格式。
  - 调用 **typetool.shape(text, { width, height })** 做排版，得到 **layout**（含 bbox、行段、glyph 等）。
  - 根据 **layout** 和 **context** 决定用 **Canvas 2D** 还是 **Skia** 等后端绘制文字。
- 若使用新版渲染，通常会走 **TypeTool + Canvas/Skia** 的路径，而不是 DOM 输入框；**init** 时若需要会 **await getTypeToolIns()**，保证首次排版前 TypeTool 已就绪。

所以「添加文字」的加载流程是：**Model 已带 content/contents/字体等 → TextVm.init/updateText → TypeTool 排版 → 生成位图或矢量绘制指令 → 画到对应显示对象 → Ticker 渲染到画布**。

---

## 四、流程串联小结

| 阶段 | 上传/添加图片 | 添加文字 |
|------|----------------|----------|
| **1. 业务** | createElement({ type: 'image', url, width, height }) + addElement | createElement({ type: 'text', content, contents, ... }) + addElement（可能先 getTypeTool()） |
| **2. 编辑器** | ElementService.addElement：写入 parent.elements，makeSnapshot({ tag: 'add_element', element, parent, index }) | 同左 |
| **3. 快照** | YDoc 更新后 $emit('base.afterApply', action) | 同左 |
| **4. 渲染桥接** | useCommit 监听 base.afterApply → app.commit({ type: 'add_element', ... }) | 同左 |
| **5. Processor** | processAddElement → vmEngine.buildVm(element) → parentVm.addChild(elementVm) | 同左 |
| **6. VmEngine** | generateElement → ImageVm；buildVm 中 createElement → setModel → init，并缓存到 elementMap | generateElement → TextVm；同上 |
| **7. 显示** | ImageVm/DynamicImage：按 model.url/imageUrl 等加载纹理，虚拟化/视口内才加载，Ticker 绘制 | TextVm：TypeTool.shape 排版，再 Canvas/Skia 绘制，Ticker 绘制 |

**共性**：  
- 所有「新增元素」都统一走 **addElement → makeSnapshot(add_element) → base.afterApply → commit(add_element) → processAddElement → buildVm → addChild**。  
- **Model 永远在编辑器侧**；渲染侧只做 **Model → ViewModel → 纹理/排版 → 绘制**，不持久化业务数据。  
- 图片的「加载」= 纹理加载 + 虚拟化；文字的「加载」= TypeTool 排版 + 字体就绪 + 绘制。

若你遇到「加了图/文但画布不显示」，可沿这条链路排查：addElement 是否执行、是否有 makeSnapshot、base.afterApply 是否触发、commit 是否被调用、processAddElement 里 parentVm 是否存在、buildVm 是否生成了对应 ImageVm/TextVm，以及 ImageVm 的 url/imageUrl 是否有效、TextVm 的 TypeTool 是否已加载等。
