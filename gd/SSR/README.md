# SSR (Server-Side Rendering) 技术文档集

> **文档集概述**  
> 本目录包含了服务端渲染（SSR）技术的完整文档体系，从基础概念到核心机制，从鉴权方案到 AB 实验优化，涵盖了 SSR 架构的各个方面。

---

## 📚 文档导航

### 🎯 第一层级：基础入门

从零开始了解 SSR，掌握前后端同构的核心概念。

| 文档 | 核心内容 | 适合人群 |
|------|---------|---------|
| **[01-基础入门-前后端同构快速入门](01-基础入门-前后端同构快速入门.md)** | SSR 常见问题、生命周期缓存、辅助方法 | 🎯 SSR 初学者 |
| **[02-基础入门-SSR接入文档](02-基础入门-SSR接入文档.md)** | 实际接入流程、配置指南 | 🎯 实践接入 |

### 🔧 第二层级：核心机制

深入理解 SSR 的数据请求与水合机制，这是 SSR 的核心。

| 文档 | 核心内容 | 适合人群 |
|------|---------|---------|
| **[03-核心机制-SSR场景下接口数据请求及水合机制](03-核心机制-SSR场景下接口数据请求及水合机制.md)** | 数据请求、水合原理、状态同步 | 🔧 深入理解 SSR |
| **[04-核心机制-RFC-SSR场景下接口数据请求及水合机制更新](04-核心机制-RFC-SSR场景下接口数据请求及水合机制更新.md)** | 机制升级、性能优化 | 🔧 架构优化 |

### 🔐 第三层级：鉴权与 Token 管理

SSR 场景下的身份认证与授权机制，确保安全性与用户体验。

| 文档 | 核心内容 | 适合人群 |
|------|---------|---------|
| **[05-鉴权-RFC16-SSR鉴权流程标准化提议](05-鉴权-RFC16-SSR鉴权流程标准化提议.md)** | 鉴权流程、水合问题、缓存污染 | 🔐 鉴权架构 |
| **[06-鉴权-SSR中使用OAuth和JWT的最佳实践](06-鉴权-SSR中使用OAuth和JWT的最佳实践.md)** | OAuth 2.0、JWT、安全最佳实践 | 🔐 安全实践 |
| **[07-鉴权-服务端刷新tokens并发问题与解决方案](07-鉴权-服务端刷新tokens并发问题与解决方案.md)** | Token 并发刷新、分布式锁、请求去重 | 🔐 并发控制 |
| **[08-鉴权-Token应当由服务端还是客户端刷新](08-鉴权-Token应当由服务端还是客户端刷新.md)** | Token 刷新策略、技术决策 | 🔐 架构决策 |

### 🧪 第四层级：AB 实验系列

SSR 场景下的 AB 实验基础设施，从缓存策略到跨平台支持。

| 文档 | 核心内容 | 适合人群 |
|------|---------|---------|
| **[09-AB实验-RFC12.1-SSR场景下的AB实验与缓存策略改进](09-AB实验-RFC12.1-SSR场景下的AB实验与缓存策略改进.md)** | AB 实验基础、缓存策略、Cache Key | 🧪 AB 基础 |
| **[10-AB实验-RFC12.2-SSR场景下的AB实验数据获取优化](10-AB实验-RFC12.2-SSR场景下的AB实验数据获取优化.md)** | 数据获取优化、性能提升 | 🧪 性能优化 |
| **[11-AB实验-RFC12.3-提高AB缓存命中率](11-AB实验-RFC12.3-提高AB缓存命中率.md)** | 缓存命中率优化、缓存策略 | 🧪 缓存优化 |
| **[12-AB实验-RFC12.4-AB支持花瓣服务端](12-AB实验-RFC12.4-AB支持花瓣服务端.md)** | 跨平台支持、花瓣适配 | 🧪 跨平台 |

---

## 🗺️ 学习路径

### 路径 1：新手入门（推荐）

```
1. 前后端同构快速入门
   ↓ 了解 SSR 基础概念
2. SSR 接入文档
   ↓ 掌握实践接入流程
3. SSR 场景下接口数据请求及水合机制
   ↓ 理解核心原理
4. 根据需求选择专题深入
   ├─ 鉴权场景 → 鉴权系列文档
   └─ AB 实验 → AB 实验系列文档
```

### 路径 2：架构设计

```
1. 核心机制文档（数据请求与水合）
   ↓
2. 鉴权系列文档（完整的鉴权方案）
   ↓
3. AB 实验系列文档（实验基础设施）
   ↓
4. 综合应用到实际项目
```

### 路径 3：问题导向

根据遇到的具体问题，直接查阅相关文档：

| 问题类型 | 推荐文档 |
|---------|---------|
| **水合失败** | 核心机制系列、前后端同构快速入门 |
| **鉴权问题** | 鉴权系列（RFC 16、OAuth/JWT） |
| **Token 刷新** | Token 并发问题、Token 刷新策略 |
| **AB 实验不生效** | RFC 12.1、RFC 12.2 |
| **缓存命中率低** | RFC 12.3 |
| **跨平台 AB** | RFC 12.4 |

---

## 🔑 核心概念

### SSR (Server-Side Rendering)

**定义**：在服务器端执行前端框架代码，生成完整的 HTML 页面返回给浏览器。

**核心优势**：
- ✅ **SEO 友好**：搜索引擎可以直接抓取完整内容
- ✅ **首屏快速**：用户更快看到内容（TTFB、FCP、LCP 优化）
- ✅ **用户体验**：减少白屏时间，提升感知性能

**核心挑战**：
- ⚠️ **水合问题**：服务端与客户端状态不一致
- ⚠️ **环境差异**：服务端没有 `window`、`document` 等浏览器 API
- ⚠️ **请求污染**：多用户请求共享服务端代码
- ⚠️ **缓存复杂**：需要考虑个性化内容与缓存的平衡

### 水合 (Hydration)

**定义**：客户端 JavaScript 接管服务端渲染的 HTML，使其变为可交互的动态页面。

**工作流程**：

```
服务端渲染 HTML
   ↓
浏览器接收并显示静态 HTML（用户已可见）
   ↓
加载客户端 JavaScript
   ↓
水合：将事件监听器绑定到 DOM
   ↓
页面变为可交互
```

**关键要求**：
- 🔴 **状态一致**：服务端和客户端的初始渲染结果必须完全一致
- 🔴 **数据同步**：服务端获取的数据需要传递给客户端
- 🔴 **生命周期**：理解 SSR 和 CSR 的生命周期差异

### 前后端同构 (Isomorphic / Universal)

**定义**：同一套代码既可以在服务端运行，也可以在客户端运行。

**核心价值**：
- ✅ 代码复用，减少维护成本
- ✅ 统一的开发体验
- ✅ 更容易实现 SSR

**实现要点**：
- 📦 使用条件导出适配不同环境
- 📦 避免单例模式，防止请求污染
- 📦 使用辅助方法屏蔽环境差异
- 📦 区分 SSR 和 CSR 生命周期

### 生命周期缓存 (Lifecycle Cache)

**定义**：将服务端数据请求的结果随 HTML 传递给客户端，避免重复请求。

**工作原理**：

```
服务端：
  ├─ 执行数据请求
  ├─ 缓存请求结果
  ├─ 渲染 HTML
  └─ 将缓存数据序列化后嵌入 HTML

客户端：
  ├─ 解析 HTML 中的缓存数据
  ├─ 水合时使用缓存数据（不重新请求）
  └─ 用户交互后才发起新请求
```

**关键价值**：
- ✅ 避免数据请求重复
- ✅ 确保水合时状态一致
- ✅ 提升性能

### Cache Key

**定义**：缓存系统用于标识缓存内容的唯一键。

**SSR 场景的 Cache Key 组成**：

```
Cache Key = hash(
  URL +
  登录状态 +
  用户ID（登录后）+
  AB 实验组 +
  其他个性化因素
)
```

**AB 实验的 Cache Key 策略**：

```
未优化：
  每个用户一个缓存 → 缓存爆炸

优化后：
  按 AB 实验组分组 → 有限的缓存版本
  
示例：
  2 个实验 → 2^2 = 4 个缓存版本
  3 个实验 → 2^3 = 8 个缓存版本
```

---

## 📊 技术架构图

### SSR 整体架构

```
用户请求
   ↓
CDN / 边缘节点
   ↓
BFF 层（King BFF）
   ├─ 鉴权
   ├─ AB 实验数据获取
   ├─ 缓存检查
   └─ ↓
Meta SSR 服务
   ├─ 执行 Vue/React SSR
   ├─ 数据请求（携带 AB Tag）
   ├─ 渲染 HTML
   ├─ 生成缓存数据
   └─ ↓
返回 HTML + 内嵌数据
   ↓
浏览器
   ├─ 显示 HTML
   ├─ 加载 JavaScript
   ├─ 水合（使用内嵌数据）
   └─ 变为可交互
```

### SSR 鉴权流程

```
1. 用户请求带 Cookie（Access Token + Refresh Token）
   ↓
2. BFF 验证 Access Token
   ├─ 有效 → 继续
   └─ 无效 → 尝试刷新
       ├─ Refresh Token 有效 → 刷新 Access Token
       └─ Refresh Token 无效 → 重定向登录
          ↓
3. SSR 渲染（携带用户信息）
   ↓
4. 返回 HTML（不包含 Token）
   ↓
5. 客户端水合（从 Cookie 读取 Token）
```

### AB 实验在 SSR 中的流程

```
1. 用户请求
   ↓
2. 检查 Cookie 中的 x-ab-test-id
   ├─ 存在 → 使用缓存的 AB 组
   └─ 不存在 → 请求 AB 服务
       ├─ 计算 AB 组
       ├─ 生成 x-ab-test-id
       └─ 种入 Cookie
          ↓
3. 组装 Cache Key（包含 AB 组）
   ↓
4. 检查缓存
   ├─ 命中 → 返回缓存
   └─ 未命中 → SSR 渲染
       ├─ 请求接口（携带 AB Tag）
       ├─ 渲染对应的 AB 实验内容
       └─ 写入缓存
```

---

## 🛠️ 快速开始

### 场景 1：第一次接入 SSR

**步骤**：

1. 阅读 [前后端同构快速入门](01-基础入门-前后端同构快速入门.md)
2. 了解常见陷阱：
   - ❌ 使用浏览器 API（`window`、`document`）
   - ❌ 单例模式导致请求污染
   - ❌ 服务端客户端状态不一致
3. 使用生命周期缓存：

```javascript
// Vue 3
import { cacheProvider } from '@web-widget/helpers/cache';

const data = await cacheProvider('cache_key', async () => {
  return await fetchData();
});

// Vue 2
import { syncCacheProvider } from '@web-widget/helpers/cache';

const data = syncCacheProvider('cache_key', async () => {
  return await fetchData();
});
```

4. 阅读 [SSR 接入文档](02-基础入门-SSR接入文档.md) 完成实际接入

### 场景 2：实现 SSR 鉴权

**步骤**：

1. 阅读 [RFC 16: SSR 鉴权流程标准化提议](05-鉴权-RFC16-SSR鉴权流程标准化提议.md)
2. 了解核心原则：
   - ✅ Token 存储在 HttpOnly Cookie
   - ✅ SSR 从 BFF 获取鉴权状态
   - ✅ 避免 Token 包含在 HTML 中
3. 实现 Token 刷新：
   - 阅读 [服务端刷新 tokens 并发问题与解决方案](07-鉴权-服务端刷新tokens并发问题与解决方案.md)
   - 使用分布式锁或请求去重
4. 参考 [OAuth 和 JWT 最佳实践](06-鉴权-SSR中使用OAuth和JWT的最佳实践.md)

### 场景 3：支持 AB 实验

**步骤**：

1. 阅读 [RFC 12.1: SSR 场景下的 AB 实验与缓存策略改进](09-AB实验-RFC12.1-SSR场景下的AB实验与缓存策略改进.md)
2. 理解核心机制：
   - AB SDK 适配 SSR
   - AB 组纳入 Cache Key
   - 使用 Cookie 缓存 AB 组
3. 优化性能：
   - 阅读 [RFC 12.2: 数据获取优化](10-AB实验-RFC12.2-SSR场景下的AB实验数据获取优化.md)
   - 阅读 [RFC 12.3: 提高缓存命中率](11-AB实验-RFC12.3-提高AB缓存命中率.md)
4. 跨平台支持：
   - 阅读 [RFC 12.4: AB 支持花瓣服务端](12-AB实验-RFC12.4-AB支持花瓣服务端.md)

---

## ⚠️ 常见问题与陷阱

### 问题 1：水合失败

**现象**：

```
Warning: Text content did not match. 
Server: "Loading..." Client: "Hello World"
```

**原因**：
- 服务端和客户端渲染结果不一致
- 数据请求在客户端重新执行，结果不同
- 使用了浏览器特定 API

**解决方案**：
- ✅ 使用生命周期缓存同步数据
- ✅ 检查服务端是否有浏览器 API 调用
- ✅ 确保初始状态完全一致

### 问题 2：请求污染

**现象**：

```
用户 A 访问 → 看到用户 B 的数据
```

**原因**：
- 使用单例模式缓存用户数据
- 全局变量在多个请求间共享

**解决方案**：
- ✅ 避免单例模式
- ✅ 基于请求上下文创建实例
- ✅ 使用元框架提供的 `context()` 方法

### 问题 3：AB 实验不生效

**现象**：
- 首次访问没有 AB 实验内容
- 刷新后又看到 AB 实验内容

**原因**：
- 缓存页面没有 AB 实验
- AB SDK 没有适配 SSR

**解决方案**：
- ✅ 参考 RFC 12.1 改造 AB SDK
- ✅ 将 AB 组纳入 Cache Key
- ✅ 使用 Cookie 缓存 AB 组

### 问题 4：Token 刷新并发问题

**现象**：
- 多个并发请求同时刷新 Token
- Token 被覆盖或失效

**原因**：
- 没有并发控制机制

**解决方案**：
- ✅ 使用分布式锁（Redis SETNX）
- ✅ 实现请求去重
- ✅ 参考 RFC 中的 6 种解决方案

---

## 📈 性能优化

### 关键性能指标

| 指标 | 说明 | 目标 | SSR 优势 |
|------|------|------|---------|
| **TTFB** | Time to First Byte | < 200ms | ✅ 缓存优化 |
| **FCP** | First Contentful Paint | < 1.8s | ✅ SSR 直接输出内容 |
| **LCP** | Largest Contentful Paint | < 2.5s | ✅ 关键内容服务端渲染 |
| **TTI** | Time to Interactive | < 3.8s | ⚠️ 需要等待 JS 加载 |
| **Hydration Time** | 水合时间 | < 500ms | ⚠️ 需要优化 |

### 优化策略

**1. 缓存策略**

```
登录前页面：
  - maxAge: 10 分钟
  - staleWhileRevalidate: 1 周
  - staleIfError: 1 周

登录后页面：
  - maxAge: 1 分钟
  - 按用户 ID 分组缓存
```

**2. AB 实验缓存优化**

```
问题：AB 实验导致缓存碎片化
   2 个实验 → 4 个缓存版本
   3 个实验 → 8 个缓存版本
   
优化：
   - 合理控制实验数量
   - 及时下线过期实验
   - 使用 Cookie 缓存 AB 组
```

**3. 数据请求优化**

```
- 使用生命周期缓存避免重复请求
- 并行请求而非串行
- 服务端请求直连内网，更快
```

---

## 🔗 相关资源

### 官方文档

- [Vue SSR Guide](https://vuejs.org/guide/scaling-up/ssr.html)
- [React Server Components](https://react.dev/reference/react/use-server)
- [Vite SSR](https://vitejs.dev/guide/ssr.html)

### 内部资源

- Meta SSR 框架文档
- @web-widget/helpers API 文档
- King BFF 接入文档

### 相关 RFC

- RFC 10: 实施 HTTP 缓存策略加速站点速度
- RFC 13: 实施 CDN 加速网站访问
- RFC 15/20: Importmap 生成工具 WPM2/WPM3

---

## 💡 贡献指南

如果你发现文档有误或需要补充：

1. 在 Confluence 原文档提出修改建议
2. 联系前端基建团队更新
3. 定期同步最新版本到本地

---

## ❓ FAQ

### Q1：什么时候应该使用 SSR？

**适合 SSR**：
- ✅ 需要 SEO（首页、详情页、落地页）
- ✅ 首屏性能要求高
- ✅ 用户体验优先

**不适合 SSR**：
- ❌ 纯后台管理系统
- ❌ 高度交互的应用（如编辑器）
- ❌ 实时性要求极高的应用

### Q2：SSR 和 CSR 可以混合使用吗？

**可以！**

```
整体页面：SSR（首屏快、SEO 友好）
   ↓
部分组件：CSR（复杂交互、实时数据）
```

使用 `<ClientOnly>` 组件包裹纯客户端组件。

### Q3：如何调试 SSR 问题？

**工具**：
- 服务端：Node.js Debugger
- 客户端：Chrome DevTools
- 网络：Charles / Fiddler
- 性能：Lighthouse

**技巧**：
- 对比服务端和客户端的渲染结果
- 检查生命周期缓存是否正确传递
- 使用 `console.log` 区分运行环境

### Q4：SSR 的性能瓶颈在哪里？

**主要瓶颈**：

1. **服务端渲染耗时**
   - 解决：缓存、代码分割、按需渲染

2. **数据请求耗时**
   - 解决：并行请求、Redis 缓存、内网直连

3. **水合耗时**
   - 解决：减少 JS 体积、延迟非关键脚本

4. **缓存命中率低**
   - 解决：优化 Cache Key 策略、控制实验数量

---

## 📝 文档维护

**维护团队**：前端基建团队  
**整理日期**：2025-01-25  
**文档版本**：v1.0

**更新记录**：
- 2025-01-25：初始版本，整合 13 篇 SSR 相关文档

---

**Happy Coding with SSR! 🚀**
