# 前后端同构快速入门

> **文档来源**  
> Confluence: https://doc.huanleguang.com/pages/viewpage.action?pageId=386676110

---

## 文档概述

本文档是 SSR（服务端渲染）的入门指南，帮助开发者快速理解前后端同构的核心概念，避免常见陷阱，掌握 SSR 开发的最佳实践。

**核心内容**：
- ⚠️ SSR 中 98% 的 BUG 来源
- 📘 Vue 官方 SSR 指南要点
- 💾 生命周期缓存机制
- 🔧 辅助方法简化同构开发
- 📦 基础包的同构适配

---

## 一、常见问题：98% 的 BUG 来源

### 1.1 核心问题清单

我们在 SSR 中遇到的 **98% 的 BUG** 来源于以下 4 个问题：

| 问题 | 说明 | 影响 |
|------|------|------|
| **1. 水合失败** | SSR 和 CSR 在初次渲染阶段状态不一致 | 🔴 客户端组件无法复用服务端渲染的 HTML |
| **2. 浏览器 API** | 在 SSR 渲染生命周期中使用浏览器特定 API | 🔴 服务端 500 或启动失败 |
| **3. 响应式数据** | 在 Vue 组件 SSR 渲染生命周期中使用响应式数据 | 🔴 HTML 没有按照预期输出 |
| **4. 单例模式** | 基础包使用单例模式缓存用户状态 | 🔴 造成不同请求污染 |

### 1.2 问题详解

#### 问题 1：水合失败

**什么是水合？**

```
服务端渲染生成 HTML
   ↓
浏览器接收并显示 HTML（用户已可见）
   ↓
加载客户端 JavaScript
   ↓
水合：客户端 JS "接管" HTML，绑定事件监听器
   ↓
页面变为可交互
```

**失败场景示例**：

```vue
<template>
  <div>{{ message }}</div>
</template>

<script setup>
// ❌ 错误：服务端和客户端获取的数据不同
const message = ref('');

onMounted(() => {
  // 只在客户端执行
  message.value = await fetchMessage();
});
</script>
```

**问题表现**：

```
服务端渲染：<div></div>
客户端渲染：<div>Hello World</div>

❌ 不匹配！水合失败！
```

**正确做法**：使用生命周期缓存（见后文）

#### 问题 2：使用浏览器 API

**错误示例**：

```javascript
// ❌ 错误：服务端没有 window 对象
export default {
  setup() {
    const width = window.innerWidth;  // ← 服务端运行时报错！
    return { width };
  }
}
```

**后果**：
- 🔴 服务端启动失败
- 🔴 500 Internal Server Error
- 🔴 整个应用无法访问

**正确做法**：

```javascript
// ✅ 正确：检查环境
export default {
  setup() {
    const width = ref(0);
    
    onMounted(() => {
      // onMounted 只在客户端执行
      width.value = window.innerWidth;
    });
    
    return { width };
  }
}
```

**常见的浏览器 API**：
- `window`
- `document`
- `location`
- `localStorage`
- `sessionStorage`
- `navigator`
- `XMLHttpRequest`

#### 问题 3：响应式数据问题

**Vue 3 中的问题示例**：

```vue
<script setup>
import { ref, watch } from 'vue';

const data = ref(null);

// ❌ 错误：在服务端 watch 不会停止
watch(data, (newVal) => {
  console.log('Data changed:', newVal);
  // 在服务端渲染期间，这可能导致意外行为
});

// 服务端也会执行这个赋值
data.value = await fetchData();
</script>
```

**原因**：
- 服务端没有响应式更新
- `watch`、`computed` 等在服务端的行为与客户端不同

**正确理解**：
- ✅ 服务端：数据是静态的，渲染一次后就结束
- ✅ 客户端：数据是响应式的，变化会触发重新渲染

#### 问题 4：单例模式导致请求污染

**错误示例**：

```javascript
// user-service.js
// ❌ 错误：单例模式
class UserService {
  constructor() {
    this.currentUser = null;
  }
  
  setUser(user) {
    this.currentUser = user;  // ← 所有请求共享这个对象！
  }
  
  getUser() {
    return this.currentUser;
  }
}

// 导出单例
export default new UserService();
```

**问题场景**：

```
时间线：
10:00:00.100 - 用户 A 请求到达，设置 currentUser = A
10:00:00.150 - 用户 B 请求到达，设置 currentUser = B  ← 覆盖了！
10:00:00.200 - 用户 A 的渲染完成，读取 currentUser = B  ← 用户 A 看到了用户 B 的数据！
```

**后果**：
- 🔴 用户 A 看到用户 B 的数据
- 🔴 严重的隐私泄露问题
- 🔴 生产事故

**正确做法**：基于请求上下文创建实例（见后文）

---

## 二、遵循 Vue 官方 SSR 指南

### 2.1 核心原则

**来源**：[Vue.js 官方 SSR 指南](https://vuejs.org/guide/scaling-up/ssr.html#writing-ssr-friendly-code)

| 原则 | 说明 | 示例 |
|------|------|------|
| **1. 服务端无响应式** | 在服务端是没有响应式的 | `watch`、`computed` 不会响应更新 |
| **2. 生命周期差异** | `onMounted`、`onUpdated` 只在客户端执行 | 服务端只执行 `setup` 和 `onServerPrefetch` |
| **3. 避免浏览器 API** | 不要在 SSR 期间访问浏览器专属 API | `window`、`document`、`location` |
| **4. 避免单例模式** | 不要使用单例模式，会造成请求污染 | 使用工厂函数创建实例 |
| **5. 状态一致** | 组件在服务端和客户端的初次渲染状态应当保持一致 | 使用生命周期缓存同步数据 |

### 2.2 Vue 生命周期对比

**Vue 3 Composition API**：

| 生命周期钩子 | 服务端 | 客户端 | 说明 |
|------------|-------|-------|------|
| `setup()` | ✅ | ✅ | 同时执行 |
| `onServerPrefetch()` | ✅ | ❌ | 仅服务端 |
| `onBeforeMount()` | ❌ | ✅ | 仅客户端 |
| `onMounted()` | ❌ | ✅ | 仅客户端 |
| `onBeforeUpdate()` | ❌ | ✅ | 仅客户端 |
| `onUpdated()` | ❌ | ✅ | 仅客户端 |
| `onBeforeUnmount()` | ❌ | ✅ | 仅客户端 |
| `onUnmounted()` | ❌ | ✅ | 仅客户端 |

**关键理解**：

```javascript
export default {
  setup() {
    // ✅ 服务端和客户端都会执行
    console.log('setup - 同时执行');
    
    onServerPrefetch(async () => {
      // ✅ 仅服务端执行
      console.log('服务端预取数据');
    });
    
    onMounted(() => {
      // ✅ 仅客户端执行
      console.log('客户端挂载完成');
      // 可以安全地访问 window、document
    });
  }
}
```

---

## 三、生命周期缓存

### 3.1 问题背景

**前后端同构的挑战**：

```
同一份组件代码会运行两次：
   1️⃣ 服务端执行（生成 HTML）
   2️⃣ 客户端执行（水合 + 交互）

问题：
   - 数据请求会执行两次
   - 两次请求的结果可能不同
   - 导致水合失败
```

**示例场景**：

```vue
<template>
  <div>{{ article.title }}</div>
</template>

<script setup>
const article = ref(null);

// ❌ 问题：这个请求会执行两次
article.value = await fetchArticle(id);
</script>
```

**执行流程**：

```
服务端：
  fetchArticle(123) → { title: "文章标题 A" }
  渲染 HTML：<div>文章标题 A</div>

客户端：
  fetchArticle(123) → { title: "文章标题 B" }  ← 内容可能已更新
  渲染 HTML：<div>文章标题 B</div>
  
❌ 水合失败！
```

### 3.2 解决方案：生命周期缓存

**Meta SSR** 提供的「**生命周期缓存**」辅助方法：

> 将服务端运行的数据请求结果伴随 HTML 流传送到客户端

**工作原理**：

![生命周期缓存工作原理](../前后端同构快速入门/attachments/image2024-5-23_23-56-59.png)

**流程说明**：

```
1. 服务端执行 cacheProvider
   ↓
2. 发起数据请求
   ↓
3. 缓存请求结果
   ↓
4. 渲染 HTML
   ↓
5. 将缓存数据序列化后嵌入 HTML
   ↓
6. 浏览器接收 HTML
   ↓
7. 客户端执行 cacheProvider
   ↓
8. 直接使用缓存数据（不发起请求）
   ↓
9. 水合成功！
```

### 3.3 Vue 3 使用方式

**基础用法**：

```vue
<template>
  <div>
    <h1>{{ data.title }}</h1>
    <p>ID: {{ data.id }}</p>
    <p>Name: {{ data.name }}</p>
  </div>
</template>

<script setup>
import { cacheProvider } from '@web-widget/helpers/cache';
import { fetchData } from './fetch-data';

// ✅ 使用生命周期缓存
const data = await cacheProvider('cache_key', async () => {
  const { id, name, title } = await fetchData();
  return { id, name, title };
});
</script>
```

**关键点**：

1. **唯一的 cache key**：第一个参数是缓存键，必须唯一
2. **异步函数**：第二个参数是返回 Promise 的函数
3. **自动缓存**：服务端执行后自动缓存，客户端直接使用缓存

**多个数据请求**：

```vue
<script setup>
import { cacheProvider } from '@web-widget/helpers/cache';

// 请求用户信息
const user = await cacheProvider('user_info', async () => {
  return await fetchUser();
});

// 请求文章列表
const articles = await cacheProvider('article_list', async () => {
  return await fetchArticles();
});

// 请求评论
const comments = await cacheProvider('comments', async () => {
  return await fetchComments();
});
</script>
```

### 3.4 Vue 2 使用方式

**基础用法**：

```vue
<template>
  <div>
    <h1>{{ data.title }}</h1>
    <p>ID: {{ data.id }}</p>
    <p>Name: {{ data.name }}</p>
  </div>
</template>

<script>
import { syncCacheProvider } from '@web-widget/helpers/cache';
import { fetchData } from './fetch-data';

export default {
  data() {
    return {
      // ✅ 使用同步版本的生命周期缓存
      data: syncCacheProvider('cache_key', async () => {
        const { id, name, title } = await fetchData();
        return { id, name, title };
      })
    };
  }
}
</script>
```

**注意事项**：

- Vue 2 使用 `syncCacheProvider`（同步版本）
- Vue 3 使用 `cacheProvider`（异步版本）
- cache key 在整个应用中必须唯一

### 3.5 最佳实践

**1. Cache Key 命名规范**：

```javascript
// ✅ 推荐：使用描述性的名称
cacheProvider('user_profile_123', ...)
cacheProvider('article_list_page_1', ...)
cacheProvider('comments_article_456', ...)

// ❌ 不推荐：过于简单
cacheProvider('data', ...)
cacheProvider('list', ...)
```

**2. 包含动态参数**：

```javascript
// ✅ 推荐：将参数包含在 key 中
const articleId = params.id;
const article = await cacheProvider(`article_${articleId}`, async () => {
  return await fetchArticle(articleId);
});

// ❌ 不推荐：key 不包含参数
const article = await cacheProvider('article', async () => {
  return await fetchArticle(articleId);  // 不同 ID 会覆盖缓存
});
```

**3. 只缓存必要数据**：

```javascript
// ✅ 推荐：只返回需要的字段
const data = await cacheProvider('user', async () => {
  const response = await fetchUser();
  return {
    id: response.id,
    name: response.name,
    avatar: response.avatar
  };
});

// ❌ 不推荐：缓存整个响应（可能很大）
const data = await cacheProvider('user', async () => {
  return await fetchUser();  // 包含大量不需要的字段
});
```

---

## 四、使用仅客户端渲染模式

### 4.1 适用场景

对于**不支持 SSR 的组件**，可以使用仅客户端渲染模式：

**典型场景**：
- 📊 图表组件（依赖 Canvas API）
- 🎨 富文本编辑器（大量 DOM 操作）
- 🗺️ 地图组件（依赖浏览器 API）
- 📹 视频播放器（依赖 Media API）

### 4.2 使用方式

**Vue 3**：

```vue
<template>
  <div>
    <h1>服务端渲染的内容</h1>
    
    <!-- 仅在客户端渲染 -->
    <ClientOnly>
      <ChartComponent :data="chartData" />
    </ClientOnly>
  </div>
</template>

<script setup>
import { ClientOnly } from '@web-widget/vue';
import ChartComponent from './ChartComponent.vue';

const chartData = [/* ... */];
</script>
```

**Vue 2**：

```vue
<template>
  <div>
    <h1>服务端渲染的内容</h1>
    
    <!-- 仅在客户端渲染 -->
    <client-only>
      <chart-component :data="chartData" />
    </client-only>
  </div>
</template>

<script>
import { ClientOnly } from '@web-widget/vue';
import ChartComponent from './ChartComponent.vue';

export default {
  components: {
    'client-only': ClientOnly,
    'chart-component': ChartComponent
  },
  data() {
    return {
      chartData: [/* ... */]
    };
  }
}
</script>
```

### 4.3 占位内容

**提供加载占位符**：

```vue
<ClientOnly>
  <template #default>
    <!-- 客户端渲染的内容 -->
    <ChartComponent :data="chartData" />
  </template>
  
  <template #placeholder>
    <!-- 服务端渲染的占位符 -->
    <div class="chart-placeholder">
      加载中...
    </div>
  </template>
</ClientOnly>
```

---

## 五、在基础包中提供同构模式

### 5.1 什么是基础包

**基础包**：项目中的公共模块，如：

- 🔐 登录认证
- 👤 用户信息
- 🎯 AB 实验
- 🎚️ 灰度控制
- 📊 埋点统计
- 🛡️ 权限管理

### 5.2 同构适配要求

**核心要求**：

> 基础包应当在**保持接口签名不变**的基础上自适应 CSR 与 SSR 的工作模式

**好处**：
- ✅ 业务代码无需改动
- ✅ 自动适配不同环境
- ✅ 降低维护成本

### 5.3 消除单例模式

#### 问题分析

**单例模式的风险**：

```javascript
// ❌ 错误的单例模式
class AuthService {
  constructor() {
    this.token = null;
    this.user = null;
  }
  
  setAuth(token, user) {
    this.token = token;  // ← 所有请求共享！
    this.user = user;
  }
}

export default new AuthService();  // ← 单例导出
```

**请求污染场景**：

```
时间线（毫秒级别）：
t0: 用户 A 请求，设置 token=A, user=A
t1: 用户 B 请求，设置 token=B, user=B  ← 覆盖！
t2: 用户 A 的请求使用 token=B  ← 用错了！
t3: 用户 B 的请求使用 token=B  ← 正确
t4: 用户 A 看到了用户 B 的数据  ← 隐私泄露！
```

#### 解决方案：工厂函数

**正确的做法**：

```javascript
// ✅ 使用工厂函数
class AuthService {
  constructor() {
    this.token = null;
    this.user = null;
  }
  
  setAuth(token, user) {
    this.token = token;
    this.user = user;
  }
}

// 导出工厂函数，而不是实例
export function createAuthService() {
  return new AuthService();
}
```

**使用方式**：

```javascript
// 每个请求创建独立的实例
import { createAuthService } from './auth-service';

export default defineMiddleware(() => {
  const authService = createAuthService();  // ← 每次都是新实例
  authService.setAuth(token, user);
  // ...
});
```

#### 基于上下文的实例

**更优雅的方式**：

```javascript
// auth-service.js
import { context } from '@web-widget/helpers/context';

class AuthService {
  constructor(request) {
    this.request = request;
  }
  
  getToken() {
    // 从请求上下文获取
    return this.request.cookies.get('token');
  }
}

export function useAuth() {
  const { request } = context();  // 获取当前请求上下文
  return new AuthService(request);
}
```

**使用方式**：

```javascript
// 组件中使用
import { useAuth } from './auth-service';

export default {
  setup() {
    const auth = useAuth();  // 自动绑定到当前请求
    const token = auth.getToken();
    // ...
  }
}
```

### 5.4 使用条件导出

**目的**：让一个包自适应不同的环境

**package.json 配置**：

```json
{
  "name": "@company/auth",
  "type": "module",
  "exports": {
    ".": {
      "worker": {
        "types": "./dist/auth.server.d.ts",
        "development": "./src/server.ts",
        "default": "./dist/auth.server.js"
      },
      "browser": {
        "types": "./dist/auth.client.d.ts",
        "development": "./src/client.ts",
        "default": "./dist/auth.client.js"
      },
      "default": {
        "types": "./dist/auth.server.d.ts",
        "development": "./src/server.ts",
        "default": "./dist/auth.server.js"
      }
    }
  }
}
```

**工作原理**：

```
客户端导入：
import auth from '@company/auth'
   ↓
匹配 "browser" 条件
   ↓
加载 ./dist/auth.client.js

服务端导入：
import auth from '@company/auth'
   ↓
匹配 "worker" 或 "default" 条件
   ↓
加载 ./dist/auth.server.js
```

**文件结构**：

```
@company/auth/
├── src/
│   ├── server.ts       # 服务端实现
│   ├── client.ts       # 客户端实现
│   └── shared.ts       # 共享代码
├── dist/
│   ├── auth.server.js  # 服务端产物
│   ├── auth.client.js  # 客户端产物
│   ├── auth.server.d.ts
│   └── auth.client.d.ts
└── package.json
```

**服务端实现**（src/server.ts）：

```typescript
import { context } from '@web-widget/helpers/context';

export function getUser() {
  const { request } = context();
  // 从请求头获取用户信息
  return parseUserFromCookie(request.headers.get('cookie'));
}
```

**客户端实现**（src/client.ts）：

```typescript
export function getUser() {
  // 从 localStorage 或全局变量获取
  return JSON.parse(localStorage.getItem('user'));
}
```

**业务代码使用**：

```javascript
// 业务代码无需关心环境
import { getUser } from '@company/auth';

export default {
  setup() {
    const user = getUser();  // 自动使用正确的实现
    return { user };
  }
}
```

---

## 六、使用辅助方法简化同构模式的实现

### 6.1 背景问题

**环境差异**：

```
客户端：
  - 上下文信息在全局对象（window、document）
  - 直接访问即可

服务端：
  - 上下文信息在请求对象（Request）
  - 需要层层传递
```

**传统做法的问题**：

```javascript
// ❌ 需要深层传递 request
function getUserInfo(request) {
  return parseUser(request.headers.get('cookie'));
}

function getProfile(request) {
  const user = getUserInfo(request);
  return fetchProfile(user.id, request);
}

function render(request) {
  const profile = getProfile(request);
  // ...
}
```

**元框架的解决方案**：

> 提供辅助方法可以避免函数深层次的传递，从而简化基础包在服务端适应的复杂度

### 6.2 Context - 请求上下文

**获取请求信息**：

```javascript
import { context } from '@web-widget/helpers/context';

export default () => {
  const { request, params, state } = context();
  
  // request: 原始请求对象
  // params: 路由参数
  // state: 请求状态
  
  return <div>Path: {request.url}</div>;
};
```

**应用场景**：

```javascript
// 中间件中使用
export default defineMiddleware(() => {
  const { request } = context();
  const userId = request.headers.get('x-user-id');
  // ...
});

// 组件中使用
export default {
  setup() {
    const { params } = context();
    const articleId = params.id;
    // ...
  }
}
```

### 6.3 Cookies - Cookie 操作

**读取 Cookie**：

```javascript
import { cookies } from '@web-widget/helpers/headers';

export const handler = async () => {
  const cookieStore = cookies();
  
  // 获取 Cookie 值
  const token = cookieStore.get('token')?.value;  // undefined | string
  
  // 检查 Cookie 是否存在
  if (cookieStore.has('user_id')) {
    // ...
  }
  
  return { token };
};
```

**设置 Cookie**：

```javascript
import { cookies } from '@web-widget/helpers/headers';

export const handler = async () => {
  const cookieStore = cookies();
  
  // 设置 Cookie
  cookieStore.set('token', 'abc123', {
    maxAge: 60 * 60 * 24 * 7,  // 7 天
    httpOnly: true,
    secure: true,
    sameSite: 'lax'
  });
};
```

### 6.4 Headers - 请求头

**读取请求头**：

```javascript
import { headers } from '@web-widget/helpers/headers';

export const handler = async () => {
  const headerStore = headers();
  
  const ua = headerStore.get('User-Agent');
  const contentType = headerStore.get('Content-Type');
  
  return new Response(`User-Agent: ${ua}`);
};
```

### 6.5 UserAgent - 用户代理

**解析 User-Agent**：

```javascript
import { userAgent } from '@web-widget/helpers/headers';

export const handler = async () => {
  const { device, browser, os } = userAgent();
  
  // device.type: 'mobile' | 'tablet' | 'desktop'
  const viewport = device.type === 'mobile' ? 'mobile' : 'desktop';
  
  // browser.name: 'Chrome' | 'Safari' | 'Firefox' | ...
  // browser.version: '120.0.0'
  
  // os.name: 'iOS' | 'Android' | 'Windows' | ...
  // os.version: '17.2'
  
  return { viewport, browser, os };
};
```

**应用场景**：

```javascript
// 响应式适配
export default {
  setup() {
    const { device } = userAgent();
    const isMobile = device.type === 'mobile';
    
    return {
      isMobile,
      containerClass: isMobile ? 'mobile-container' : 'desktop-container'
    };
  }
}
```

### 6.6 Navigation - 路由导航

#### params - 路由参数

```javascript
import { params } from '@web-widget/helpers/navigation';

export default () => {
  const { id, slug } = params();
  
  return <>
    <div>ID: {id}</div>
    <div>Slug: {slug}</div>
  </>;
};
```

**对应路由**：

```
/article/:id/:slug
   ↓
/article/123/hello-world
   ↓
params() => { id: '123', slug: 'hello-world' }
```

#### searchParams - 查询参数

```javascript
import { searchParams } from '@web-widget/helpers/navigation';

export default () => {
  const search = searchParams();
  
  const id = search.get('id');
  const page = search.get('page') || '1';
  const tags = search.getAll('tag');
  
  return (
    <>
      <div>ID: {id}</div>
      <div>Page: {page}</div>
      <div>Tags: {tags.join(', ')}</div>
    </>
  );
};
```

**对应 URL**：

```
/search?id=123&page=2&tag=vue&tag=ssr
   ↓
searchParams() => URLSearchParams {
  id: '123',
  page: '2',
  tag: ['vue', 'ssr']
}
```

#### url - 完整 URL

```javascript
import { url } from '@web-widget/helpers/navigation';

export default () => {
  const currentUrl = url();
  
  return (
    <>
      <div>Pathname: {currentUrl.pathname}</div>
      <div>Search: {currentUrl.search}</div>
      <div>Hash: {currentUrl.hash}</div>
      <div>Host: {currentUrl.host}</div>
    </>
  );
};
```

---

## 七、总结

### 7.1 核心要点

**必须遵守的规则**：

| 规则 | 说明 | 违反后果 |
|------|------|---------|
| **✅ 状态一致** | 服务端和客户端初始渲染必须一致 | 🔴 水合失败 |
| **✅ 生命周期缓存** | 数据请求使用生命周期缓存 | 🔴 水合失败、重复请求 |
| **✅ 避免浏览器 API** | 不在服务端使用浏览器 API | 🔴 服务端 500 错误 |
| **✅ 避免单例模式** | 不使用单例模式 | 🔴 请求污染、隐私泄露 |
| **✅ 生命周期理解** | 理解 SSR 和 CSR 的生命周期差异 | 🔴 代码运行异常 |

### 7.2 开发清单

**开发 SSR 组件前的检查清单**：

- [ ] 数据请求使用了生命周期缓存（`cacheProvider`）
- [ ] 没有在 `setup()` 中直接访问 `window`、`document`
- [ ] 浏览器 API 调用都在 `onMounted()` 中
- [ ] 没有使用单例模式缓存用户数据
- [ ] 理解哪些生命周期钩子在服务端执行
- [ ] 对于不支持 SSR 的组件使用了 `<ClientOnly>`
- [ ] 基础包使用了条件导出适配不同环境

### 7.3 常见问题速查

| 问题现象 | 可能原因 | 解决方案 |
|---------|---------|---------|
| **水合失败警告** | 服务端客户端状态不一致 | 使用生命周期缓存 |
| **服务端 500 错误** | 使用了浏览器 API | 移到 `onMounted` 或使用 `ClientOnly` |
| **用户数据错乱** | 单例模式导致请求污染 | 使用工厂函数或上下文 |
| **数据请求两次** | 没有使用生命周期缓存 | 使用 `cacheProvider` |
| **响应式不工作** | 服务端没有响应式 | 理解生命周期差异 |

### 7.4 下一步

**继续学习**：

1. **实践接入**：
   - 阅读 [SSR 接入文档](02-基础入门-SSR接入文档.md)
   
2. **深入理解核心机制**：
   - 阅读 [SSR 场景下接口数据请求及水合机制](03-核心机制-SSR场景下接口数据请求及水合机制.md)
   
3. **鉴权方案**：
   - 阅读 [RFC 16: SSR 鉴权流程标准化提议](05-鉴权-RFC16-SSR鉴权流程标准化提议.md)
   
4. **AB 实验**：
   - 阅读 [RFC 12.1: SSR 场景下的 AB 实验与缓存策略改进](09-AB实验-RFC12.1-SSR场景下的AB实验与缓存策略改进.md)

---

## 八、参考资源

**官方文档**：
- [Vue.js SSR Guide](https://vuejs.org/guide/scaling-up/ssr.html)
- [Vite SSR](https://vitejs.dev/guide/ssr.html)

**内部资源**：
- Meta SSR 框架文档
- @web-widget/helpers API 文档

**相关 RFC**：
- RFC 16: SSR 鉴权流程标准化提议
- RFC 12 系列：AB 实验系列

---

**文档维护**：前端基建团队  
**整理日期**：2025-01-25  
**文档版本**：v1.0
