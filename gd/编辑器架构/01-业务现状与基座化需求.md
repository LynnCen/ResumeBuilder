# 编辑器业务现状与基座化需求

## 一、业务背景

### 1.1 编辑器产品矩阵

公司旗下存在多个编辑器产品线，面向不同市场和场景：

```
┌─────────────────────────────────────────────────────────────────────┐
│                        编辑器产品矩阵                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│   ┌─────────────────┐   ┌─────────────────┐   ┌─────────────────┐   │
│   │    稿定设计      │   │     InsMind     │   │    稿定Art      │   │
│   │   (国内主站)     │   │    (海外市场)    │   │   (AI创作)      │   │
│   ├─────────────────┤   ├─────────────────┤   ├─────────────────┤   │
│   │ • 设计模板编辑   │   │ • AI图像处理    │   │ • AI绘图生成    │   │
│   │ • 协同设计      │   │ • 批量抠图      │   │ • 风格转换      │   │
│   │ • 品牌管理      │   │ • 格式转换      │   │ • 创意设计      │   │
│   │ • 企业版       │   │ • 智能修复      │   │ • 艺术滤镜      │   │
│   └─────────────────┘   └─────────────────┘   └─────────────────┘   │
│                                                                       │
│                    ┌─────────────────────────┐                       │
│                    │      共同核心需求        │                       │
│                    ├─────────────────────────┤                       │
│                    │  • 用户认证与权限管理    │                       │
│                    │  • VIP权益与计费系统     │                       │
│                    │  • 素材上传与OSS管理     │                       │
│                    │  • 导出下载与格式转换    │                       │
│                    │  • 埋点追踪与数据分析    │                       │
│                    │  • 协同编辑与实时同步    │                       │
│                    │  • 历史版本与回退机制    │                       │
│                    └─────────────────────────┘                       │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

### 1.2 Monorepo 项目结构

整个项目采用 **pnpm Monorepo** 架构，包含多个应用和公共包：

```
domains/editor/
├── apps/                           # 应用层
│   ├── design/                     # 稿定设计主站
│   │   ├── routes/
│   │   │   ├── (nuxt3)/           # Nuxt3 页面
│   │   │   └── (vue3)/            # Vue3 页面
│   │   │       └── services/      # 工具服务
│   │   │           └── editor/
│   │   │               └── editors/
│   │   │                   ├── matting/       # 抠图工具
│   │   │                   ├── magic-eraser/  # 魔法橡皮擦
│   │   │                   ├── ai-replace/    # AI替换
│   │   │                   └── ...            # 20+ 工具
│   │   └── package.json
│   │
│   ├── design-view/                # 编辑器视图
│   └── insmind/                    # InsMind海外版
│
├── packages/                       # 公共包层
│   ├── design/                     # 设计相关
│   │   ├── services/              # 业务服务（180+ 文件）
│   │   ├── business-ui/           # 业务UI（950+ 组件）
│   │   └── stores/                # 状态管理
│   │
│   ├── foundations/               # 基座层
│   │   ├── design/               # 新基座（Kernel-X）
│   │   └── design-view/          # 旧基座
│   │
│   ├── kernel-x/                  # 扩展系统核心
│   │   ├── core/                 # 内核
│   │   ├── design-services/      # 服务扩展
│   │   └── design-components/    # 组件扩展
│   │
│   └── shared/                    # 共享工具
│       ├── apis/                 # API封装
│       ├── oss/                  # OSS服务
│       └── commerce/             # 商业化
│
└── package.json
```

### 1.3 工具类型多样性

以 InsMind 为例，单个产品包含 **20+ 种编辑工具**：

```typescript
// apps/insmind/routes/(vue3)/services/editor/editors/ 目录结构
enum ToolType {
    // AI图像处理类
    Matting = 'matting',              // 智能抠图
    AiBackground = 'ai-background',    // AI换背景
    OutPaintExpand = 'expand',         // 扩图
    AiUpscale = 'upscale',            // AI放大
    
    // 智能修复类
    MagicEraser = 'magic-eraser',      // 魔法橡皮擦
    AiReplace = 'ai-replace',          // AI替换
    ObjectRemover = 'object-remover',  // 物体移除
    
    // 图像编辑类
    Crop = 'crop',                     // 裁剪
    Compress = 'compress',             // 压缩
    Convert = 'convert',               // 格式转换
    Resize = 'resize',                 // 尺寸调整
    
    // AI生成类
    AiDraw = 'ai-draw',               // AI绘图
    PhotoGenerate = 'photo-generate',  // 照片生成
    AvatarGenerate = 'avatar',         // 头像生成
    
    // ... 更多工具
}
```

每个工具的核心需求：

| 工具类别 | 具体工具 | 共性需求 | 差异需求 |
|---------|---------|---------|---------|
| **AI图像处理** | 抠图、AI换背景、扩图 | 用户登录、VIP校验、OSS上传 | AI模型调用、Canvas处理 |
| **图像编辑** | 裁剪、压缩、格式转换 | 用户登录、导出下载、埋点 | 图像变换算法、编解码 |
| **AI生成** | AI绘图、照片生成 | 用户登录、VIP扣次、埋点 | Prompt处理、生成流程 |
| **智能修复** | 魔法橡皮擦、AI替换 | 用户登录、VIP校验、Canvas | 选区管理、Inpaint |

### 1.4 共性需求分析

观察各工具的核心能力，发现**大量可复用的基础模块**：

```
┌─────────────────────────────────────────────────────────────────────┐
│                         共性需求矩阵                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │                      用户与权限层                              │   │
│  │                                                                │   │
│  │  ┌────────────┐  ┌────────────┐  ┌────────────┐             │   │
│  │  │  用户认证   │  │  VIP权益   │  │  权限控制   │             │   │
│  │  │            │  │            │  │            │             │   │
│  │  │ • 登录弹窗 │  │ • 等级判断 │  │ • 功能权限 │             │   │
│  │  │ • Token管理│  │ • 次数扣减 │  │ • 企业权限 │             │   │
│  │  │ • 多端同步 │  │ • 付费引导 │  │ • 编辑权限 │             │   │
│  │  └────────────┘  └────────────┘  └────────────┘             │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                       │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │                      资源与存储层                              │   │
│  │                                                                │   │
│  │  ┌────────────┐  ┌────────────┐  ┌────────────┐             │   │
│  │  │  素材上传   │  │  OSS管理   │  │  字体服务   │             │   │
│  │  │            │  │            │  │            │             │   │
│  │  │ • 文件校验 │  │ • 上传配置 │  │ • 字体加载 │             │   │
│  │  │ • 格式转换 │  │ • CDN加速  │  │ • 字体渲染 │             │   │
│  │  │ • 进度追踪 │  │ • webp/avif│  │ • 字体授权 │             │   │
│  │  └────────────┘  └────────────┘  └────────────┘             │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                       │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │                      功能与交互层                              │   │
│  │                                                                │   │
│  │  ┌────────────┐  ┌────────────┐  ┌────────────┐             │   │
│  │  │  导出下载   │  │  协同编辑   │  │  版本管理   │             │   │
│  │  │            │  │            │  │            │             │   │
│  │  │ • 格式选择 │  │ • 实时同步 │  │ • 历史记录 │             │   │
│  │  │ • 水印处理 │  │ • 冲突解决 │  │ • 版本回退 │             │   │
│  │  │ • 批量导出 │  │ • 成员管理 │  │ • 自动保存 │             │   │
│  │  └────────────┘  └────────────┘  └────────────┘             │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                       │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │                      监控与运营层                              │   │
│  │                                                                │   │
│  │  ┌────────────┐  ┌────────────┐  ┌────────────┐             │   │
│  │  │  埋点追踪   │  │  日志系统   │  │  新手引导   │             │   │
│  │  │            │  │            │  │            │             │   │
│  │  │ • 行为埋点 │  │ • 错误上报 │  │ • 功能引导 │             │   │
│  │  │ • 转化追踪 │  │ • 性能监控 │  │ • 任务系统 │             │   │
│  │  │ • AB实验  │  │ • 健康检测 │  │ • 帮助文档 │             │   │
│  │  └────────────┘  └────────────┘  └────────────┘             │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 二、无基座时代的困境

### 2.1 最初的实现方式

早期各产品独立开发，每个编辑器自己实现所有功能：

```
┌─────────────────────────────────────────────────────────────────────┐
│                      早期：各自为政                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│   apps/design/                          apps/insmind/                │
│   ┌─────────────────────┐              ┌─────────────────────┐      │
│   │     稿定设计         │              │      InsMind        │      │
│   ├─────────────────────┤              ├─────────────────────┤      │
│   │ services/           │              │ services/           │      │
│   │   ├── user.ts      ✗│              │   ├── user.ts      ✗│      │
│   │   ├── vip.ts       ✗│              │   ├── vip.ts       ✗│      │
│   │   ├── upload.ts    ✗│              │   ├── upload.ts    ✗│      │
│   │   ├── export.ts    ✗│              │   ├── export.ts    ✗│      │
│   │   ├── tracker.ts   ✗│              │   ├── tracker.ts   ✗│      │
│   │   └── ...          │              │   └── ...          │      │
│   │                     │              │                     │      │
│   │ components/         │              │ components/         │      │
│   │   ├── Header.vue   ✗│              │   ├── Header.vue   ✗│      │
│   │   ├── Panel.vue    ✗│              │   ├── Panel.vue    ✗│      │
│   │   └── ...          │              │   └── ...          │      │
│   └─────────────────────┘              └─────────────────────┘      │
│                                                                       │
│   ✗ 表示重复实现的代码                                                │
│                                                                       │
│   问题统计：                                                          │
│   • 用户服务：2套实现，约 800 行重复代码                              │
│   • VIP服务：2套实现，约 1200 行重复代码                              │
│   • 上传服务：2套实现，约 600 行重复代码                              │
│   • 总计：约 15000+ 行重复代码                                        │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.2 核心痛点详解

#### 痛点一：代码重复

```typescript
// apps/design/services/user/login.ts
class GaodingUserService {
    async login() {
        // 弹窗登录实现
        const modal = await import('./login-modal');
        modal.show();
        
        // 登录成功后
        const token = await this.getToken();
        localStorage.setItem('gd_token', token);
        
        // 刷新页面
        window.location.reload();
    }
    
    async checkLoginStatus() {
        const token = localStorage.getItem('gd_token');
        if (!token) return false;
        
        try {
            const user = await this.fetchUserInfo(token);
            return !!user;
        } catch {
            return false;
        }
    }
}

// apps/insmind/services/user/login.ts（高度相似但有细微差异）
class InsMindUserService {
    async login() {
        // 跳转登录页实现（因为海外版 OAuth 不同）
        const redirectUrl = encodeURIComponent(window.location.href);
        window.location.href = `/login?redirect=${redirectUrl}`;
    }
    
    async checkLoginStatus() {
        // Cookie 方式（因为要跨域）
        const token = this.getCookie('im_token');
        if (!token) return false;
        
        try {
            const user = await this.fetchUserInfo(token);
            return !!user;
        } catch {
            return false;
        }
    }
    
    private getCookie(name: string) {
        // Cookie 解析逻辑...
    }
}

// 问题：
// 1. checkLoginStatus 逻辑 90% 相同，但存储方式不同
// 2. login 流程 70% 相同，但 UI 交互不同
// 3. 当需要增加「登录埋点」时，需要修改两处代码
```

#### 痛点二：一致性差

```typescript
// 稿定设计的 VIP 检查
async function checkVipInGaoding(userId: string) {
    const response = await api.get('/vip/status', { userId });
    // 返回格式：{ isVip: boolean, level: number, expireTime: string }
    return response.data;
}

// InsMind 的 VIP 检查
async function checkVipInInsMind(userId: string) {
    const response = await api.get('/user/membership', { user_id: userId });
    // 返回格式：{ is_member: boolean, tier: string, expire_at: number }
    // 注意：字段命名不同，tier 是字符串不是数字
    return {
        isVip: response.data.is_member,
        level: this.tierToLevel(response.data.tier),  // 需要转换
        expireTime: new Date(response.data.expire_at * 1000).toISOString()
    };
}

// 问题：
// 1. API 路径不同：/vip/status vs /user/membership
// 2. 参数命名不同：userId vs user_id
// 3. 返回格式不同：需要额外的转换逻辑
// 4. 当后端统一接口时，两边都需要修改
```

#### 痛点三：迭代缓慢

```
┌─────────────────────────────────────────────────────────────────────┐
│                   新功能开发流程（无基座）                             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  需求：增加「登录后自动同步云端设计」功能                             │
│                                                                       │
│  Step 1: 稿定设计实现                                                │
│  ────────────────────                                                │
│  • 修改 user.ts                    1天                               │
│  • 修改 sync.ts                    2天                               │
│  • 测试验证                        1天                               │
│  • 代码审查                        0.5天                             │
│                                   ─────                              │
│                                   4.5天                              │
│                                                                       │
│  Step 2: InsMind 实现（需要参考稿定设计，但不能直接复制）             │
│  ────────────────────                                                │
│  • 阅读稿定实现                    0.5天                             │
│  • 修改 user.ts（适配差异）        1.5天                             │
│  • 修改 sync.ts（适配差异）        2.5天                             │
│  • 测试验证                        1天                               │
│  • 代码审查                        0.5天                             │
│                                   ─────                              │
│                                   6天                                │
│                                                                       │
│  Step 3: 后续产品线...                                               │
│                                                                       │
│  总计：10.5天 × N（产品数量）                                        │
│                                                                       │
│  如果有基座：                                                        │
│  • 基座层实现：4.5天                                                 │
│  • 各产品适配：0.5天 × N                                             │
│  • 节省：(6天 × (N-1)) 的开发时间                                    │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

#### 痛点四：质量参差

```typescript
// 稿定设计的错误处理（较完善）
async function uploadImage(file: File) {
    try {
        // 1. 文件校验
        if (!validateFile(file)) {
            throw new ValidationError('文件格式不支持');
        }
        
        // 2. 大小检查
        if (file.size > MAX_SIZE) {
            throw new FileSizeError('文件过大');
        }
        
        // 3. 上传
        const result = await ossClient.upload(file);
        
        // 4. 埋点
        tracker.track('upload_success', { size: file.size });
        
        return result;
    } catch (error) {
        // 5. 错误上报
        logger.error('upload_failed', error);
        
        // 6. 用户提示
        if (error instanceof ValidationError) {
            message.error(error.message);
        } else if (error instanceof FileSizeError) {
            message.error('文件过大，请压缩后重试');
        } else {
            message.error('上传失败，请重试');
        }
        
        throw error;
    }
}

// InsMind 的错误处理（较简陋）
async function uploadImage(file: File) {
    try {
        const result = await ossClient.upload(file);
        return result;
    } catch (error) {
        alert('Upload failed');  // 简单的 alert
        console.error(error);    // 只有 console.log
        throw error;
    }
}

// 问题：
// 1. 错误处理策略不一致
// 2. 用户体验不统一
// 3. 日志和埋点缺失
// 4. 没有统一的最佳实践
```

### 2.3 问题影响量化

| 指标 | 无基座 | 有基座 | 改善 |
|-----|-------|-------|-----|
| **重复代码** | 15000+ 行 | 0 行 | -100% |
| **新功能开发周期** | 10天 × N | 5天 + 0.5天 × N | -50%+ |
| **Bug 修复** | N 处修改 | 1 处修改 | -80%+ |
| **代码审查** | N 次审查 | 1 次审查 | -80%+ |
| **测试覆盖** | 分散，难以统一 | 集中，统一标准 | +200% |

---

## 三、基座化的必然性

### 3.1 什么是编辑器基座

**基座（Foundation）** 是一套可复用的基础架构，为上层业务提供标准化的能力支撑：

```
┌─────────────────────────────────────────────────────────────────────┐
│                         基座化架构                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│     ┌──────────┐    ┌──────────┐    ┌──────────┐                    │
│     │ 稿定设计  │    │ InsMind  │    │ 稿定Art  │     应用层         │
│     └─────┬────┘    └─────┬────┘    └─────┬────┘                    │
│           │               │               │                          │
│           │    差异化配置  │    差异化配置  │                          │
│           │               │               │                          │
│           └───────────────┼───────────────┘                          │
│                           │                                          │
│                           ▼                                          │
│     ┌─────────────────────────────────────────────────────────┐     │
│     │                    编辑器基座层                           │     │
│     │                                                           │     │
│     │  ┌─────────────────────────────────────────────────────┐│     │
│     │  │                   Foundation                         ││     │
│     │  │              (应用入口与编排)                        ││     │
│     │  └─────────────────────────────────────────────────────┘│     │
│     │                          │                               │     │
│     │  ┌───────────┬───────────┼───────────┬───────────┐     │     │
│     │  │           │           │           │           │     │     │
│     │  ▼           ▼           ▼           ▼           ▼     │     │
│     │ ┌─────┐   ┌─────┐   ┌─────┐   ┌─────┐   ┌─────┐      │     │
│     │ │User │   │ VIP │   │Upload│   │Export│   │Track│ ... │     │
│     │ │Svc  │   │ Svc │   │ Svc │   │ Svc │   │ Svc │      │     │
│     │ └─────┘   └─────┘   └─────┘   └─────┘   └─────┘      │     │
│     │                                                           │     │
│     │  ┌─────────────────────────────────────────────────────┐│     │
│     │  │                   Business UI                        ││     │
│     │  │               (950+ 可复用组件)                      ││     │
│     │  └─────────────────────────────────────────────────────┘│     │
│     │                                                           │     │
│     └─────────────────────────────────────────────────────────┘     │
│                                                                       │
│     复用统计：                                                        │
│     • Services 层：90%+ 代码复用                                     │
│     • UI 层：70%+ 组件复用                                           │
│     • Foundation：100% 复用                                          │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.2 基座化的核心价值

```
┌─────────────────────────────────────────────────────────────────────┐
│                       基座化收益分析                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │  收益一：开发效率提升                                          │  │
│  │                                                                 │  │
│  │  场景：开发新产品「稿定PPT」                                    │  │
│  │                                                                 │  │
│  │  无基座：                                                       │  │
│  │  ├─ 用户系统开发        2周                                    │  │
│  │  ├─ VIP系统开发         2周                                    │  │
│  │  ├─ 上传导出开发        1周                                    │  │
│  │  ├─ 埋点系统开发        1周                                    │  │
│  │  └─ PPT核心功能         4周                                    │  │
│  │                        ────                                    │  │
│  │                        10周                                    │  │
│  │                                                                 │  │
│  │  有基座：                                                       │  │
│  │  ├─ 基座配置适配        0.5周                                  │  │
│  │  └─ PPT核心功能         4周                                    │  │
│  │                        ────                                    │  │
│  │                        4.5周  (节省 55%)                       │  │
│  └───────────────────────────────────────────────────────────────┘  │
│                                                                       │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │  收益二：维护成本降低                                          │  │
│  │                                                                 │  │
│  │  场景：修复「用户Token过期未正确处理」Bug                       │  │
│  │                                                                 │  │
│  │  无基座：                                                       │  │
│  │  ├─ 定位问题（每个项目）  0.5天 × N                            │  │
│  │  ├─ 修复代码             0.5天 × N                            │  │
│  │  ├─ 测试验证             0.5天 × N                            │  │
│  │  └─ 代码审查             0.25天 × N                           │  │
│  │                         ─────────                              │  │
│  │                         1.75天 × N  (N=3 时 5.25天)            │  │
│  │                                                                 │  │
│  │  有基座：                                                       │  │
│  │  ├─ 定位问题             0.5天                                 │  │
│  │  ├─ 修复代码             0.5天                                 │  │
│  │  ├─ 测试验证             0.5天                                 │  │
│  │  └─ 代码审查             0.25天                                │  │
│  │                         ─────                                  │  │
│  │                         1.75天  (节省 67%)                     │  │
│  └───────────────────────────────────────────────────────────────┘  │
│                                                                       │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │  收益三：质量一致性保障                                        │  │
│  │                                                                 │  │
│  │  • 统一的错误处理策略                                          │  │
│  │  • 统一的日志上报格式                                          │  │
│  │  • 统一的埋点规范                                              │  │
│  │  • 统一的 UI/UX 体验                                           │  │
│  │  • 统一的测试覆盖标准                                          │  │
│  └───────────────────────────────────────────────────────────────┘  │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.3 复用层次划分

基座化需要明确「什么该复用，什么该差异化」：

```
┌─────────────────────────────────────────────────────────────────────┐
│                        复用层次金字塔                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│                           ▲                                          │
│                          /│\                                         │
│                         / │ \                                        │
│                        /  │  \                                       │
│                       /   │   \                                      │
│                      / 业务 \      ← 差异化实现                       │
│                     / 逻辑层 \        各工具核心算法                  │
│                    /─────────\        20% 代码在这里                 │
│                   /           \                                      │
│                  /   UI组件层  \    ← 60%复用+40%定制                │
│                 /              \      Header/Panel/Modal...          │
│                /────────────────\                                    │
│               /                  \                                   │
│              /   业务服务层       \  ← 80%复用+20%配置               │
│             /                      \    VIP/Upload/Export...         │
│            /────────────────────────\                                │
│           /                          \                               │
│          /        核心层              \ ← 100%复用                   │
│         /                              \   User/Auth/Logger...       │
│        /────────────────────────────────\                            │
│                                                                       │
│  各层说明：                                                           │
│                                                                       │
│  核心层（100%复用）：                                                 │
│  • 用户认证、权限校验、日志系统                                       │
│  • 这些功能在所有产品中完全一致                                       │
│                                                                       │
│  业务服务层（80%复用 + 20%配置）：                                    │
│  • VIP权益（规则可配置）                                             │
│  • 上传服务（大小限制可配置）                                        │
│  • 导出服务（格式可配置）                                            │
│                                                                       │
│  UI组件层（60%复用 + 40%定制）：                                     │
│  • 工具栏（布局可调整）                                              │
│  • 面板（样式可定制）                                                │
│  • 弹窗（内容可替换）                                                │
│                                                                       │
│  业务逻辑层（按需复用）：                                             │
│  • 各工具的核心算法（抠图、AI替换等）                                │
│  • 特定业务的交互流程                                                │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 四、基座化面临的技术挑战

### 4.1 挑战一：依赖管理复杂

当服务数量增多，依赖关系变得复杂：

```
┌─────────────────────────────────────────────────────────────────────┐
│                       服务依赖关系图                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│                         UserService                                   │
│                              │                                        │
│              ┌───────────────┼───────────────┐                       │
│              │               │               │                        │
│              ▼               ▼               ▼                        │
│        VipService    EnterpriseService  CollabService                │
│              │               │               │                        │
│              │               │               └────────┐              │
│              ▼               ▼                        │              │
│        GuideService  PermissionService               │              │
│              │               │                        │              │
│              └───────────────┼────────────────────────┘              │
│                              │                                        │
│                              ▼                                        │
│                       EditorService                                   │
│                              │                                        │
│              ┌───────────────┼───────────────┐                       │
│              │               │               │                        │
│              ▼               ▼               ▼                        │
│        FontsService   SaveService    ExportService                   │
│              │               │               │                        │
│              └───────────────┴───────────────┘                       │
│                              │                                        │
│                              ▼                                        │
│                       UploadService                                   │
│                                                                       │
│  问题：                                                               │
│  ├─ 如何确定正确的初始化顺序？                                        │
│  ├─ 如何检测循环依赖？                                                │
│  ├─ 某服务初始化失败时如何降级？                                      │
│  └─ 如何在不同产品中替换某个服务的实现？                              │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

**具体问题示例**：

```typescript
// 问题1：循环依赖
class VipService {
    constructor(private userService: UserService) {}
}

class UserService {
    constructor(private vipService: VipService) {}  // 循环！
}

// 问题2：初始化顺序
// 正确顺序：User → Vip → Editor → Fonts
// 但如果有人不小心写成：
await vipService.init();  // ❌ userService 未初始化
await userService.init();

// 问题3：依赖缺失
class ExportService {
    async export() {
        const fonts = useFontsService();  // 运行时才发现依赖
        const vip = useVipService();      // 运行时才发现依赖
        // 如果这些服务未初始化，会报错
    }
}
```

### 4.2 挑战二：扩展机制设计

不同业务有不同的定制需求：

```
┌─────────────────────────────────────────────────────────────────────┐
│                       定制需求场景                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  场景1：VIP 权益差异                                                  │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │                                                                 │  │
│  │  稿定设计：                      InsMind：                     │  │
│  │  ┌─────────────────────┐       ┌─────────────────────┐       │  │
│  │  │ • 免费版：3次/天    │       │ • Free：5次/天      │       │  │
│  │  │ • VIP：无限次       │       │ • Pro：100次/月     │       │  │
│  │  │ • SVIP：无限次+优先│       │ • Enterprise：无限  │       │  │
│  │  └─────────────────────┘       └─────────────────────┘       │  │
│  │                                                                 │  │
│  │  问题：同一个 VipService，如何支持不同的权益规则？              │  │
│  └───────────────────────────────────────────────────────────────┘  │
│                                                                       │
│  场景2：登录流程差异                                                  │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │                                                                 │  │
│  │  稿定设计：                      InsMind：                     │  │
│  │  ┌─────────────────────┐       ┌─────────────────────┐       │  │
│  │  │ • 弹窗登录          │       │ • Google OAuth      │       │  │
│  │  │ • 微信扫码          │       │ • Apple Sign In     │       │  │
│  │  │ • 手机验证码        │       │ • Email 登录        │       │  │
│  │  └─────────────────────┘       └─────────────────────┘       │  │
│  │                                                                 │  │
│  │  问题：如何在不修改核心代码的前提下，支持不同的登录方式？       │  │
│  └───────────────────────────────────────────────────────────────┘  │
│                                                                       │
│  场景3：功能开关差异                                                  │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │                                                                 │  │
│  │  稿定设计：                      InsMind：                     │  │
│  │  ┌─────────────────────┐       ┌─────────────────────┐       │  │
│  │  │ ✓ 协同编辑          │       │ ✗ 协同编辑          │       │  │
│  │  │ ✓ 品牌管理          │       │ ✗ 品牌管理          │       │  │
│  │  │ ✓ 企业版            │       │ ✓ 多语言            │       │  │
│  │  └─────────────────────┘       └─────────────────────┘       │  │
│  │                                                                 │  │
│  │  问题：如何按需加载功能，避免打包无用代码？                     │  │
│  └───────────────────────────────────────────────────────────────┘  │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

**当前的解决方式（问题多多）**：

```typescript
// ❌ 方式1：条件分支污染核心代码
// @design/services/src/vip/store.ts
const useVipService = defineStore('vip', {
    actions: {
        async checkVip() {
            if (isInsMind) {
                // InsMind 逻辑（50行）
            } else if (isGaoding) {
                // 稿定逻辑（50行）
            } else if (isGaodingArt) {
                // 稿定Art 逻辑（50行）
            }
            // 随着产品增加，if-else 越来越长...
        }
    }
});

// ❌ 方式2：Fork 代码
// 每个产品维护自己的 vip/store.ts
// 问题：公共逻辑修改需要同步多处

// ❌ 方式3：配置化（但配置越来越复杂）
const vipConfig = {
    gaoding: { ... },
    insmind: { ... },
    gaodingArt: { ... },
    // 配置项越来越多，难以维护
};
```

### 4.3 挑战三：生命周期管理

服务的初始化和销毁需要精确控制：

```
┌─────────────────────────────────────────────────────────────────────┐
│                       生命周期管理问题                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  问题1：初始化顺序                                                    │
│  ────────────────                                                    │
│                                                                       │
│  应用启动                                                             │
│      │                                                                │
│      ▼                                                                │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  1. 环境检测          ──┐                                    │    │
│  │  2. 配置加载            │ 同步，顺序执行                     │    │
│  │  3. Logger初始化      ──┘                                    │    │
│  │                                                               │    │
│  │  4. UserService.init()  ◄── 异步，必须最先完成               │    │
│  │          │                                                    │    │
│  │          ▼                                                    │    │
│  │  5. VipService.init()   ◄── 依赖 User，必须在 User 之后      │    │
│  │  6. EnterpriseService.init() ◄── 依赖 User                   │    │
│  │          │                                                    │    │
│  │          ▼                                                    │    │
│  │  7. EditorService.init() ◄── 依赖 Vip + Enterprise           │    │
│  │          │                                                    │    │
│  │          ▼                                                    │    │
│  │  8. FontsService.init() ◄── 依赖 Editor                      │    │
│  │  9. CollabService.init() ◄── 可选，依赖 Editor               │    │
│  └─────────────────────────────────────────────────────────────┘    │
│      │                                                                │
│      ▼                                                                │
│  应用就绪                                                             │
│                                                                       │
│  当前方案（手动编排）的问题：                                         │
│  • 顺序靠人工记忆和文档约定                                          │
│  • 新增服务需要找到正确的插入点                                      │
│  • 删除服务需要检查是否有其他服务依赖它                              │
│  • 初始化失败时，后续服务如何处理？                                  │
│                                                                       │
│  ─────────────────────────────────────────────────────────────────   │
│                                                                       │
│  问题2：资源销毁                                                      │
│  ────────────────                                                    │
│                                                                       │
│  当前的销毁方式：                                                     │
│                                                                       │
│  // 组件中手动清理                                                   │
│  onMounted(() => {                                                   │
│      lifecycleEvent.on('template-loaded', handler1);                 │
│      userStatusEvent.on('login', handler2);                          │
│      collabService.on('sync', handler3);                             │
│  });                                                                  │
│                                                                       │
│  onUnmounted(() => {                                                 │
│      lifecycleEvent.off('template-loaded', handler1);  // 容易忘    │
│      userStatusEvent.off('login', handler2);           // 容易忘    │
│      // handler3 忘了清理！→ 内存泄漏                               │
│  });                                                                  │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

### 4.4 挑战四：类型安全

事件系统缺乏类型约束：

```typescript
// 当前的事件系统问题

// 问题1：事件名是字符串，容易拼错
lifecycleEvent.emit('editor-ready');
lifecycleEvent.emit('editor-raedy');  // 拼错了，编译不报错，运行时才发现

// 问题2：事件数据没有类型
lifecycleEvent.on('template-loaded', (data) => {
    // data 是 any 类型
    console.log(data.template.id);      // 可能 undefined
    console.log(data.template.pages);   // 可能不存在
    console.log(data.tempalte);         // 拼错了，编译不报错
});

// 问题3：emit 和 on 的参数不匹配
lifecycleEvent.emit('user-login', { userId: '123' });
lifecycleEvent.on('user-login', (data: { user: any }) => {
    // 期望 data.user，实际是 data.userId
    // 编译不报错，运行时才发现问题
});
```

### 4.5 挑战汇总

| 挑战 | 核心问题 | 期望解决方案 |
|-----|---------|-------------|
| **依赖管理** | 隐式依赖、循环依赖、初始化顺序 | 显式声明 + 自动拓扑排序 |
| **扩展机制** | 定制困难、代码污染 | 插件化 + Token替换 |
| **生命周期** | 手动编排、资源泄漏 | 自动管理 + 追踪清理 |
| **类型安全** | any类型、运行时错误 | 泛型Token + 编译检查 |

---

## 五、演进方向

### 5.1 设计原则

```
┌─────────────────────────────────────────────────────────────────────┐
│                       基座设计原则                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  原则1：依赖倒置（DIP）                                              │
│  ──────────────────                                                  │
│  高层模块不应该依赖低层模块，两者都应该依赖抽象                       │
│                                                                       │
│  // ❌ 直接依赖                                                      │
│  import { VipService } from './vip-service';                         │
│  class EditorService {                                               │
│      private vip = new VipService();  // 紧耦合                      │
│  }                                                                   │
│                                                                       │
│  // ✓ 依赖抽象                                                       │
│  interface IVipService { checkVip(): Promise<boolean>; }             │
│  class EditorService {                                               │
│      constructor(private vip: IVipService) {}  // 依赖接口           │
│  }                                                                   │
│                                                                       │
│  ─────────────────────────────────────────────────────────────────   │
│                                                                       │
│  原则2：开闭原则（OCP）                                              │
│  ──────────────────                                                  │
│  对扩展开放，对修改关闭                                              │
│                                                                       │
│  // ❌ 修改核心代码                                                  │
│  if (isInsMind) { ... } else if (isGaoding) { ... }                 │
│                                                                       │
│  // ✓ 扩展点设计                                                     │
│  const InsMindVipService = createVipService({ rules: insmindRules })│
│  const GaodingVipService = createVipService({ rules: gaodingRules })│
│                                                                       │
│  ─────────────────────────────────────────────────────────────────   │
│                                                                       │
│  原则3：单一职责（SRP）                                              │
│  ──────────────────                                                  │
│  一个模块只负责一件事                                                │
│                                                                       │
│  // ❌ 职责混乱                                                      │
│  class UserService {                                                 │
│      login() { ... }                                                 │
│      checkVip() { ... }      // 应该在 VipService                   │
│      uploadAvatar() { ... }  // 应该在 UploadService                │
│  }                                                                   │
│                                                                       │
│  // ✓ 职责清晰                                                       │
│  class UserService { login() { ... } }                               │
│  class VipService { checkVip() { ... } }                             │
│  class UploadService { upload() { ... } }                            │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

### 5.2 演进路线

```
┌─────────────────────────────────────────────────────────────────────┐
│                       基座演进路线图                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  阶段1：服务抽取（第一代基座）                    ← 当前状态         │
│  ─────────────────────────────                                       │
│                                                                       │
│  目标：将公共服务抽取到独立包                                        │
│                                                                       │
│  实现：                                                               │
│  • @design/services：Pinia Store 管理服务                           │
│  • @design/business-ui：Vue 组件库                                  │
│  • @design/design-view-foundation：手动编排初始化                   │
│                                                                       │
│  问题：                                                               │
│  • 依赖关系隐式                                                      │
│  • 初始化顺序手动管理                                                │
│  • 扩展需要修改核心代码                                              │
│                                                                       │
│                              │                                        │
│                              ▼                                        │
│                                                                       │
│  阶段2：Kernel-X 架构（第二代基座）              ← 演进目标          │
│  ─────────────────────────────                                       │
│                                                                       │
│  目标：引入依赖注入和扩展系统                                        │
│                                                                       │
│  实现：                                                               │
│  • Token 系统：类型安全的身份标识                                    │
│  • 三层架构：Services → Components → Extensions                     │
│  • 扩展机制：Manifest + Activate                                    │
│  • 自动编排：依赖检查 + 拓扑排序                                    │
│                                                                       │
│  收益：                                                               │
│  • 显式依赖声明                                                      │
│  • 自动初始化编排                                                    │
│  • Token 替换实现扩展                                                │
│  • 类型安全的事件系统                                                │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

### 5.3 技术选型参考

| 方案 | 代表项目 | 核心思想 | 优点 | 缺点 |
|-----|---------|---------|------|------|
| **依赖注入** | Angular、NestJS | 声明依赖，容器自动注入 | 类型安全、可测试 | 学习成本 |
| **扩展系统** | VSCode | 扩展点 + 扩展实现 | 高度可扩展 | 设计复杂 |
| **IOC容器** | InversifyJS | 控制反转，解耦创建和使用 | 灵活、可插拔 | 运行时开销 |
| **微前端** | qiankun | 应用级隔离 | 独立部署 | 过重、通信复杂 |

**最终选择**：融合 **依赖注入** + **扩展系统** 的设计，形成 **Kernel-X** 架构。

---

## 六、小结

本章介绍了编辑器业务的现状和基座化的必要性：

**核心要点**：

1. **多产品线矛盾**：稿定设计、InsMind、稿定Art 等共享 70%+ 基础能力，但各自独立实现
2. **无基座困境**：代码重复 15000+ 行、迭代效率低、质量参差、维护成本高
3. **基座化价值**：开发效率提升 55%+、维护成本降低 67%+、质量一致性保障
4. **技术挑战**：依赖管理、扩展机制、生命周期控制、类型安全

**下一章预告**：

我们将详细介绍**第一代基座方案**（Pinia + Vue）的实现：
- Foundation 层的应用入口设计
- Services 层的 Pinia Store 模式
- 事件系统的实现
- 存在的局限性和问题

这些内容将帮助理解为什么需要演进到 Kernel-X 架构。

---

> 📖 **系列文档导航**
> 
> - [x] **第一篇：业务现状与基座化需求**（本文）
> - [ ] 第二篇：第一代基座方案实现
> - [ ] 第三篇：Kernel-X 架构详解
> - [ ] 第四篇：架构演进总结
