# 架构演进总结

## 一、演进背景回顾

### 1.1 业务发展驱动

```
┌─────────────────────────────────────────────────────────────────────┐
│                       业务发展时间线                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  2019          2020          2021          2022          2023        │
│    │             │             │             │             │          │
│    ▼             ▼             ▼             ▼             ▼          │
│  ┌─────┐      ┌─────┐      ┌─────┐      ┌─────┐      ┌─────┐       │
│  │稿定  │      │InsMind│     │稿定Art│    │工具矩阵│    │Kernel-X│    │
│  │设计  │      │海外版 │     │上线   │    │20+工具│    │上线    │    │
│  └─────┘      └─────┘      └─────┘      └─────┘      └─────┘       │
│                                                                       │
│  阶段一         阶段二         阶段三         阶段四         阶段五    │
│  单产品         多产品         产品爆发       规模化挑战     架构升级   │
│  独立开发       复制代码       开始抽取       第一代基座     Kernel-X   │
│                                                                       │
│  ─────────────────────────────────────────────────────────────────   │
│                                                                       │
│  痛点演变：                                                           │
│                                                                       │
│  阶段一：无痛点，快速开发                                             │
│           ↓                                                           │
│  阶段二：代码重复，维护成本上升                                       │
│           ↓                                                           │
│  阶段三：一致性问题，Bug 同步困难                                     │
│           ↓                                                           │
│  阶段四：服务抽取，但依赖混乱                                         │
│           ↓                                                           │
│  阶段五：架构升级，解决根本问题                                       │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

### 1.2 技术债务累积

```
┌─────────────────────────────────────────────────────────────────────┐
│                       技术债务增长曲线                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  技术债务                                                             │
│     ▲                                                                 │
│     │                                            ╱─ 无基座方案        │
│     │                                         ╱                       │
│     │                                      ╱     ← 债务加速累积      │
│     │                                   ╱                             │
│     │                               ╱╲                                │
│     │                            ╱    ╲─ 第一代基座                  │
│     │                         ╱         ╲                            │
│     │                      ╱              ╲                          │
│     │                   ╱                   ╲                        │
│     │                ╱                        ╲─ Kernel-X            │
│     │             ╱                             ╲                    │
│     │          ╱                                  ╲                  │
│     │       ╱                                       ╲                │
│     │    ╱                                            ╲             │
│     │ ╱                                                 ╲           │
│     └─────────────────────────────────────────────────────▶ 时间    │
│                                                                       │
│  关键节点：                                                           │
│  • 无基座：技术债务线性增长                                          │
│  • 第一代基座：债务增速减缓，但仍有新问题                            │
│  • Kernel-X：债务可控，架构支撑持续演进                              │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 二、架构对比总览

### 2.1 三代架构对比

```
┌─────────────────────────────────────────────────────────────────────┐
│                       三代架构对比                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  无基座时代（2019-2020）                                     │    │
│  │                                                               │    │
│  │  apps/design/           apps/insmind/                        │    │
│  │  ├── services/ ✗        ├── services/ ✗                     │    │
│  │  ├── components/ ✗      ├── components/ ✗                   │    │
│  │  └── utils/ ✗           └── utils/ ✗                        │    │
│  │                                                               │    │
│  │  特点：各自为政，代码复制粘贴                                │    │
│  │  问题：重复 15000+ 行，一致性差                              │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                              │                                        │
│                              ▼                                        │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  第一代基座（2021-2022）                                     │    │
│  │                                                               │    │
│  │  packages/                                                    │    │
│  │  ├── @design/services/           ← Pinia Store              │    │
│  │  ├── @design/business-ui/        ← Vue 组件                 │    │
│  │  ├── @design/stores/             ← 底层状态                 │    │
│  │  └── @design/design-view-foundation/ ← 手动编排             │    │
│  │                                                               │    │
│  │  特点：服务抽取，统一管理                                    │    │
│  │  问题：隐式依赖，手动编排，扩展困难                          │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                              │                                        │
│                              ▼                                        │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  Kernel-X（2023-至今）                                       │    │
│  │                                                               │    │
│  │  packages/                                                    │    │
│  │  ├── kernel-x/                                               │    │
│  │  │   ├── core/                   ← 内核                      │    │
│  │  │   ├── design-services/        ← 服务扩展                  │    │
│  │  │   └── design-components/      ← 组件扩展                  │    │
│  │  └── foundations/                                            │    │
│  │      └── design/                 ← 新基座                    │    │
│  │                                                               │    │
│  │  特点：Token + 依赖注入 + 扩展系统                          │    │
│  │  优势：类型安全，自动编排，可插拔                            │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.2 核心维度对比表

| 维度 | 无基座 | 第一代基座 | Kernel-X |
|-----|-------|-----------|----------|
| **代码复用** | 复制粘贴 | 包引用 | 扩展组装 |
| **依赖管理** | 无管理 | 隐式 import | 显式声明 + Token |
| **初始化** | 各自处理 | 手动编排 | 自动拓扑排序 |
| **类型安全** | 无保障 | 部分 | 全链路类型安全 |
| **扩展机制** | 无 | if-else 分支 | Token 替换 |
| **事件系统** | 各自实现 | mitt 字符串 | EventToken + 泛型 |
| **内存管理** | 各自处理 | 手动清理 | 自动追踪清理 |
| **代码分割** | 无 | 无原生支持 | 懒加载扩展 |
| **层级隔离** | 无 | 无 | 三层架构 + 编译检查 |

---

## 三、依赖管理演进

### 3.1 无基座时代：无管理

```typescript
// apps/design/services/vip.ts
// 各产品独立实现，无复用

class VipService {
    async checkVip() {
        // 稿定设计的实现
        const user = await this.getUser();
        return api.get('/vip/status', { userId: user.id });
    }
}

// apps/insmind/services/vip.ts
// 几乎相同的代码，但有微小差异

class VipService {
    async checkVip() {
        // InsMind 的实现
        const user = await this.getUser();
        return api.get('/user/membership', { user_id: user.id }); // API 不同
    }
}

// 问题：
// 1. 代码大量重复
// 2. 差异点难以追踪
// 3. Bug 修复需要同步多处
```

### 3.2 第一代基座：隐式依赖

```typescript
// packages/design/services/src/vip/store.ts
import { defineStore } from 'pinia';
import { useUserStore } from '@design/stores';  // 隐式依赖

export const useVipService = defineStore('vip', {
    actions: {
        async checkVip() {
            // 直接 import 获取依赖
            const userStore = useUserStore();  // ⚠️ 隐式依赖
            
            if (!userStore.user) {
                return { isVip: false };
            }
            
            return api.get('/vip/status', { userId: userStore.user.id });
        }
    }
});

// 问题：
// 1. 依赖关系隐藏在代码中，难以追踪
// 2. 无法静态分析依赖图
// 3. 初始化顺序靠人工保证
// 4. 循环依赖难以检测
```

### 3.3 Kernel-X：显式声明

```typescript
// packages/kernel-x/design-services/src/services/vip/manifest.ts
import { UserServiceToken } from '../user/token';
import { VipServiceToken } from './token';

export const manifest = {
    id: VipServiceToken.id,
    dependencies: [UserServiceToken],  // ✓ 显式声明依赖
};

// packages/kernel-x/design-services/src/services/vip/index.ts
import { defineServiceExtension } from '@design/kernel-x';
import { manifest } from './manifest';
import { UserServiceToken } from '../user/token';

export function createVipExtension() {
    return defineServiceExtension({
        ...manifest,
        
        async activate(context) {
            // 通过 context 获取依赖（非直接 import）
            const userApi = await context.services.get(UserServiceToken);
            
            // 返回服务 API
            return {
                async checkVip() {
                    const user = await userApi.getUser();
                    if (!user) return { isVip: false };
                    return api.get('/vip/status', { userId: user.id });
                }
            };
        }
    });
}

// 优势：
// 1. 依赖关系一目了然
// 2. 静态分析 + 编译期检查
// 3. 自动处理初始化顺序
// 4. 自动检测循环依赖
```

### 3.4 依赖管理对比图

```
┌─────────────────────────────────────────────────────────────────────┐
│                       依赖管理演进对比                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  无基座：无依赖管理                                                   │
│  ─────────────────                                                   │
│                                                                       │
│  ServiceA ────?───> ServiceB ────?───> ServiceC                     │
│      │                  │                   │                        │
│      └──────────────────┴───────────────────┘                        │
│              依赖关系完全不透明                                        │
│                                                                       │
│  ─────────────────────────────────────────────────────────────────   │
│                                                                       │
│  第一代：隐式依赖                                                     │
│  ───────────────                                                     │
│                                                                       │
│  VipService ──import──> useUserStore()                              │
│      │                       │                                        │
│      │    隐藏在代码内部     │                                        │
│      └───────────────────────┘                                        │
│                                                                       │
│  // 需要阅读代码才能知道依赖                                          │
│  const userStore = useUserStore();  // 藏在 actions 里               │
│                                                                       │
│  ─────────────────────────────────────────────────────────────────   │
│                                                                       │
│  Kernel-X：显式声明                                                   │
│  ─────────────────                                                   │
│                                                                       │
│  ┌─────────────────┐                                                │
│  │   VipService    │                                                │
│  │   Manifest      │                                                │
│  │                 │                                                │
│  │  dependencies:  │──────────────────┐                             │
│  │  [UserService]  │                  │                             │
│  └─────────────────┘                  │                             │
│                                        ▼                             │
│                               ┌─────────────────┐                   │
│                               │   UserService   │                   │
│                               │   Token         │                   │
│                               └─────────────────┘                   │
│                                                                       │
│  // 清晰可见，可静态分析                                             │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 四、初始化流程演进

### 4.1 无基座时代：各自处理

```typescript
// apps/design/main.ts
async function bootstrap() {
    // 每个应用独立处理初始化
    await initEnv();
    await initUser();
    await initVip();
    await initEditor();
    // ... 顺序靠各应用自己维护
}

// apps/insmind/main.ts
async function bootstrap() {
    // InsMind 可能顺序不同
    await initEnv();
    await initEditor();  // 先初始化编辑器？
    await initUser();
    await initVip();
    // 不一致导致 Bug
}
```

### 4.2 第一代基座：手动编排

```typescript
// packages/foundations/design-view/src/init/index.ts
export function initDesign(selector: string, config: DesignConfig) {
    // 同步初始化
    initEnv(config.env);
    initAPI(config.apis);
    initPermission(config.permissions);
    
    // 创建应用
    const app = createApp({ ... });
    app.mount(selector);
}

// packages/foundations/design-view/src/compositions/use-init-design-view.ts
export function useInitDesignView() {
    async function initDesign(template: Template) {
        // ⚠️ 手动控制顺序
        await Promise.all([
            enterpriseService.init(),
            userService.init()
        ]);
        
        // ⚠️ 必须在 user 之后
        await vipService.init();
        
        // ⚠️ 必须在 vip 之后
        await enterpriseService.initSecondary();
        
        // ... 顺序错了运行时才发现
    }
    
    return { initDesign };
}

// 问题：
// 1. 顺序靠人工记忆
// 2. 新增服务要找正确插入点
// 3. 删除服务要检查依赖
// 4. 错误要到运行时才发现
```

### 4.3 Kernel-X：自动编排

```typescript
// packages/foundations/design/src/install.ts
export async function installDesign(selector: string, options: Options) {
    const builder = new KernelBuilder();
    
    // 只需注册扩展，无需关心顺序
    builder.initialize({
        services: [
            createInitDesignExtension(options),
            createUserExtension(),
            createVipExtension(),       // 声明了依赖 User
            createEditorExtension(),    // 声明了依赖 Vip
            createFontsExtension(),     // 声明了依赖 Editor
            // ... 50+ 扩展，任意顺序注册
        ],
        components: [
            createLazyDesignLayoutExtension(),
        ],
    });
    
    // 系统自动：
    // 1. 检查依赖完整性
    // 2. 检测循环依赖
    // 3. 拓扑排序确定初始化顺序
    // 4. 按序激活
    
    const initDesignApi = await context.services.get(InitDesignServiceToken);
    return initDesignApi.createApp({ ... });
}
```

### 4.4 初始化顺序对比图

```
┌─────────────────────────────────────────────────────────────────────┐
│                       初始化顺序对比                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  第一代基座：手动编排                                                 │
│  ─────────────────────                                               │
│                                                                       │
│  开发者需要手动确保顺序正确：                                         │
│                                                                       │
│  // 正确                          // 错误（运行时才发现）             │
│  await user.init();              await vip.init();      ← ❌         │
│  await vip.init();               await user.init();                  │
│  await editor.init();            await editor.init();                │
│                                                                       │
│  ─────────────────────────────────────────────────────────────────   │
│                                                                       │
│  Kernel-X：自动拓扑排序                                               │
│  ────────────────────                                                │
│                                                                       │
│  注册顺序（任意）：                                                   │
│  [Editor, Vip, User, Fonts, Collab, ...]                            │
│                                                                       │
│           │                                                           │
│           ▼  系统自动分析依赖                                         │
│                                                                       │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  依赖图构建                                                   │    │
│  │                                                               │    │
│  │         User ◄────── Vip ◄────── Editor ◄────── Fonts       │    │
│  │           │                         │                         │    │
│  │           └─────────────────────────┘                         │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                       │
│           │                                                           │
│           ▼  拓扑排序                                                 │
│                                                                       │
│  激活顺序（自动计算）：                                               │
│  [User] → [Vip] → [Editor] → [Fonts, Collab]                        │
│                                                                       │
│  优势：                                                               │
│  • 编译期检测循环依赖                                                │
│  • 自动确定正确顺序                                                  │
│  • 支持并行激活（无依赖的可并行）                                    │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 五、扩展机制演进

### 5.1 无基座时代：无扩展

```typescript
// 没有扩展概念，需要定制只能 Fork 代码
// apps/design/services/vip.ts
class VipService {
    async checkVip() {
        // 稿定的实现
    }
}

// apps/insmind/services/vip.ts
class VipService {
    async checkVip() {
        // InsMind 的实现（Fork 后修改）
    }
}

// 问题：代码分裂，公共逻辑修改需要同步多处
```

### 5.2 第一代基座：if-else 分支

```typescript
// packages/design/services/src/vip/store.ts
export const useVipService = defineStore('vip', {
    actions: {
        async checkVip() {
            // ⚠️ 条件分支污染核心代码
            if (isInsMind()) {
                // InsMind 特殊逻辑（50行）
                return this.checkInsMindVip();
            } else if (isGaoding()) {
                // 稿定逻辑（50行）
                return this.checkGaodingVip();
            } else if (isGaodingArt()) {
                // 稿定Art 逻辑（50行）
                return this.checkGaodingArtVip();
            }
            // 随着产品增加，分支越来越多...
        },
        
        checkInsMindVip() { /* ... */ },
        checkGaodingVip() { /* ... */ },
        checkGaodingArtVip() { /* ... */ },
    }
});

// 问题：
// 1. 核心代码被业务逻辑污染
// 2. 每个定制点都需要 if-else
// 3. 代码耦合度高
// 4. 无法真正「可插拔」
```

### 5.3 Kernel-X：Token 替换

```typescript
// 方案一：不同产品注册不同实现

// apps/design/src/main.ts
builder.initialize({
    services: [
        createGaodingVipExtension(),  // 稿定的 VIP 实现
        // ...
    ],
});

// apps/insmind/src/main.ts
builder.initialize({
    services: [
        createInsMindVipExtension(),  // InsMind 的 VIP 实现
        // 同一个 Token，不同实现
    ],
});

// ─────────────────────────────────────────────────────────

// 方案二：配置化创建扩展

// packages/kernel-x/design-services/src/services/vip/index.ts
export function createVipExtension(config: VipConfig) {
    return defineServiceExtension({
        id: VipServiceToken.id,
        dependencies: [UserServiceToken],
        
        async activate(context) {
            const userApi = await context.services.get(UserServiceToken);
            
            return {
                async checkVip() {
                    const user = await userApi.getUser();
                    
                    // 通过配置差异化，而非 if-else
                    return api.get(config.apiEndpoint, {
                        [config.userIdField]: user.id,
                    });
                },
                
                checkFeatureAccess(feature: string) {
                    // 使用配置中的规则
                    return config.featureRules[feature] || false;
                }
            };
        }
    });
}

// 使用
// apps/design/src/main.ts
createVipExtension({
    apiEndpoint: '/vip/status',
    userIdField: 'userId',
    featureRules: gaodingRules,
});

// apps/insmind/src/main.ts
createVipExtension({
    apiEndpoint: '/user/membership',
    userIdField: 'user_id',
    featureRules: insmindRules,
});

// 优势：
// 1. 核心代码保持干净
// 2. 差异通过配置或 Token 替换实现
// 3. 真正的「可插拔」
```

### 5.4 扩展机制对比图

```
┌─────────────────────────────────────────────────────────────────────┐
│                       扩展机制对比                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  第一代基座：if-else 分支                                            │
│  ────────────────────────                                            │
│                                                                       │
│  ┌───────────────────────────────────────────────────────────┐      │
│  │  VipService                                                 │      │
│  │  ┌─────────────────────────────────────────────────────┐  │      │
│  │  │  checkVip() {                                        │  │      │
│  │  │    if (isInsMind) {                                  │  │      │
│  │  │      // InsMind 逻辑 ─────────────────────────┐     │  │      │
│  │  │    } else if (isGaoding) {                    │     │  │      │
│  │  │      // 稿定逻辑 ────────────────────────┐    │     │  │      │
│  │  │    } else if (isGaodingArt) {            │    │     │  │      │
│  │  │      // Art 逻辑 ─────────────────┐      │    │     │  │      │
│  │  │    }                              │      │    │     │  │      │
│  │  │  }                                │      │    │     │  │      │
│  │  │                                   ▼      ▼    ▼     │  │      │
│  │  │                              业务逻辑污染核心代码    │  │      │
│  │  └─────────────────────────────────────────────────────┘  │      │
│  └───────────────────────────────────────────────────────────┘      │
│                                                                       │
│  ─────────────────────────────────────────────────────────────────   │
│                                                                       │
│  Kernel-X：Token 替换                                                │
│  ───────────────────                                                 │
│                                                                       │
│  ┌───────────────────┐     ┌───────────────────┐                   │
│  │  VipServiceToken  │     │  VipServiceToken  │                   │
│  │                   │     │                   │                   │
│  │  稿定设计         │     │  InsMind          │                   │
│  │  ┌─────────────┐ │     │  ┌─────────────┐ │                   │
│  │  │GaodingVip   │ │     │  │InsMindVip   │ │                   │
│  │  │Extension    │ │     │  │Extension    │ │                   │
│  │  └─────────────┘ │     │  └─────────────┘ │                   │
│  └───────────────────┘     └───────────────────┘                   │
│           │                         │                               │
│           │    同一个 Token        │                               │
│           │    不同实现            │                               │
│           └─────────┬───────────────┘                               │
│                     ▼                                                │
│           ┌───────────────────┐                                     │
│           │  context.services │                                     │
│           │  .get(VipToken)   │  ← 获取时返回对应实现              │
│           └───────────────────┘                                     │
│                                                                       │
│  核心代码保持干净，差异通过注册不同扩展实现                          │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 六、事件系统演进

### 6.1 无基座时代：各自实现

```typescript
// apps/design/services/event.ts
class EventBus {
    private listeners = new Map();
    
    emit(event: string, data: any) { /* ... */ }
    on(event: string, handler: Function) { /* ... */ }
}

export const eventBus = new EventBus();

// apps/insmind/services/event.ts
// 类似但略有不同的实现
class EventEmitter {
    emit(event: string, ...args: any[]) { /* ... */ }
    on(event: string, handler: Function) { /* ... */ }
}

// 问题：
// 1. 实现不统一
// 2. 事件名可能冲突
// 3. 类型完全无保障
```

### 6.2 第一代基座：mitt 字符串

```typescript
// packages/design/services/src/event/index.ts
import mitt from 'mitt';

export const lifecycleEventName = {
    EDITOR_READY: 'editor-ready',
    TEMPLATE_LOADED: 'template-loaded',
    SAVE_SUCCESS: 'save-success',
} as const;

export const lifecycleEvent = mitt();

// 使用
lifecycleEvent.emit(lifecycleEventName.EDITOR_READY);

lifecycleEvent.on(lifecycleEventName.EDITOR_READY, (data) => {
    // ⚠️ data 是 any 类型
    console.log(data.template);  // 可能 undefined
});

// 问题：
// 1. 事件名是字符串，拼错编译不报错
// 2. 事件数据是 any，无类型提示
// 3. emit/on 参数不匹配，编译不报错
// 4. 订阅需要手动清理
```

### 6.3 Kernel-X：EventToken + 泛型

```typescript
// 事件 Token 定义
interface EventToken<TData = void> {
    readonly key: string;
    readonly _phantom?: TData;  // 幻影类型
}

function createEventToken<TData = void>(key: string): EventToken<TData> {
    return { key } as EventToken<TData>;
}

// packages/kernel-x/design-services/src/events/lifecycle.ts
export const TemplateLoadedEvent = createEventToken<{
    template: Template;
    isNew: boolean;
}>('template-loaded');

export const SaveSuccessEvent = createEventToken<{
    templateId: string;
    savedAt: Date;
}>('save-success');

// 使用
// 发送事件（类型安全）
context.events.emit(TemplateLoadedEvent, {
    template: loadedTemplate,
    isNew: false,
});

// ❌ 类型错误：缺少 isNew 字段
context.events.emit(TemplateLoadedEvent, { template: loadedTemplate });

// 订阅事件（自动推断类型）
context.events.on(TemplateLoadedEvent, (data) => {
    console.log(data.template);  // ✓ Template 类型
    console.log(data.isNew);     // ✓ boolean 类型
    console.log(data.xxx);       // ❌ 编译错误
});

// 优势：
// 1. 类型安全：编译期检查
// 2. 自动清理：扩展卸载时自动取消订阅
// 3. 可追踪：所有订阅都被记录
```

### 6.4 事件系统对比图

```
┌─────────────────────────────────────────────────────────────────────┐
│                       事件系统对比                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  第一代基座：mitt + 字符串                                           │
│  ────────────────────────                                            │
│                                                                       │
│  // 定义                                                              │
│  const EDITOR_READY = 'editor-ready';  // 字符串                    │
│                                                                       │
│  // 发送                                                              │
│  event.emit('editor-ready', { ... });   // any 数据                 │
│  event.emit('editor-raedy', { ... });   // 拼错，编译不报错 ⚠️      │
│                                                                       │
│  // 订阅                                                              │
│  event.on('editor-ready', (data) => {                                │
│      data.xxx;  // any 类型，无提示 ⚠️                              │
│  });                                                                  │
│                                                                       │
│  // 清理                                                              │
│  event.off('editor-ready', handler);  // 必须手动清理 ⚠️            │
│                                                                       │
│  ─────────────────────────────────────────────────────────────────   │
│                                                                       │
│  Kernel-X：EventToken + 泛型                                         │
│  ─────────────────────────                                           │
│                                                                       │
│  // 定义                                                              │
│  const EditorReadyEvent = createEventToken<{                         │
│      editor: VPEditor;                                               │
│      timestamp: number;                                              │
│  }>('editor-ready');                                                 │
│                                                                       │
│  // 发送（类型检查）                                                  │
│  context.events.emit(EditorReadyEvent, {                             │
│      editor: vpEditor,                                               │
│      timestamp: Date.now(),                                          │
│  });  // ✓ 类型正确                                                  │
│                                                                       │
│  context.events.emit(EditorReadyEvent, {                             │
│      editor: vpEditor,                                               │
│  });  // ❌ 编译错误：缺少 timestamp                                 │
│                                                                       │
│  // 订阅（类型推断）                                                  │
│  context.events.on(EditorReadyEvent, (data) => {                     │
│      data.editor;     // ✓ VPEditor 类型                            │
│      data.timestamp;  // ✓ number 类型                              │
│      data.xxx;        // ❌ 编译错误                                 │
│  });                                                                  │
│                                                                       │
│  // 自动清理：扩展卸载时自动取消所有订阅                             │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 七、生命周期管理演进

### 7.1 无基座时代：无管理

```typescript
// 没有统一的生命周期概念
// 各组件自己管理自己的初始化和清理
```

### 7.2 第一代基座：手动管理

```typescript
// 组件中手动管理
onMounted(() => {
    // 手动初始化
    editorService.init();
    
    // 手动订阅
    lifecycleEvent.on('template-loaded', handleTemplateLoaded);
    lifecycleEvent.on('save-success', handleSaveSuccess);
    userStatusEvent.on('logout', handleLogout);
});

onUnmounted(() => {
    // ⚠️ 必须手动清理，容易忘记
    lifecycleEvent.off('template-loaded', handleTemplateLoaded);
    lifecycleEvent.off('save-success', handleSaveSuccess);
    // userStatusEvent.off('logout', handleLogout);  // 忘记清理！内存泄漏
});

// 问题：
// 1. 初始化分散在各处
// 2. 清理容易遗漏
// 3. 内存泄漏风险
// 4. 重复初始化防护需要各自实现
```

### 7.3 Kernel-X：自动管理

```typescript
// 扩展定义
export function createEditorExtension() {
    return defineServiceExtension({
        id: EditorServiceToken.id,
        dependencies: [UserServiceToken, VipServiceToken],
        
        async activate(context) {
            // context.events 是 Proxy 包装的
            // 所有订阅自动被追踪
            
            context.events.on(TemplateLoadedEvent, (data) => {
                // 处理模板加载
            });
            
            context.events.on(SaveSuccessEvent, (data) => {
                // 处理保存成功
            });
            
            // 无需手动清理！
            // 扩展卸载时自动取消所有订阅
            
            return {
                // 返回服务 API
            };
        },
        
        async deactivate() {
            // 可选：自定义清理逻辑
            // 事件订阅已自动清理
        }
    });
}

// 系统保证：
// 1. 激活只执行一次（幂等）
// 2. 并发请求共享同一个 Promise
// 3. 事件订阅自动追踪和清理
// 4. 卸载时按依赖逆序执行
```

### 7.4 生命周期对比图

```
┌─────────────────────────────────────────────────────────────────────┐
│                       生命周期管理对比                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  第一代基座：手动管理                                                 │
│  ─────────────────────                                               │
│                                                                       │
│  组件A                    组件B                    组件C             │
│  ┌─────────────┐        ┌─────────────┐        ┌─────────────┐     │
│  │onMounted    │        │onMounted    │        │onMounted    │     │
│  │  .on(event1)│        │  .on(event2)│        │  .on(event3)│     │
│  │  .on(event2)│        │  .on(event4)│        │  .on(event5)│     │
│  └─────────────┘        └─────────────┘        └─────────────┘     │
│  ┌─────────────┐        ┌─────────────┐        ┌─────────────┐     │
│  │onUnmounted  │        │onUnmounted  │        │onUnmounted  │     │
│  │  .off(event1)│       │  .off(event2)│       │  忘记清理！  │     │
│  │  .off(event2)│       │  .off(event4)│       │    ⚠️       │     │
│  └─────────────┘        └─────────────┘        └─────────────┘     │
│                                                                       │
│  问题：清理分散，容易遗漏                                            │
│                                                                       │
│  ─────────────────────────────────────────────────────────────────   │
│                                                                       │
│  Kernel-X：自动管理                                                   │
│  ─────────────────                                                   │
│                                                                       │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  ExtensionA activate()                                       │    │
│  │                                                               │    │
│  │  context.events.on(event1, handler1)  ──┐                    │    │
│  │  context.events.on(event2, handler2)  ──┼─► 自动追踪         │    │
│  │  context.events.on(event3, handler3)  ──┘                    │    │
│  │                                                               │    │
│  │  return api;                                                  │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                       │
│                              │                                        │
│                              ▼ 扩展卸载时                             │
│                                                                       │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  系统自动执行：                                               │    │
│  │                                                               │    │
│  │  for (const unsub of trackedSubscriptions) {                 │    │
│  │      unsub();  // 自动取消所有订阅                           │    │
│  │  }                                                            │    │
│  │                                                               │    │
│  │  await extension.deactivate?.();  // 调用自定义清理          │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                       │
│  优势：无需手动清理，不会遗漏                                        │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 八、类型安全演进

### 8.1 类型安全对比

```
┌─────────────────────────────────────────────────────────────────────┐
│                       类型安全对比                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  第一代基座：部分类型安全                                            │
│  ───────────────────────                                             │
│                                                                       │
│  // Pinia Store 有类型                                               │
│  const userStore = useUserStore();                                   │
│  userStore.user;  // ✓ 有类型                                       │
│                                                                       │
│  // 但事件系统无类型                                                 │
│  lifecycleEvent.emit('save-success', { ... });  // any              │
│  lifecycleEvent.on('save-success', (data) => {                       │
│      data.xxx;  // any，无提示                                       │
│  });                                                                  │
│                                                                       │
│  // 依赖关系无类型约束                                               │
│  const vipService = useVipService();                                 │
│  // 无法知道它依赖什么                                               │
│                                                                       │
│  ─────────────────────────────────────────────────────────────────   │
│                                                                       │
│  Kernel-X：全链路类型安全                                            │
│  ─────────────────────                                               │
│                                                                       │
│  // Token 携带类型                                                   │
│  const UserServiceToken: ServiceToken<UserServiceAPI> = ...;         │
│                                                                       │
│  // 获取时自动推断                                                   │
│  const userApi = await context.services.get(UserServiceToken);       │
│  userApi.login();  // ✓ 有类型提示                                  │
│  userApi.xxx();    // ❌ 编译错误                                    │
│                                                                       │
│  // 事件类型安全                                                     │
│  const SaveEvent = createEventToken<{ id: string }>('save');         │
│  context.events.emit(SaveEvent, { id: '123' });  // ✓               │
│  context.events.emit(SaveEvent, { xxx: 1 });     // ❌ 编译错误     │
│                                                                       │
│  // 层级隔离编译检查                                                 │
│  // Services 层无法访问 Components                                   │
│  context.components.get(...);  // ❌ ServiceContext 无此方法        │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

### 8.2 类型安全链路图

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Kernel-X 类型安全链路                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  1. Token 定义                                                        │
│  ─────────────                                                       │
│  const UserToken = createServiceToken<UserAPI>('user');              │
│                                           ▲                          │
│                                           │ 类型绑定                 │
│                                           │                          │
│  2. 扩展注册                                                          │
│  ─────────────                                                       │
│  defineServiceExtension<UserAPI>({                                   │
│      id: UserToken.id,                                               │
│      async activate() {                                              │
│          return {                                                    │
│              login(): Promise<User>,   // 必须符合 UserAPI          │
│              logout(): void,                                         │
│          };                                                          │
│      }                                                               │
│  });                                                                  │
│                                                                       │
│  3. 依赖获取                                                          │
│  ─────────────                                                       │
│  const userApi = await context.services.get(UserToken);              │
│  //    ^^^^^^^                                                       │
│  //    类型自动推断为 UserAPI | undefined                            │
│                                                                       │
│  4. 使用                                                              │
│  ─────────────                                                       │
│  userApi?.login();    // ✓ Promise<User>                            │
│  userApi?.getVip();   // ❌ 编译错误：UserAPI 无此方法              │
│                                                                       │
│  5. 事件                                                              │
│  ─────────────                                                       │
│  const LoginEvent = createEventToken<{ user: User }>('login');       │
│                                                                       │
│  context.events.emit(LoginEvent, { user });      // ✓               │
│  context.events.emit(LoginEvent, { userId });    // ❌ 类型错误     │
│                                                                       │
│  context.events.on(LoginEvent, (data) => {                           │
│      data.user;   // ✓ User 类型                                    │
│      data.xxx;    // ❌ 编译错误                                    │
│  });                                                                  │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 九、代码组织演进

### 9.1 目录结构对比

```
┌─────────────────────────────────────────────────────────────────────┐
│                       代码组织对比                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  第一代基座                                                           │
│  ──────────                                                          │
│                                                                       │
│  packages/design/services/src/                                       │
│  ├── user/                                                          │
│  │   ├── store.ts        # Pinia Store 定义                        │
│  │   └── index.ts        # 导出                                     │
│  ├── vip/                                                           │
│  │   ├── store.ts                                                   │
│  │   └── index.ts                                                   │
│  └── event/                                                         │
│      ├── lifecycle.ts    # 字符串事件名                             │
│      └── index.ts                                                   │
│                                                                       │
│  特点：                                                               │
│  • Store 定义 + 导出                                                 │
│  • 依赖隐藏在 store.ts 中                                           │
│  • 无明确的元数据                                                    │
│                                                                       │
│  ─────────────────────────────────────────────────────────────────   │
│                                                                       │
│  Kernel-X                                                            │
│  ─────────                                                           │
│                                                                       │
│  packages/kernel-x/design-services/src/services/                     │
│  ├── user/                                                          │
│  │   ├── token.ts        # Token 定义                               │
│  │   ├── type.ts         # API 类型定义                             │
│  │   ├── manifest.ts     # 元数据（依赖声明）                       │
│  │   └── index.ts        # 扩展实现（activate）                     │
│  ├── vip/                                                           │
│  │   ├── token.ts                                                   │
│  │   ├── type.ts                                                    │
│  │   ├── manifest.ts     # dependencies: [UserToken]                │
│  │   └── index.ts                                                   │
│  └── init-design/                                                   │
│      ├── token.ts                                                   │
│      ├── type.ts                                                    │
│      ├── manifest.ts                                                │
│      ├── activate.ts     # 复杂激活逻辑单独文件                     │
│      └── index.ts                                                   │
│                                                                       │
│  特点：                                                               │
│  • 4 文件结构：token / type / manifest / index                      │
│  • 依赖在 manifest 中显式声明                                       │
│  • 类型与实现分离                                                    │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

### 9.2 扩展文件详解

```typescript
// ========== token.ts ==========
// 定义 Token，是扩展的唯一标识 + 类型载体
import { createServiceToken } from '@design/kernel-x';
import type { VipServiceAPI } from './type';

export const VipServiceToken = createServiceToken<VipServiceAPI>('vip');


// ========== type.ts ==========
// 定义 API 类型，与实现分离
export interface VipServiceAPI {
    checkVip(): Promise<VipStatus>;
    checkFeatureAccess(feature: string): boolean;
    openPayment(options: PaymentOptions): void;
}

export interface VipStatus {
    isVip: boolean;
    level: number;
    expireTime: Date | null;
}


// ========== manifest.ts ==========
// 定义元数据，声明依赖关系
import { UserServiceToken } from '../user/token';
import { VipServiceToken } from './token';

export const manifest = {
    id: VipServiceToken.id,
    dependencies: [UserServiceToken],  // 显式声明依赖
};


// ========== index.ts ==========
// 实现扩展
import { defineServiceExtension } from '@design/kernel-x';
import { manifest } from './manifest';
import { UserServiceToken } from '../user/token';
import type { VipServiceAPI } from './type';

export function createVipExtension() {
    return defineServiceExtension<VipServiceAPI>({
        ...manifest,
        autoActivate: true,
        
        async activate(context) {
            // 获取依赖
            const userApi = await context.services.get(UserServiceToken);
            
            // 返回 API 实现
            return {
                async checkVip() {
                    const user = await userApi!.getUser();
                    if (!user) return { isVip: false, level: 0, expireTime: null };
                    return api.get('/vip/status', { userId: user.id });
                },
                
                checkFeatureAccess(feature) {
                    // 功能权限检查
                },
                
                openPayment(options) {
                    // 打开支付弹窗
                }
            };
        }
    });
}
```

---

## 十、性能与体验优化

### 10.1 代码分割对比

```
┌─────────────────────────────────────────────────────────────────────┐
│                       代码分割对比                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  第一代基座：无原生支持                                               │
│  ─────────────────────                                               │
│                                                                       │
│  // 所有服务在入口处一次性 import                                    │
│  import { useUserService } from '@design/services';                  │
│  import { useVipService } from '@design/services';                   │
│  import { useCollabService } from '@design/services';                │
│  // ... 180+ 服务全部打包                                            │
│                                                                       │
│  结果：                                                               │
│  • 首屏加载 180+ 服务代码                                            │
│  • 即使不用协同功能，也要加载 CollabService                          │
│  • bundle 体积大                                                     │
│                                                                       │
│  ─────────────────────────────────────────────────────────────────   │
│                                                                       │
│  Kernel-X：懒加载扩展                                                │
│  ─────────────────                                                   │
│                                                                       │
│  // 懒加载扩展定义                                                   │
│  export function createLazyCollabExtension() {                       │
│      return defineServiceExtension({                                 │
│          id: CollabServiceToken.id,                                  │
│          autoActivate: false,  // 关键：不自动激活                   │
│                                                                       │
│          async activate(context) {                                   │
│              // 动态导入，仅在需要时加载                             │
│              const { CollabService } = await import(                 │
│                  /* webpackChunkName: "collab" */                    │
│                  './collab-service'                                  │
│              );                                                       │
│              return new CollabService();                             │
│          }                                                           │
│      });                                                              │
│  }                                                                   │
│                                                                       │
│  // 使用时才加载                                                     │
│  async function openCollab() {                                       │
│      // 首次调用时触发激活，加载代码                                 │
│      const collabApi = await context.services.get(CollabServiceToken);│
│      await collabApi.connect();                                      │
│  }                                                                   │
│                                                                       │
│  结果：                                                               │
│  • 首屏只加载必要代码                                                │
│  • 协同功能按需加载                                                  │
│  • bundle 按功能分割                                                 │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

### 10.2 初始化性能对比

```
┌─────────────────────────────────────────────────────────────────────┐
│                       初始化性能对比                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  第一代基座                                                           │
│  ──────────                                                          │
│                                                                       │
│  // 串行初始化                                                       │
│  await userService.init();           // 100ms                        │
│  await vipService.init();            // 50ms                         │
│  await editorService.init();         // 80ms                         │
│  await fontsService.init();          // 150ms                        │
│  await collabService.init();         // 200ms                        │
│                                      ──────                          │
│                                      总计 580ms                      │
│                                                                       │
│  ─────────────────────────────────────────────────────────────────   │
│                                                                       │
│  Kernel-X（可并行）                                                   │
│  ─────────────────                                                   │
│                                                                       │
│  // 依赖图分析后并行激活                                             │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │                                                               │    │
│  │  第一轮（无依赖）:                                            │    │
│  │  user ─────────────────────► 100ms                           │    │
│  │                                                               │    │
│  │  第二轮（依赖 user）:                                         │    │
│  │  vip ──────► 50ms        ┐                                   │    │
│  │  editor ────────► 80ms   ├─ 并行，取最长 80ms                │    │
│  │                          ┘                                   │    │
│  │                                                               │    │
│  │  第三轮（依赖 editor）:                                       │    │
│  │  fonts ──────────────► 150ms  ┐                              │    │
│  │  collab ────────────────────► ├─ 并行，取最长 200ms          │    │
│  │          200ms                ┘                              │    │
│  │                                                               │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                       │
│  总计：100ms + 80ms + 200ms = 380ms（节省 35%）                      │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 十一、迁移路径

### 11.1 渐进式迁移策略

```
┌─────────────────────────────────────────────────────────────────────┐
│                       渐进式迁移策略                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  阶段一：共存                                                         │
│  ──────────                                                          │
│                                                                       │
│  • Kernel-X 和第一代基座共存                                         │
│  • 新功能使用 Kernel-X 开发                                          │
│  • 旧服务通过兼容层桥接                                              │
│                                                                       │
│  // 兼容层：将旧 Pinia Store 包装为 Kernel-X 扩展                    │
│  export function createUserExtension() {                             │
│      return defineServiceExtension({                                 │
│          id: UserServiceToken.id,                                    │
│          async activate() {                                          │
│              // 复用旧的 Pinia Store                                 │
│              return useUserService();                                │
│          }                                                           │
│      });                                                              │
│  }                                                                   │
│                                                                       │
│  ─────────────────────────────────────────────────────────────────   │
│                                                                       │
│  阶段二：事件迁移                                                     │
│  ──────────────                                                      │
│                                                                       │
│  • 使用事件兼容层桥接新旧事件系统                                    │
│  • 逐步将 mitt 事件迁移到 EventToken                                │
│                                                                       │
│  // 事件兼容层                                                       │
│  export function initEventCompatibility(context: KernelContext) {    │
│      // 旧系统发事件 → 新系统也发                                    │
│      lifecycleEvent.on('editor-ready', () => {                       │
│          context.events.emit(EditorReadyEvent);                      │
│      });                                                              │
│                                                                       │
│      // 新系统发事件 → 旧系统也发                                    │
│      context.events.on(EditorReadyEvent, () => {                     │
│          lifecycleEvent.emit('editor-ready');                        │
│      });                                                              │
│  }                                                                   │
│                                                                       │
│  ─────────────────────────────────────────────────────────────────   │
│                                                                       │
│  阶段三：逐步替换                                                     │
│  ──────────────                                                      │
│                                                                       │
│  • 按优先级逐步重写核心服务                                          │
│  • 使用 Token 替换机制切换实现                                       │
│  • 保持对外 API 兼容                                                 │
│                                                                       │
│  ─────────────────────────────────────────────────────────────────   │
│                                                                       │
│  阶段四：清理                                                         │
│  ──────────                                                          │
│                                                                       │
│  • 移除兼容层                                                        │
│  • 移除旧的 Pinia Store                                              │
│  • 移除 mitt 事件系统                                                │
│  • 完成全面迁移                                                      │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

### 11.2 迁移检查清单

| 检查项 | 说明 | 状态 |
|-------|------|------|
| Token 定义 | 为每个服务创建 Token | ✓ 必须 |
| 类型定义 | 定义 API 类型接口 | ✓ 必须 |
| Manifest 声明 | 显式声明依赖关系 | ✓ 必须 |
| 扩展实现 | 实现 activate 函数 | ✓ 必须 |
| 事件迁移 | 使用 EventToken | ○ 建议 |
| 兼容层 | 桥接新旧系统 | ○ 过渡期 |
| 单元测试 | 验证功能正确性 | ✓ 必须 |

---

## 十二、最佳实践总结

### 12.1 扩展开发最佳实践

```typescript
// ✓ 好的实践

// 1. Token 命名清晰
export const UserServiceToken = createServiceToken<UserServiceAPI>('user-service');

// 2. 类型定义完整
export interface UserServiceAPI {
    getUser(): Promise<User | null>;
    login(credentials: LoginCredentials): Promise<LoginResult>;
    logout(): Promise<void>;
}

// 3. 依赖显式声明
export const manifest = {
    id: UserServiceToken.id,
    dependencies: [AuthServiceToken, StorageServiceToken],
};

// 4. activate 返回完整 API
async activate(context) {
    const authApi = await context.services.get(AuthServiceToken);
    const storageApi = await context.services.get(StorageServiceToken);
    
    return {
        async getUser() {
            const token = await storageApi.get('token');
            if (!token) return null;
            return authApi.validateToken(token);
        },
        
        async login(credentials) {
            const result = await authApi.authenticate(credentials);
            if (result.success) {
                await storageApi.set('token', result.token);
            }
            return result;
        },
        
        async logout() {
            await storageApi.remove('token');
            await authApi.invalidate();
        }
    };
}

// ✗ 不好的实践

// 1. 直接 import 而不是通过 context
import { useAuthService } from '../auth';  // ❌ 隐式依赖

// 2. 未声明依赖
export const manifest = {
    id: UserServiceToken.id,
    dependencies: [],  // ❌ 实际依赖了 Auth 和 Storage
};

// 3. 返回不完整的 API
async activate() {
    return {
        getUser() { ... },
        // ❌ 缺少 login 和 logout
    };
}
```

### 12.2 事件使用最佳实践

```typescript
// ✓ 好的实践

// 1. 事件 Token 类型完整
export const UserLoginEvent = createEventToken<{
    user: User;
    timestamp: number;
    source: 'modal' | 'redirect';
}>('user-login');

// 2. 发送时提供完整数据
context.events.emit(UserLoginEvent, {
    user: loggedInUser,
    timestamp: Date.now(),
    source: 'modal',
});

// 3. 订阅在 activate 中，自动清理
async activate(context) {
    context.events.on(UserLoginEvent, (data) => {
        // 处理登录事件
    });
    
    // 无需手动 off，扩展卸载时自动清理
}


// ✗ 不好的实践

// 1. 类型定义不完整
const LoginEvent = createEventToken<any>('login');  // ❌ any 类型

// 2. 使用旧的 mitt 事件
lifecycleEvent.emit('user-login', { ... });  // ❌ 字符串事件名

// 3. 在组件中订阅忘记清理
onMounted(() => {
    lifecycleEvent.on('xxx', handler);
});
// ❌ 忘记 onUnmounted 中 off
```

---

## 十三、总结与展望

### 13.1 演进成果

```
┌─────────────────────────────────────────────────────────────────────┐
│                       架构演进成果                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  解决的问题                                                   │    │
│  │                                                               │    │
│  │  ✓ 代码重复        → 扩展复用，配置差异化                    │    │
│  │  ✓ 隐式依赖        → 显式声明，静态分析                      │    │
│  │  ✓ 手动编排        → 自动拓扑排序                            │    │
│  │  ✓ 扩展困难        → Token 替换，可插拔                      │    │
│  │  ✓ 类型不安全      → 全链路类型安全                          │    │
│  │  ✓ 内存泄漏        → 自动追踪清理                            │    │
│  │  ✓ 代码分割困难    → 懒加载扩展                              │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                       │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  量化收益                                                     │    │
│  │                                                               │    │
│  │  • 代码重复：-100%（从 15000+ 行降至 0）                     │    │
│  │  • 新产品开发：-55%（从 10 周降至 4.5 周）                   │    │
│  │  • Bug 修复：-80%（从 N 处改为 1 处）                        │    │
│  │  • 初始化性能：-35%（并行激活优化）                          │    │
│  │  • 类型错误：-90%（编译期检查）                              │    │
│  │  • 内存泄漏：-95%（自动清理）                                │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

### 13.2 架构原则总结

| 原则 | 第一代实现 | Kernel-X 实现 |
|-----|----------|---------------|
| **依赖倒置** | 直接 import 具体实现 | 依赖 Token 抽象 |
| **开闭原则** | 修改核心代码扩展 | Token 替换扩展 |
| **单一职责** | 服务职责边界模糊 | 扩展职责明确 |
| **接口隔离** | 无明确接口定义 | Type 定义 API 契约 |
| **控制反转** | 无 | Context 注入依赖 |

### 13.3 未来展望

```
┌─────────────────────────────────────────────────────────────────────┐
│                       未来演进方向                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  短期（6个月）                                                        │
│  ─────────────                                                       │
│  • 完成核心服务迁移到 Kernel-X                                       │
│  • 移除事件兼容层                                                    │
│  • 完善开发者文档和工具                                              │
│                                                                       │
│  中期（1年）                                                          │
│  ──────────                                                          │
│  • 实现热更新扩展                                                    │
│  • 引入扩展市场概念                                                  │
│  • 支持第三方扩展开发                                                │
│                                                                       │
│  长期（2年）                                                          │
│  ──────────                                                          │
│  • 跨平台扩展（Web/Desktop/Mobile）                                  │
│  • 扩展沙箱隔离                                                      │
│  • AI 辅助扩展开发                                                   │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 十四、附录：快速参考

### 14.1 核心概念速查

| 概念 | 定义 | 用途 |
|-----|------|-----|
| **Token** | 扩展唯一标识 + 类型载体 | 依赖声明、类型推断 |
| **Manifest** | 扩展静态元数据 | 声明 ID 和依赖 |
| **Activate** | 扩展激活函数 | 初始化并返回 API |
| **Context** | 受限的执行上下文 | 获取依赖、发送事件 |
| **Registry** | 扩展注册表 | 管理扩展注册和激活 |

### 14.2 三层架构速查

| 层级 | 职责 | 可访问 | 示例 |
|-----|------|-------|------|
| **Services** | 纯业务逻辑 | services, events | UserService, VipService |
| **Components** | UI 组件 | components, services, events | DesignLayout, Header |
| **Extensions** | 场景整合 | 全部 | InitDesign |

### 14.3 激活模式速查

| 模式 | 配置 | 时机 | 场景 |
|-----|------|-----|------|
| **立即** | `autoActivate: true` | 注册时 | 核心服务 |
| **延迟** | `autoActivate: false` | get() 时 | 可选功能 |
| **条件** | `autoActivate: async () => {}` | 条件满足 | 依赖外部条件 |

---

> 📖 **系列文档导航**
> 
> - [x] 第一篇：业务现状与基座化需求
> - [x] 第二篇：第一代基座方案实现
> - [x] 第三篇：Kernel-X 架构详解
> - [x] **第四篇：架构演进总结**（本文）

---

## 结语

从「无基座」到「第一代基座」再到「Kernel-X」，编辑器架构经历了三次重大演进：

1. **无基座时代**：快速但混乱，技术债务快速累积
2. **第一代基座**：抽取复用，但依赖混乱、扩展困难
3. **Kernel-X**：类型安全、自动编排、可插拔

每次演进都是对前一阶段问题的回应，也为下一阶段的发展奠定基础。Kernel-X 不是终点，而是一个能够持续演进的架构基础。

**核心经验**：
- 架构演进需要业务驱动
- 渐进式迁移比大规模重写更可行
- 类型安全是大型项目的基石
- 显式优于隐式
- 约定不如约束
