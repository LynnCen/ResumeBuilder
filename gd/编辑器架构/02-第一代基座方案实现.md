# 第一代基座方案实现

## 一、方案概述

### 1.1 技术选型

第一代基座方案基于 **Pinia + Vue + mitt** 技术栈，将公共服务抽取到独立包：

```
┌─────────────────────────────────────────────────────────────────────┐
│                       第一代基座架构                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│                        apps/design                                   │
│                        apps/insmind                                  │
│                             │                                        │
│                             ▼                                        │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │              @design/design-view-foundation                    │  │
│  │                    (应用入口层)                                │  │
│  │                                                                 │  │
│  │  职责：                                                         │  │
│  │  • 编排服务初始化顺序                                          │  │
│  │  • 创建 Vue 应用实例                                           │  │
│  │  • 配置路由和插件                                              │  │
│  │  • 环境适配                                                    │  │
│  └────────────────────────────┬──────────────────────────────────┘  │
│                               │                                      │
│                               ▼                                      │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │                   @design/business-ui                          │  │
│  │                    (业务UI组件层)                              │  │
│  │                                                                 │  │
│  │  内容：                                                         │  │
│  │  • 950+ Vue 组件                                               │  │
│  │  • 200+ Composition 函数                                       │  │
│  │  • 通用 Hooks                                                  │  │
│  └────────────────────────────┬──────────────────────────────────┘  │
│                               │                                      │
│                               ▼                                      │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │                    @design/services                            │  │
│  │                    (业务服务层)                                │  │
│  │                                                                 │  │
│  │  内容：                                                         │  │
│  │  • 180+ Pinia Store 服务                                       │  │
│  │  • 事件系统（mitt）                                            │  │
│  │  • 业务逻辑封装                                                │  │
│  └────────────────────────────┬──────────────────────────────────┘  │
│                               │                                      │
│                               ▼                                      │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │                     @design/stores                             │  │
│  │                    (底层状态管理)                              │  │
│  │                                                                 │  │
│  │  内容：                                                         │  │
│  │  • EditorStore（编辑器核心状态）                               │  │
│  │  • UserStore（用户状态）                                       │  │
│  │  • TemplateStore（模板状态）                                   │  │
│  └───────────────────────────────────────────────────────────────┘  │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

### 1.2 包目录结构详解

```
packages/
├── foundations/
│   └── design-view/                     # Foundation 层
│       └── src/
│           ├── init/                    # 初始化逻辑
│           │   ├── index.ts            # 主入口 initDesign()
│           │   ├── init-api.ts         # API 配置
│           │   ├── init-env.ts         # 环境变量
│           │   ├── init-log.ts         # 日志初始化
│           │   ├── init-permission.ts  # 权限初始化
│           │   └── init-router.ts      # 路由配置
│           │
│           ├── compositions/            # 组合式函数
│           │   ├── use-init-design-view.ts
│           │   ├── use-editor-layer.ts
│           │   └── ...
│           │
│           └── layout/                  # 布局组件
│               └── app.vue
│
├── design/
│   ├── services/                        # 服务层
│   │   └── src/
│   │       ├── user/                   # 用户服务
│   │       │   ├── store.ts
│   │       │   └── index.ts
│   │       ├── vip/                    # VIP 服务
│   │       ├── editor/                 # 编辑器服务
│   │       ├── fonts/                  # 字体服务
│   │       ├── collab/                 # 协同服务
│   │       ├── lifecycle/              # 生命周期服务
│   │       ├── material-uploader/      # 素材上传
│   │       ├── tracker/                # 埋点追踪
│   │       ├── guide/                  # 新手引导
│   │       ├── enterprise/             # 企业版
│   │       ├── event/                  # 事件系统 ⭐
│   │       │   ├── index.ts           # 事件定义
│   │       │   ├── lifecycle.ts       # 生命周期事件
│   │       │   ├── skeleton.ts        # 骨架屏事件
│   │       │   └── user-status.ts     # 用户状态事件
│   │       └── ...                     # 180+ 服务
│   │
│   ├── business-ui/                     # UI 组件层
│   │   └── src/
│   │       ├── components/             # 组件目录
│   │       │   ├── header/            # 顶部工具栏
│   │       │   ├── aside/             # 左侧面板
│   │       │   ├── right-panel/       # 右侧属性面板
│   │       │   ├── material/          # 素材组件
│   │       │   ├── layer/             # 图层组件
│   │       │   └── ...                # 400+ 组件目录
│   │       │
│   │       ├── compositions/          # 组合式函数
│   │       │   ├── use-editor-layer.ts
│   │       │   ├── use-hotkey/
│   │       │   ├── use-creation/
│   │       │   └── ...
│   │       │
│   │       └── hooks/                 # 通用 Hooks
│   │           ├── use-colors/
│   │           ├── use-effects/
│   │           └── ...
│   │
│   └── stores/                         # 底层状态
│       └── src/
│           ├── editor/                # 编辑器状态
│           ├── user/                  # 用户状态
│           ├── template/              # 模板状态
│           └── pinia.ts               # Pinia 实例
```

### 1.3 核心包职责

| 包名 | 职责 | 文件数量 | 代码行数 |
|-----|------|---------|---------|
| `@design/design-view-foundation` | 应用入口，编排初始化流程 | 30+ | ~3000 |
| `@design/services` | 业务服务层，封装核心业务逻辑 | 180+ | ~25000 |
| `@design/business-ui` | 业务UI层，复用的Vue组件 | 950+ | ~80000 |
| `@design/stores` | 底层状态，Editor/User/Template | 20+ | ~5000 |

---

## 二、Foundation 层详解

### 2.1 Foundation 的定位

Foundation 是**应用与基座的连接层**，承担着关键的编排职责：

```
┌─────────────────────────────────────────────────────────────────────┐
│                      Foundation 层职责                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│     apps/design              apps/design-view        apps/insmind    │
│          │                         │                       │         │
│          │    传入配置             │    传入配置           │         │
│          │                         │                       │         │
│          └─────────────────────────┼───────────────────────┘         │
│                                    │                                  │
│                                    ▼                                  │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │              @design/design-view-foundation                  │    │
│  │                                                               │    │
│  │  ┌─────────────────────────────────────────────────────┐    │    │
│  │  │  initDesign(selector, config)                        │    │    │
│  │  │                                                       │    │    │
│  │  │  1. initEnv()        → 环境变量设置                  │    │    │
│  │  │  2. initAPI()        → API 配置（baseURL、headers） │    │    │
│  │  │  3. initPermission() → 权限点初始化                  │    │    │
│  │  │  4. initLog()        → 日志服务（SLS）               │    │    │
│  │  │  5. initResourceManage() → 资源管理器                │    │    │
│  │  │  6. createApp()      → 创建 Vue 应用                 │    │    │
│  │  │  7. initPlugins()    → 安装 Vue 插件                 │    │    │
│  │  │  8. initRouter()     → 配置路由                      │    │    │
│  │  │  9. app.mount()      → 挂载应用                      │    │    │
│  │  └─────────────────────────────────────────────────────┘    │    │
│  │                                                               │    │
│  │  ┌─────────────────────────────────────────────────────┐    │    │
│  │  │  useInitDesignView()                                 │    │    │
│  │  │                                                       │    │    │
│  │  │  组合式函数，供 Vue 组件使用：                        │    │    │
│  │  │  • initEditor() → 编辑器实例创建后                   │    │    │
│  │  │  • initDesign() → 模板加载后                         │    │    │
│  │  │  • initFontsAndWatermark() → 字体和水印              │    │    │
│  │  └─────────────────────────────────────────────────────┘    │    │
│  │                                                               │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                    │                                  │
│                                    ▼                                  │
│                  @design/services + @design/stores                   │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.2 初始化入口 initDesign

```typescript
// foundations/design-view/src/init/index.ts

import { createApp } from 'vue-demi';
import VueRouter from 'vue-router';
import { PiniaVuePlugin } from 'pinia';
import { pinia } from '@design/stores';

import { initEnv } from './init-env';
import { initAPI } from './init-api';
import { initPermission } from './init-permission';
import { initLog } from './init-log';
import { initResourceManage } from './init-resource-manager';
import App from '../layout/app.vue';

export interface DesignConfig {
    env: {
        APP_BASE_URL: string;
        APP_LOGIN_MODAL?: { TYPE: string };
        FAVICON_LINK?: string;
    };
    apis: {
        baseURL: string;
        timeout?: number;
    };
    permissions?: Record<string, boolean>;
    editorConfig?: {
        defaultPadding?: number[];
        enableCollab?: boolean;
        commercial?: object;
    };
}

/**
 * 初始化设计应用
 * 
 * 这是整个应用的入口点，负责编排所有服务的初始化顺序
 */
export function initDesign(selector: string, config: DesignConfig) {
    // ================ 第一阶段：基础配置 ================
    
    // 1. 环境变量初始化
    // 设置全局环境变量，供其他服务使用
    initEnv(config.env);
    
    // 2. API 配置初始化
    // 配置 axios 实例的 baseURL、headers、interceptors
    initAPI(config.apis);
    
    // 3. 权限点初始化
    // 加载用户权限配置，控制功能开关
    initPermission(config.permissions || {});
    
    // 4. 编辑器配置
    // 设置编辑器相关配置项
    editorConfigService.setConfig(config.editorConfig || {});
    
    // 5. 资源管理初始化
    // 初始化图片、字体等资源的管理器
    initResourceManage();
    
    // ================ 第二阶段：创建 Vue 应用 ================
    
    // 6. 创建 Vue 应用实例
    const app = createApp({
        pinia,  // 注入 Pinia 实例
        router, // 注入路由实例
        render(h: Function) {
            return h(App);
        }
    });
    
    // 7. 安装 Vue 插件
    app.use(PiniaVuePlugin);
    app.use(VueRouter);
    
    // 8. 初始化日志服务
    initLog(app, config.slsConfig);
    
    // ================ 第三阶段：挂载应用 ================
    
    // 9. 挂载到 DOM
    app.mount(selector);
    
    return app;
}
```

### 2.3 编辑器初始化 Composition

Foundation 提供 `useInitDesignView` 组合式函数，供 Vue 组件在不同时机调用：

```typescript
// foundations/design-view/src/compositions/use-init-design-view.ts

import { useUserService } from '@design/services';
import { useEnterpriseService } from '@design/services';
import { useEditorStore, useTemplateStore } from '@design/stores';
import { lifecycleEvent, lifecycleEventName } from '@design/services';
import { permissionController } from '@design/services';

export function useInitDesignView() {
    // ============ 获取所有需要的服务 ============
    // 注意：这里是直接 import 获取，没有依赖声明
    const userService = useUserService();
    const enterpriseService = useEnterpriseService();
    const editorStore = useEditorStore();
    const templateStore = useTemplateStore();
    const vipService = useVipService();
    const fontsService = useFontsService();
    const collabService = useCollabService();
    const guideService = useGuideService();
    
    /**
     * 编辑器实例创建后调用
     * 时机：VPEditor 实例化完成
     */
    function initEditor(editor: VPEditor, isH5Template: boolean) {
        // 1. 将编辑器实例存入全局状态
        editorStore.setEditor(editor);
        
        // 2. 初始化资源管理器
        initResourceManager(editor);
        
        // 3. 设置编辑器模式（H5 或普通）
        if (isH5Template) {
            editor.setMode('h5');
        }
        
        // 4. 发送生命周期事件
        lifecycleEvent.emit(lifecycleEventName.EDITOR_INIT);
    }
    
    /**
     * 模板加载后调用
     * 时机：模板数据获取完成，准备渲染
     */
    async function initDesign(template: Template) {
        try {
            // ============ 第一步：并行初始化基础服务 ============
            // 用户和企业信息可以并行加载
            await Promise.all([
                enterpriseService.init(),
                userService.init()
            ]);
            
            // ============ 第二步：依赖用户的服务 ============
            // VIP 服务依赖用户信息
            await vipService.init();
            
            // ============ 第三步：权限初始化 ============
            // 企业权限的二次初始化（依赖企业和用户信息）
            await enterpriseService.initSecondary();
            permissionController.init({ enable: true, loaded: true });
            
            // ============ 第四步：设置模板 ============
            templateStore.setTemplate(template);
            
            // ============ 第五步：发送就绪事件 ============
            lifecycleEvent.emit(lifecycleEventName.TEMPLATE_LOADED, { template });
            
        } catch (error) {
            console.error('初始化失败:', error);
            lifecycleEvent.emit(lifecycleEventName.INIT_ERROR, { error });
        }
    }
    
    /**
     * 字体和水印初始化
     * 时机：模板渲染后，需要加载字体
     */
    async function initFontsAndWatermark(template: Template, isH5Template: boolean) {
        // 1. 获取模板使用的字体列表
        const fontIds = extractFontIds(template);
        
        // 2. 加载字体
        await fontsService.loadFonts(fontIds);
        
        // 3. 初始化水印（如果需要）
        if (template.watermark) {
            await initWatermark(template.watermark);
        }
        
        // 4. 发送字体加载完成事件
        lifecycleEvent.emit(lifecycleEventName.FONT_LOADED);
    }
    
    return {
        initEditor,
        initDesign,
        initFontsAndWatermark
    };
}

// 使用示例（在 Vue 组件中）
// design-view.vue
export default {
    setup() {
        const { initEditor, initDesign, initFontsAndWatermark } = useInitDesignView();
        
        onMounted(async () => {
            // 1. 创建编辑器
            const editor = new VPEditor(canvasEl.value);
            initEditor(editor, isH5.value);
            
            // 2. 加载模板
            const template = await fetchTemplate(templateId);
            await initDesign(template);
            
            // 3. 加载字体
            await initFontsAndWatermark(template, isH5.value);
            
            // 4. 最终就绪
            lifecycleEvent.emit(lifecycleEventName.EDITOR_READY);
        });
    }
}
```

### 2.4 Foundation 的核心问题

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Foundation 层的核心问题                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  问题1：初始化顺序完全由手动代码控制                                  │
│  ────────────────────────────────                                    │
│                                                                       │
│  // 正确顺序必须人工保证                                             │
│  await enterpriseService.init();     // 1                            │
│  await userService.init();           // 2                            │
│  await vipService.init();            // 3 - 必须在 user 之后        │
│  await enterpriseService.initSecondary(); // 4                       │
│                                                                       │
│  // 如果有人不小心改成：                                             │
│  await vipService.init();            // ❌ user 还没初始化           │
│  await userService.init();           // 顺序错了！                   │
│                                                                       │
│  ─────────────────────────────────────────────────────────────────   │
│                                                                       │
│  问题2：依赖关系没有显式声明                                          │
│  ────────────────────────────                                        │
│                                                                       │
│  // useInitDesignView 内部直接 import，无法知道完整依赖               │
│  const userService = useUserService();                               │
│  const vipService = useVipService();  // vip 依赖 user，但看不出来   │
│  const fontsService = useFontsService();                             │
│                                                                       │
│  // 问题：                                                           │
│  // - 新人接手无法快速理解依赖关系                                   │
│  // - 删除某个服务不知道会影响什么                                   │
│  // - 无法自动检测循环依赖                                           │
│                                                                       │
│  ─────────────────────────────────────────────────────────────────   │
│                                                                       │
│  问题3：扩展困难                                                      │
│  ──────────                                                          │
│                                                                       │
│  // InsMind 想要替换 VIP 服务的实现                                  │
│  // 当前只能修改 useInitDesignView 源码                              │
│  // 或者在 useVipService 内部加 if-else                              │
│                                                                       │
│  if (isInsMind) {                                                    │
│      // InsMind 的 VIP 逻辑                                          │
│  } else {                                                            │
│      // 稿定的 VIP 逻辑                                              │
│  }                                                                   │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 三、Services 层详解

### 3.1 Pinia Store 模式

所有服务统一使用 `defineStore` 定义，遵循统一的模式：

```typescript
// @design/services/src/editor/store.ts

import { defineStore } from 'pinia';
import { useUserStore, useTemplateStore } from '@design/stores';
import { lifecycleEvent, lifecycleEventName } from '../event';

/**
 * 编辑器服务
 * 
 * 职责：
 * - 管理编辑器相关的业务逻辑
 * - 协调其他服务的调用
 * - 维护编辑器状态
 */
export const useEditorService = defineStore('editor-service', {
    // ============ 状态定义 ============
    state() {
        return {
            // 初始化标记（防止重复初始化）
            $saveInited: false,
            $clipboardInited: false,
            $historyInited: false,
            
            // 功能开关
            $enableAutoSelectLayout: true,
            $enableMultiSelect: true,
            
            // 运行时状态
            $isEditing: false,
            $isDirty: false,
        };
    },
    
    // ============ 计算属性 ============
    getters: {
        /**
         * 是否允许添加布局
         * 依赖用户权限和 VIP 状态
         */
        enableAddLayout(): boolean {
            const userStore = useUserStore();
            const vipService = useVipService();
            
            // 业务逻辑：VIP 用户或有特殊权限
            return vipService.isVip || userStore.hasPermission('add_layout');
        },
        
        /**
         * 当前编辑器实例
         */
        editor(): VPEditor | null {
            const editorStore = useEditorStore();
            return editorStore.editor;
        }
    },
    
    // ============ 业务方法 ============
    actions: {
        /**
         * 初始化保存功能
         * 设置自动保存、手动保存等
         */
        async initSave() {
            // 幂等检查：防止重复初始化
            if (this.$saveInited) return;
            
            const templateStore = useTemplateStore();
            
            // 设置自动保存
            this.setupAutoSave();
            
            // 监听模板变化
            templateStore.$subscribe((mutation, state) => {
                this.$isDirty = true;
            });
            
            this.$saveInited = true;
            
            // 发送事件
            lifecycleEvent.emit(lifecycleEventName.SAVE_INITED);
        },
        
        /**
         * 初始化剪贴板功能
         */
        async initClipboard() {
            if (this.$clipboardInited) return;
            
            // 注册快捷键
            this.registerHotkeys();
            
            // 监听粘贴事件
            document.addEventListener('paste', this.handlePaste);
            
            this.$clipboardInited = true;
        },
        
        /**
         * 执行保存
         */
        async save() {
            if (!this.$isDirty) return;
            
            const templateStore = useTemplateStore();
            const userStore = useUserStore();
            
            // 检查登录状态
            if (!userStore.isLoggedIn) {
                throw new Error('请先登录');
            }
            
            try {
                // 调用 API 保存
                await api.saveTemplate(templateStore.template);
                this.$isDirty = false;
                
                // 发送保存成功事件
                lifecycleEvent.emit(lifecycleEventName.SAVE_SUCCESS);
            } catch (error) {
                lifecycleEvent.emit(lifecycleEventName.SAVE_ERROR, { error });
                throw error;
            }
        },
        
        // 私有方法
        setupAutoSave() {
            setInterval(() => {
                if (this.$isDirty) {
                    this.save().catch(console.error);
                }
            }, 30000); // 30秒自动保存
        },
        
        registerHotkeys() {
            // Ctrl+C, Ctrl+V 等
        },
        
        handlePaste(event: ClipboardEvent) {
            // 粘贴处理逻辑
        }
    }
});
```

### 3.2 服务分类与目录结构

```
@design/services/src/
│
├── =============== 用户相关 ===============
├── user/                      # 用户服务
│   ├── store.ts              # Pinia Store 定义
│   ├── index.ts              # 导出
│   └── types.ts              # 类型定义
│
├── vip/                       # VIP 权益服务
│   ├── store.ts              # VIP 状态和方法
│   ├── payment.ts            # 支付相关
│   └── index.ts
│
├── enterprise/                # 企业版服务
│   ├── store.ts
│   └── index.ts
│
├── =============== 编辑器核心 ===============
├── editor/                    # 编辑器服务
│   ├── store.ts              # 编辑器业务逻辑
│   ├── clipboard.ts          # 剪贴板功能
│   ├── history.ts            # 历史记录
│   └── index.ts
│
├── fonts/                     # 字体服务
│   ├── store.ts              # 字体加载和管理
│   ├── loader.ts             # 字体加载器
│   └── index.ts
│
├── lifecycle/                 # 生命周期服务
│   ├── init-template.ts      # 模板初始化
│   ├── save-template.ts      # 模板保存
│   ├── export-template.ts    # 模板导出
│   └── index.ts
│
├── =============== 协同与版本 ===============
├── collab/                    # 协同编辑服务
│   ├── store.ts              # 协同状态
│   ├── websocket.ts          # WebSocket 连接
│   ├── conflict.ts           # 冲突处理
│   └── index.ts
│
├── =============== 素材与资源 ===============
├── material-uploader/         # 素材上传服务
│   ├── store.ts
│   ├── oss.ts                # OSS 上传
│   └── index.ts
│
├── =============== 运营相关 ===============
├── tracker/                   # 埋点追踪服务
│   ├── store.ts
│   ├── events.ts             # 埋点事件定义
│   └── index.ts
│
├── guide/                     # 新手引导服务
│   ├── store.ts
│   └── index.ts
│
├── =============== 事件系统 ===============
├── event/                     # 事件系统 ⭐
│   ├── index.ts              # 导出所有事件
│   ├── lifecycle.ts          # 生命周期事件
│   ├── skeleton.ts           # 骨架屏事件
│   ├── user-status.ts        # 用户状态事件
│   └── editor-outside.ts     # 外部通信事件
│
└── index.ts                   # 统一导出
```

### 3.3 服务间依赖关系

服务之间通过 **直接 import** 建立依赖：

```typescript
// vip/store.ts - VIP 服务依赖用户服务

import { defineStore } from 'pinia';
import { useUserStore } from '@design/stores';

export const useVipService = defineStore('vip-service', {
    state() {
        return {
            $inited: false,
            isVip: false,
            vipLevel: 0,
            expireTime: null as Date | null,
        };
    },
    
    actions: {
        async init() {
            if (this.$inited) return;
            
            // ⚠️ 隐式依赖：直接调用 useUserStore
            // 如果 UserStore 未初始化，这里可能出问题
            const userStore = useUserStore();
            
            if (!userStore.user) {
                // 用户未登录，无法获取 VIP 状态
                this.isVip = false;
                return;
            }
            
            // 调用 API 获取 VIP 状态
            const vipStatus = await api.getVipStatus(userStore.user.id);
            
            this.isVip = vipStatus.isVip;
            this.vipLevel = vipStatus.level;
            this.expireTime = new Date(vipStatus.expireTime);
            
            this.$inited = true;
        },
        
        async checkVipStatus() {
            const userStore = useUserStore();
            
            if (!userStore.user) {
                return { isVip: false };
            }
            
            return {
                isVip: this.isVip,
                level: this.vipLevel,
                canUseFeature: (feature: string) => {
                    // 根据 VIP 等级判断功能权限
                    return this.checkFeatureAccess(feature);
                }
            };
        },
        
        checkFeatureAccess(feature: string): boolean {
            // VIP 功能权限检查逻辑
            const featureRequirements: Record<string, number> = {
                'export-hd': 1,      // VIP 1 级
                'remove-watermark': 1,
                'batch-export': 2,   // VIP 2 级
                'collab': 2,
            };
            
            return this.vipLevel >= (featureRequirements[feature] || 0);
        }
    }
});
```

**依赖关系可视化**：

```
┌─────────────────────────────────────────────────────────────────────┐
│                       服务依赖关系图                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│                         ┌─────────────┐                              │
│                         │ UserStore   │                              │
│                         │ (用户状态)  │                              │
│                         └──────┬──────┘                              │
│                                │                                      │
│         ┌──────────────────────┼──────────────────────┐              │
│         │                      │                      │              │
│         ▼                      ▼                      ▼              │
│  ┌─────────────┐       ┌─────────────┐       ┌─────────────┐        │
│  │ VipService  │       │ Enterprise  │       │ CollabSvc   │        │
│  │ (VIP权益)   │       │ Service     │       │ (协同)      │        │
│  └──────┬──────┘       └──────┬──────┘       └──────┬──────┘        │
│         │                      │                      │              │
│         │                      ▼                      │              │
│         │              ┌─────────────┐               │              │
│         │              │ Permission  │               │              │
│         │              │ Controller  │               │              │
│         │              └──────┬──────┘               │              │
│         │                      │                      │              │
│         └──────────────────────┼──────────────────────┘              │
│                                │                                      │
│                                ▼                                      │
│                        ┌─────────────┐                               │
│                        │EditorService│                               │
│                        │(编辑器核心) │                               │
│                        └──────┬──────┘                               │
│                                │                                      │
│         ┌──────────────────────┼──────────────────────┐              │
│         │                      │                      │              │
│         ▼                      ▼                      ▼              │
│  ┌─────────────┐       ┌─────────────┐       ┌─────────────┐        │
│  │ FontsSvc    │       │ SaveSvc     │       │ ExportSvc   │        │
│  │ (字体)      │       │ (保存)      │       │ (导出)      │        │
│  └─────────────┘       └──────┬──────┘       └─────────────┘        │
│                                │                                      │
│                                ▼                                      │
│                        ┌─────────────┐                               │
│                        │ UploadSvc   │                               │
│                        │ (上传)      │                               │
│                        └─────────────┘                               │
│                                                                       │
│  ⚠️ 问题：                                                           │
│  • 依赖关系通过 import 隐式建立，难以追踪全貌                         │
│  • 无法静态分析依赖图                                                │
│  • 初始化顺序需要人工保证                                            │
│  • 循环依赖难以检测                                                  │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 四、事件系统详解

### 4.1 基于 mitt 的事件发射器

```typescript
// @design/services/src/event/index.ts

import mitt from 'mitt';

// ============ 生命周期事件 ============
export const lifecycleEventName = {
    // 编辑器相关
    EDITOR_INIT: 'editor-init',
    EDITOR_READY: 'editor-ready',
    EDITOR_DESTROY: 'editor-destroy',
    
    // 模板相关
    TEMPLATE_LOADED: 'template-loaded',
    TEMPLATE_CHANGED: 'template-changed',
    
    // 保存相关
    SAVE_INITED: 'save-inited',
    SAVE_START: 'save-start',
    SAVE_SUCCESS: 'save-success',
    SAVE_ERROR: 'save-error',
    
    // 字体相关
    FONT_LOADED: 'font-loaded',
    FONT_LOAD_ERROR: 'font-load-error',
    
    // 初始化错误
    INIT_ERROR: 'init-error',
} as const;

export const lifecycleEvent = mitt();

// ============ 骨架屏事件 ============
export const skeletonEventName = {
    SHOW: 'skeleton-show',
    HIDE: 'skeleton-hide',
    UPDATE: 'skeleton-update',
} as const;

export const skeletonEvent = mitt();

// ============ 用户状态事件 ============
export const userStatusEventName = {
    LOGIN: 'user-login',
    LOGOUT: 'user-logout',
    VIP_CHANGE: 'vip-change',
    PERMISSION_CHANGE: 'permission-change',
} as const;

export const userStatusEvent = mitt();

// ============ 编辑器外部通信事件 ============
export const editorOutsideEventName = {
    MESSAGE: 'editor-outside-message',
    NAVIGATE: 'editor-navigate',
    CLOSE: 'editor-close',
} as const;

export const editorOutsideEvent = mitt();
```

### 4.2 事件使用方式

```typescript
// ============ 发送事件 ============

// 简单事件（无数据）
lifecycleEvent.emit(lifecycleEventName.EDITOR_READY);

// 带数据的事件
lifecycleEvent.emit(lifecycleEventName.TEMPLATE_LOADED, {
    template: loadedTemplate,
    isNew: false
});

// 错误事件
lifecycleEvent.emit(lifecycleEventName.SAVE_ERROR, {
    error: new Error('保存失败'),
    templateId: '123'
});


// ============ 订阅事件 ============

// 基本订阅
lifecycleEvent.on(lifecycleEventName.EDITOR_READY, () => {
    console.log('编辑器就绪');
});

// 带数据的订阅
lifecycleEvent.on(lifecycleEventName.TEMPLATE_LOADED, (data) => {
    // ⚠️ data 是 any 类型，没有类型提示
    console.log('模板加载完成:', data.template);
});

// 一次性订阅
lifecycleEvent.once(lifecycleEventName.FONT_LOADED, () => {
    console.log('字体首次加载完成');
});


// ============ 取消订阅 ============

// 需要保存 handler 引用
const handler = () => {
    console.log('模板加载');
};

lifecycleEvent.on(lifecycleEventName.TEMPLATE_LOADED, handler);

// 取消订阅
lifecycleEvent.off(lifecycleEventName.TEMPLATE_LOADED, handler);

// 取消所有订阅
lifecycleEvent.off(lifecycleEventName.TEMPLATE_LOADED);
```

### 4.3 在 Vue 组件中使用事件

```typescript
// components/header/save-button.vue
<script setup>
import { onMounted, onUnmounted, ref } from 'vue';
import { lifecycleEvent, lifecycleEventName } from '@design/services';

const isSaving = ref(false);
const lastSaveTime = ref<Date | null>(null);

// ⚠️ 需要保存 handler 引用，用于取消订阅
const handleSaveStart = () => {
    isSaving.value = true;
};

const handleSaveSuccess = () => {
    isSaving.value = false;
    lastSaveTime.value = new Date();
};

const handleSaveError = (data: any) => {
    isSaving.value = false;
    // ⚠️ data 是 any 类型
    console.error('保存失败:', data.error);
};

onMounted(() => {
    // 订阅事件
    lifecycleEvent.on(lifecycleEventName.SAVE_START, handleSaveStart);
    lifecycleEvent.on(lifecycleEventName.SAVE_SUCCESS, handleSaveSuccess);
    lifecycleEvent.on(lifecycleEventName.SAVE_ERROR, handleSaveError);
});

onUnmounted(() => {
    // ⚠️ 必须手动取消订阅，否则会内存泄漏
    lifecycleEvent.off(lifecycleEventName.SAVE_START, handleSaveStart);
    lifecycleEvent.off(lifecycleEventName.SAVE_SUCCESS, handleSaveSuccess);
    lifecycleEvent.off(lifecycleEventName.SAVE_ERROR, handleSaveError);
});
</script>
```

### 4.4 事件系统的问题

```
┌─────────────────────────────────────────────────────────────────────┐
│                      事件系统问题分析                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  问题1：类型不安全                                                    │
│  ────────────────                                                    │
│                                                                       │
│  // 事件名是字符串，拼写错误不会报错                                  │
│  lifecycleEvent.emit('editor-ready');    // ✓ 正确                   │
│  lifecycleEvent.emit('editor-raedy');    // ✗ 拼错了，编译不报错     │
│  lifecycleEvent.emit('editorReady');     // ✗ 大小写错误，编译不报错 │
│                                                                       │
│  // 事件数据是 any 类型                                              │
│  lifecycleEvent.on('template-loaded', (data) => {                    │
│      data.template.id;        // 可能 undefined                      │
│      data.tempalte;           // 拼错了，编译不报错                  │
│      data.nonExistent;        // 不存在的属性，编译不报错            │
│  });                                                                  │
│                                                                       │
│  ─────────────────────────────────────────────────────────────────   │
│                                                                       │
│  问题2：emit 和 on 参数不匹配                                        │
│  ──────────────────────────                                          │
│                                                                       │
│  // 发送时传 userId                                                  │
│  lifecycleEvent.emit('user-login', { userId: '123' });               │
│                                                                       │
│  // 订阅时期望 user                                                  │
│  lifecycleEvent.on('user-login', (data: { user: any }) => {          │
│      console.log(data.user);  // undefined！                         │
│      console.log(data.userId); // 这才是对的，但类型定义错了         │
│  });                                                                  │
│                                                                       │
│  // 编译完全正常，运行时才发现问题                                   │
│                                                                       │
│  ─────────────────────────────────────────────────────────────────   │
│                                                                       │
│  问题3：手动清理订阅                                                  │
│  ────────────────                                                    │
│                                                                       │
│  // 必须保存 handler 引用                                            │
│  const handler = () => { ... };                                      │
│  lifecycleEvent.on('xxx', handler);                                  │
│                                                                       │
│  // 必须在 onUnmounted 中手动清理                                    │
│  onUnmounted(() => {                                                 │
│      lifecycleEvent.off('xxx', handler);  // 容易忘记！             │
│  });                                                                  │
│                                                                       │
│  // 如果忘记清理：                                                   │
│  // - 组件销毁后 handler 仍然存在                                    │
│  // - 事件触发时 handler 仍会执行                                    │
│  // - 可能访问已销毁的响应式数据 → 报错                              │
│  // - 内存泄漏                                                       │
│                                                                       │
│  ─────────────────────────────────────────────────────────────────   │
│                                                                       │
│  问题4：事件分散难以管理                                              │
│  ────────────────────                                                │
│                                                                       │
│  // 多个事件发射器                                                   │
│  lifecycleEvent.emit(...)                                            │
│  skeletonEvent.emit(...)                                             │
│  userStatusEvent.emit(...)                                           │
│  editorOutsideEvent.emit(...)                                        │
│                                                                       │
│  // 问题：                                                           │
│  // - 不知道应该用哪个事件发射器                                     │
│  // - 事件名可能重复                                                 │
│  // - 难以全局查看所有事件                                           │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 五、初始化流程详解

### 5.1 完整初始化时序

```
┌─────────────────────────────────────────────────────────────────────┐
│                       完整初始化时序图                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  浏览器                                                               │
│     │                                                                 │
│     │  加载 main.ts                                                   │
│     ▼                                                                 │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  initDesign('#app', config)                                  │    │
│  │                                                               │    │
│  │  ┌─────────────────────────────────────────────────────┐    │    │
│  │  │  同步初始化阶段                                       │    │    │
│  │  │                                                       │    │    │
│  │  │  1. initEnv()                    ~1ms                │    │    │
│  │  │  2. initAPI()                    ~2ms                │    │    │
│  │  │  3. initPermission()             ~1ms                │    │    │
│  │  │  4. editorConfigService.set()    ~1ms                │    │    │
│  │  │  5. initResourceManage()         ~3ms                │    │    │
│  │  └─────────────────────────────────────────────────────┘    │    │
│  │                       │                                      │    │
│  │                       ▼                                      │    │
│  │  ┌─────────────────────────────────────────────────────┐    │    │
│  │  │  Vue 应用创建                                        │    │    │
│  │  │                                                       │    │    │
│  │  │  6. createApp()                  ~5ms                │    │    │
│  │  │  7. app.use(plugins)             ~3ms                │    │    │
│  │  │  8. initLog()                    ~10ms               │    │    │
│  │  │  9. app.mount()                  ~50ms               │    │    │
│  │  └─────────────────────────────────────────────────────┘    │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                       │                                              │
│                       ▼                                              │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  Vue 组件 setup()                                            │    │
│  │                                                               │    │
│  │  const { initEditor, initDesign } = useInitDesignView();    │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                       │                                              │
│                       ▼                                              │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  onMounted() - 异步初始化阶段                                │    │
│  │                                                               │    │
│  │  ┌─────────────────────────────────────────────────────┐    │    │
│  │  │  10. 创建 VPEditor 实例           ~100ms             │    │    │
│  │  │  11. initEditor(editor)           ~10ms              │    │    │
│  │  │      └─ editorStore.setEditor()                      │    │    │
│  │  │      └─ emit('editor-init')                          │    │    │
│  │  └─────────────────────────────────────────────────────┘    │    │
│  │                       │                                      │    │
│  │                       ▼                                      │    │
│  │  ┌─────────────────────────────────────────────────────┐    │    │
│  │  │  12. fetchTemplate()              ~200ms (网络)      │    │    │
│  │  └─────────────────────────────────────────────────────┘    │    │
│  │                       │                                      │    │
│  │                       ▼                                      │    │
│  │  ┌─────────────────────────────────────────────────────┐    │    │
│  │  │  13. initDesign(template)                            │    │    │
│  │  │                                                       │    │    │
│  │  │  ┌─────────────────────────────────────────────┐    │    │    │
│  │  │  │  并行：                                       │    │    │    │
│  │  │  │  • enterpriseService.init()    ~50ms         │    │    │    │
│  │  │  │  • userService.init()          ~100ms        │    │    │    │
│  │  │  └─────────────────────────────────────────────┘    │    │    │
│  │  │                   │                                  │    │    │
│  │  │                   ▼                                  │    │    │
│  │  │  ┌─────────────────────────────────────────────┐    │    │    │
│  │  │  │  串行（依赖 user）：                          │    │    │    │
│  │  │  │  • vipService.init()           ~50ms         │    │    │    │
│  │  │  │  • enterpriseService.initSecondary() ~30ms  │    │    │    │
│  │  │  │  • permissionController.init() ~10ms         │    │    │    │
│  │  │  └─────────────────────────────────────────────┘    │    │    │
│  │  │                   │                                  │    │    │
│  │  │                   ▼                                  │    │    │
│  │  │  • templateStore.setTemplate()                       │    │    │
│  │  │  • emit('template-loaded')                           │    │    │
│  │  └─────────────────────────────────────────────────────┘    │    │
│  │                       │                                      │    │
│  │                       ▼                                      │    │
│  │  ┌─────────────────────────────────────────────────────┐    │    │
│  │  │  14. initFontsAndWatermark()      ~300ms            │    │    │
│  │  │      └─ fontsService.loadFonts()                     │    │    │
│  │  │      └─ emit('font-loaded')                          │    │    │
│  │  └─────────────────────────────────────────────────────┘    │    │
│  │                       │                                      │    │
│  │                       ▼                                      │    │
│  │  ┌─────────────────────────────────────────────────────┐    │    │
│  │  │  15. emit('editor-ready')                            │    │    │
│  │  └─────────────────────────────────────────────────────┘    │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                       │                                              │
│                       ▼                                              │
│                    应用就绪                                          │
│                                                                       │
│  总耗时：~900ms（其中网络请求 ~300ms）                               │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

### 5.2 手动编排的问题

```typescript
// useInitDesignView 中的初始化代码

async function initDesign(template: Template) {
    // ============ 问题1：顺序靠人工保证 ============
    
    // 正确顺序：
    await Promise.all([
        enterpriseService.init(),  // 可以并行
        userService.init()         // 可以并行
    ]);
    
    await vipService.init();       // 必须在 user 之后
    await enterpriseService.initSecondary();  // 必须在 enterprise + user 之后
    
    // 如果有人不小心改成：
    // await vipService.init();     // ❌ user 还没初始化！
    // await userService.init();
    
    // ============ 问题2：依赖关系不透明 ============
    
    // 从代码中无法直观看出依赖关系
    // 需要阅读每个 init() 的内部实现才知道它依赖什么
    
    // ============ 问题3：错误处理不统一 ============
    
    try {
        await vipService.init();
    } catch (error) {
        // VIP 初始化失败怎么办？
        // - 继续执行？用户可能无法使用 VIP 功能
        // - 终止初始化？整个应用无法使用
        // - 降级处理？逻辑在哪里？
        console.error('VIP 初始化失败', error);
        // 当前做法：打个日志继续执行
    }
    
    // ============ 问题4：新增服务困难 ============
    
    // 假设要新增一个 BrandService
    // 1. 要知道它依赖什么
    // 2. 要找到正确的插入位置
    // 3. 要考虑失败处理
    // 4. 要更新文档
    
    // await brandService.init();  // 放在哪？
}
```

### 5.3 生命周期管理的困境

```
┌─────────────────────────────────────────────────────────────────────┐
│                     生命周期管理困境                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  困境1：初始化时机不统一                                              │
│  ──────────────────────                                              │
│                                                                       │
│  // 有些服务在 initDesign 时初始化                                   │
│  async function initDesign() {                                       │
│      await userService.init();                                       │
│      await vipService.init();                                        │
│  }                                                                   │
│                                                                       │
│  // 有些服务在组件 onMounted 时初始化                                │
│  onMounted(() => {                                                   │
│      guideService.init();    // 引导服务在组件挂载后                 │
│      trackerService.init();  // 埋点服务在组件挂载后                 │
│  });                                                                  │
│                                                                       │
│  // 有些服务懒加载                                                   │
│  async function openCollab() {                                       │
│      await collabService.init();  // 协同服务按需初始化              │
│  }                                                                   │
│                                                                       │
│  // 问题：没有统一的初始化时机管理                                   │
│                                                                       │
│  ─────────────────────────────────────────────────────────────────   │
│                                                                       │
│  困境2：销毁逻辑分散                                                  │
│  ────────────────                                                    │
│                                                                       │
│  // 服务的销毁逻辑分散在各个组件中                                   │
│                                                                       │
│  // 组件A                                                            │
│  onUnmounted(() => {                                                 │
│      lifecycleEvent.off('xxx', handlerA);                            │
│  });                                                                  │
│                                                                       │
│  // 组件B                                                            │
│  onUnmounted(() => {                                                 │
│      collabService.disconnect();                                     │
│      userStatusEvent.off('logout', handlerB);                        │
│  });                                                                  │
│                                                                       │
│  // 组件C                                                            │
│  onUnmounted(() => {                                                 │
│      // 忘记清理了！→ 内存泄漏                                      │
│  });                                                                  │
│                                                                       │
│  ─────────────────────────────────────────────────────────────────   │
│                                                                       │
│  困境3：重复初始化防护分散                                            │
│  ────────────────────────                                            │
│                                                                       │
│  // 每个服务都要自己实现幂等检查                                     │
│                                                                       │
│  // userService                                                      │
│  async init() {                                                      │
│      if (this.$inited) return;  // 重复代码                         │
│      // ...                                                          │
│      this.$inited = true;                                            │
│  }                                                                   │
│                                                                       │
│  // vipService                                                       │
│  async init() {                                                      │
│      if (this.$inited) return;  // 重复代码                         │
│      // ...                                                          │
│      this.$inited = true;                                            │
│  }                                                                   │
│                                                                       │
│  // editorService                                                    │
│  async init() {                                                      │
│      if (this.$inited) return;  // 重复代码                         │
│      // ...                                                          │
│      this.$inited = true;                                            │
│  }                                                                   │
│                                                                       │
│  // 180+ 服务，每个都要写这段代码                                    │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 六、业务UI层详解

### 6.1 组件组织结构

```
@design/business-ui/src/
│
├── components/                      # 业务组件（400+ 目录）
│   │
│   ├── header/                     # 顶部工具栏
│   │   ├── index.vue              # 主组件
│   │   ├── logo.vue               # Logo
│   │   ├── file-menu.vue          # 文件菜单
│   │   ├── save-button.vue        # 保存按钮
│   │   ├── export-button.vue      # 导出按钮
│   │   ├── share-button.vue       # 分享按钮
│   │   └── user-avatar.vue        # 用户头像
│   │
│   ├── aside/                      # 左侧面板
│   │   ├── index.vue              # 主组件
│   │   ├── template-panel/        # 模板面板
│   │   ├── material-panel/        # 素材面板
│   │   ├── text-panel/            # 文字面板
│   │   ├── shape-panel/           # 形状面板
│   │   └── upload-panel/          # 上传面板
│   │
│   ├── right-panel/                # 右侧属性面板
│   │   ├── index.vue              # 主组件
│   │   ├── layer-panel/           # 图层面板
│   │   ├── style-panel/           # 样式面板
│   │   ├── effect-panel/          # 效果面板
│   │   └── position-panel/        # 位置面板
│   │
│   ├── material/                   # 素材相关
│   │   ├── material-list.vue      # 素材列表
│   │   ├── material-item.vue      # 素材项
│   │   ├── material-search.vue    # 素材搜索
│   │   └── material-upload.vue    # 素材上传
│   │
│   ├── layer/                      # 图层相关
│   │   ├── layer-list.vue         # 图层列表
│   │   ├── layer-item.vue         # 图层项
│   │   ├── layer-thumbnail.vue    # 图层缩略图
│   │   └── layer-actions.vue      # 图层操作
│   │
│   └── ...                         # 更多组件
│
├── compositions/                    # 组合式函数（200+）
│   │
│   ├── use-editor-layer.ts         # 图层操作
│   ├── use-editor-selection.ts     # 选择操作
│   ├── use-editor-history.ts       # 历史记录
│   │
│   ├── use-hotkey/                 # 快捷键
│   │   ├── index.ts
│   │   ├── use-copy-paste.ts      # 复制粘贴
│   │   ├── use-undo-redo.ts       # 撤销重做
│   │   └── use-zoom.ts            # 缩放
│   │
│   ├── use-creation/               # 创建元素
│   │   ├── use-create-text.ts
│   │   ├── use-create-shape.ts
│   │   └── use-create-image.ts
│   │
│   └── ...
│
└── hooks/                          # 通用 Hooks
    │
    ├── use-colors/                 # 颜色相关
    ├── use-effects/                # 效果相关
    ├── use-fonts/                  # 字体相关
    └── use-upload/                 # 上传相关
```

### 6.2 Composition 复用模式

```typescript
// compositions/use-editor-layer.ts

import { computed, ref } from 'vue';
import { useEditorStore } from '@design/stores';
import { useVipService, lifecycleEvent } from '@design/services';

/**
 * 图层操作 Composition
 * 
 * 封装图层相关的逻辑，供多个组件复用
 */
export function useEditorLayer() {
    // ============ 获取依赖 ============
    const editorStore = useEditorStore();
    const vipService = useVipService();
    
    // ============ 响应式状态 ============
    const isMoving = ref(false);
    
    // ============ 计算属性 ============
    
    /**
     * 当前选中的图层
     */
    const selectedLayer = computed(() => {
        return editorStore.editor?.selectedElements?.[0];
    });
    
    /**
     * 所有图层列表
     */
    const layers = computed(() => {
        return editorStore.editor?.currentPage?.elements || [];
    });
    
    /**
     * 是否可以上移图层
     */
    const canMoveUp = computed(() => {
        if (!selectedLayer.value) return false;
        const index = layers.value.indexOf(selectedLayer.value);
        return index < layers.value.length - 1;
    });
    
    /**
     * 是否可以下移图层
     */
    const canMoveDown = computed(() => {
        if (!selectedLayer.value) return false;
        const index = layers.value.indexOf(selectedLayer.value);
        return index > 0;
    });
    
    // ============ 方法 ============
    
    /**
     * 上移图层
     */
    function moveLayerUp() {
        if (!canMoveUp.value) return;
        
        const editor = editorStore.editor;
        if (!editor) return;
        
        isMoving.value = true;
        
        try {
            editor.moveElementUp(selectedLayer.value);
            
            // 发送事件
            lifecycleEvent.emit('layer-moved', {
                layer: selectedLayer.value,
                direction: 'up'
            });
        } finally {
            isMoving.value = false;
        }
    }
    
    /**
     * 下移图层
     */
    function moveLayerDown() {
        if (!canMoveDown.value) return;
        
        const editor = editorStore.editor;
        if (!editor) return;
        
        isMoving.value = true;
        
        try {
            editor.moveElementDown(selectedLayer.value);
            
            lifecycleEvent.emit('layer-moved', {
                layer: selectedLayer.value,
                direction: 'down'
            });
        } finally {
            isMoving.value = false;
        }
    }
    
    /**
     * 删除图层（需要 VIP 权限检查）
     */
    async function deleteLayer() {
        if (!selectedLayer.value) return;
        
        // VIP 功能检查示例
        if (selectedLayer.value.type === 'watermark') {
            const canRemove = vipService.checkFeatureAccess('remove-watermark');
            if (!canRemove) {
                // 引导开通 VIP
                vipService.openVipPayment({
                    source: 'remove-watermark'
                });
                return;
            }
        }
        
        const editor = editorStore.editor;
        editor?.removeElement(selectedLayer.value);
        
        lifecycleEvent.emit('layer-deleted', {
            layer: selectedLayer.value
        });
    }
    
    return {
        // 状态
        selectedLayer,
        layers,
        isMoving,
        canMoveUp,
        canMoveDown,
        
        // 方法
        moveLayerUp,
        moveLayerDown,
        deleteLayer
    };
}
```

### 6.3 组件与服务协作

```typescript
// components/header/save-button.vue

<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted } from 'vue';
import {
    useSaveTemplateService,
    useVipService,
    lifecycleEvent,
    lifecycleEventName
} from '@design/services';
import { useEditorStore } from '@design/stores';

// ============ 获取服务 ============
const saveService = useSaveTemplateService();
const vipService = useVipService();
const editorStore = useEditorStore();

// ============ 本地状态 ============
const isSaving = ref(false);
const lastSaveTime = ref<Date | null>(null);
const saveError = ref<Error | null>(null);

// ============ 计算属性 ============
const isDirty = computed(() => editorStore.isDirty);
const canSave = computed(() => !isSaving.value && isDirty.value);

// ============ 事件处理器 ============
const handleSaveStart = () => {
    isSaving.value = true;
    saveError.value = null;
};

const handleSaveSuccess = () => {
    isSaving.value = false;
    lastSaveTime.value = new Date();
};

const handleSaveError = (data: { error: Error }) => {
    isSaving.value = false;
    saveError.value = data.error;
};

// ============ 生命周期 ============
onMounted(() => {
    // 订阅事件
    lifecycleEvent.on(lifecycleEventName.SAVE_START, handleSaveStart);
    lifecycleEvent.on(lifecycleEventName.SAVE_SUCCESS, handleSaveSuccess);
    lifecycleEvent.on(lifecycleEventName.SAVE_ERROR, handleSaveError);
});

onUnmounted(() => {
    // ⚠️ 必须手动取消订阅
    lifecycleEvent.off(lifecycleEventName.SAVE_START, handleSaveStart);
    lifecycleEvent.off(lifecycleEventName.SAVE_SUCCESS, handleSaveSuccess);
    lifecycleEvent.off(lifecycleEventName.SAVE_ERROR, handleSaveError);
});

// ============ 方法 ============
async function handleSave() {
    if (!canSave.value) return;
    
    try {
        await saveService.save();
    } catch (error) {
        console.error('保存失败:', error);
    }
}
</script>

<template>
    <button
        :disabled="!canSave"
        :loading="isSaving"
        @click="handleSave"
    >
        <span v-if="isSaving">保存中...</span>
        <span v-else-if="saveError">保存失败</span>
        <span v-else-if="lastSaveTime">
            已保存 {{ formatTime(lastSaveTime) }}
        </span>
        <span v-else>保存</span>
    </button>
</template>
```

---

## 七、存在的问题汇总

### 7.1 依赖管理问题

```
┌─────────────────────────────────────────────────────────────────────┐
│                     问题1：隐式依赖                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  // 服务 A 的定义                                                    │
│  const useServiceA = defineStore('A', {                              │
│      actions: {                                                       │
│          foo() {                                                      │
│              const B = useServiceB();  // 隐式依赖                   │
│              const C = useServiceC();  // 隐式依赖                   │
│              const D = useServiceD();  // 隐式依赖                   │
│              // ...                                                   │
│          }                                                            │
│      }                                                                │
│  });                                                                  │
│                                                                       │
│  问题：                                                               │
│  • 依赖关系只有在运行时才能确定                                      │
│  • 无法静态分析依赖图                                                │
│  • 循环依赖难以检测                                                  │
│  • 新人接手需要阅读全部代码才能理解依赖                              │
│                                                                       │
│  影响：                                                               │
│  • 重构困难：不知道改一个服务会影响哪些地方                          │
│  • 测试困难：不知道需要 mock 哪些依赖                                │
│  • 维护困难：依赖关系不透明                                          │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

### 7.2 初始化顺序问题

```
┌─────────────────────────────────────────────────────────────────────┐
│                     问题2：手动编排                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  // 正确顺序                                                         │
│  await userStore.init();        // 1 - 最先                         │
│  await vipService.init();       // 2 - 依赖 user                    │
│  await editorStore.init();      // 3 - 依赖 vip                     │
│                                                                       │
│  // 错误顺序（运行时才发现）                                         │
│  await editorStore.init();      // ❌ vip 未初始化                   │
│  await vipService.init();       // ❌ user 未初始化                  │
│  await userStore.init();                                             │
│                                                                       │
│  问题：                                                               │
│  • 顺序靠人工记忆和文档约定                                          │
│  • 新人接手容易出错                                                  │
│  • 增删服务需要手动调整顺序                                          │
│  • 没有自动化的顺序检查                                              │
│                                                                       │
│  真实案例：                                                           │
│  某次重构中，开发者将 vipService.init() 移到了 userService.init()   │
│  之前，导致线上 VIP 判断全部失效。问题持续了 2 小时才被发现。        │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

### 7.3 扩展性问题

```
┌─────────────────────────────────────────────────────────────────────┐
│                     问题3：定制困难                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  场景：InsMind 需要替换 VIP 服务的实现                               │
│                                                                       │
│  // 方式1：修改核心代码（if-else）                                   │
│  // @design/services/src/vip/store.ts                                │
│  const useVipService = defineStore('vip', {                          │
│      actions: {                                                       │
│          async checkVip() {                                          │
│              if (isInsMind) {                                        │
│                  // InsMind 特殊逻辑（50行）                         │
│              } else if (isGaoding) {                                 │
│                  // 稿定逻辑（50行）                                 │
│              } else if (isGaodingArt) {                              │
│                  // 稿定Art 逻辑（50行）                             │
│              }                                                        │
│              // 随着产品增加，代码越来越长...                        │
│          }                                                            │
│      }                                                                │
│  });                                                                  │
│                                                                       │
│  问题：                                                               │
│  • 条件分支污染核心代码                                              │
│  • 每个定制点都需要 if-else                                          │
│  • 无法做到真正的「可插拔」                                          │
│  • 代码耦合度高，维护困难                                            │
│                                                                       │
│  ─────────────────────────────────────────────────────────────────   │
│                                                                       │
│  // 方式2：Fork 代码（更糟糕）                                       │
│  // 每个产品维护自己的 vip/store.ts                                  │
│                                                                       │
│  问题：                                                               │
│  • 公共逻辑修改需要同步多处                                          │
│  • 版本分裂严重                                                      │
│  • Bug 修复需要多处更新                                              │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

### 7.4 事件系统问题

```
┌─────────────────────────────────────────────────────────────────────┐
│                     问题4：类型不安全                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  // 事件名是字符串，没有类型提示                                     │
│  lifecycleEvent.emit('editor-ready');                                │
│  lifecycleEvent.emit('editor-raedy');  // 拼写错误，编译不报错       │
│                                                                       │
│  // 事件数据没有类型约束                                             │
│  lifecycleEvent.on('template-loaded', (data) => {                    │
│      // data 是 any 类型，无法推断                                   │
│      data.template.xxx;  // 运行时才知道有没有这个属性               │
│  });                                                                  │
│                                                                       │
│  // emit 和 on 的参数类型不匹配                                      │
│  lifecycleEvent.emit('user-login', { userId: '123' });               │
│  lifecycleEvent.on('user-login', (data: { user: any }) => {          │
│      // 类型定义和实际数据不匹配，编译不报错                         │
│  });                                                                  │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

### 7.5 内存泄漏问题

```
┌─────────────────────────────────────────────────────────────────────┐
│                     问题5：手动清理                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  // 事件订阅需要手动清理                                             │
│  onMounted(() => {                                                   │
│      lifecycleEvent.on('xxx', handler1);                             │
│      lifecycleEvent.on('yyy', handler2);                             │
│      lifecycleEvent.on('zzz', handler3);                             │
│  });                                                                  │
│                                                                       │
│  onUnmounted(() => {                                                 │
│      lifecycleEvent.off('xxx', handler1);                            │
│      lifecycleEvent.off('yyy', handler2);                            │
│      // handler3 忘了清理！→ 内存泄漏                               │
│  });                                                                  │
│                                                                       │
│  后果：                                                               │
│  • 组件销毁后，handler 仍然存在于事件监听器中                        │
│  • 事件触发时，handler 仍会执行                                      │
│  • 可能访问已销毁的响应式数据，导致报错                              │
│  • 长时间运行后，内存占用越来越高                                    │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

### 7.6 问题影响汇总

| 问题 | 表现 | 风险等级 | 影响范围 |
|-----|------|---------|---------|
| 隐式依赖 | import 分散，依赖关系不透明 | ⚠️ 中 | 全局 |
| 手动编排 | 初始化顺序靠约定 | 🔴 高 | 启动流程 |
| 定制困难 | 改核心代码，if-else 泛滥 | 🔴 高 | 多产品线 |
| 类型不安全 | 字符串事件名，any 类型数据 | ⚠️ 中 | 事件系统 |
| 内存泄漏 | 事件订阅需手动清理 | ⚠️ 中 | 长时间运行 |

---

## 八、改进方向预览

基于上述问题，第二代架构（Kernel-X）将引入：

```
┌─────────────────────────────────────────────────────────────────────┐
│                       Kernel-X 改进方向                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  1. Token 系统：类型安全的身份标识                                   │
│     ─────────────────────────────                                    │
│     • 唯一标识 + 类型推断 + 依赖声明                                 │
│     • 编译期检查，运行时安全                                         │
│                                                                       │
│  2. 显式依赖声明：Manifest 元数据                                    │
│     ─────────────────────────────                                    │
│     • dependencies: [Token1, Token2]                                 │
│     • 可静态分析，自动检测循环依赖                                   │
│                                                                       │
│  3. 自动初始化编排：依赖图 + 拓扑排序                                │
│     ─────────────────────────────────                                │
│     • 根据依赖关系自动确定顺序                                       │
│     • 支持并行初始化                                                 │
│                                                                       │
│  4. 三层架构：Services → Components → Extensions                    │
│     ─────────────────────────────────────────                        │
│     • 层级隔离，单向依赖                                             │
│     • 编译期检查访问权限                                             │
│                                                                       │
│  5. 类型安全事件：EventToken<T>                                      │
│     ────────────────────────────                                     │
│     • 泛型约束事件数据类型                                           │
│     • 编译期检查 emit/on 参数匹配                                    │
│                                                                       │
│  6. 自动资源清理：追踪 + 自动 off                                    │
│     ─────────────────────────────                                    │
│     • 扩展卸载时自动清理订阅                                         │
│     • 无需手动 off                                                   │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 九、小结

本章详细介绍了第一代基座方案的实现和存在的问题：

**架构组成**：
- Foundation 层：应用入口，手动编排初始化
- Services 层：180+ Pinia Store 服务
- Business-UI 层：950+ Vue 组件
- Stores 层：底层状态管理

**实现方式**：
- Pinia `defineStore` 定义服务
- mitt 实现事件系统
- 直接 import 建立依赖
- 手动编排初始化顺序

**核心问题**：
- 依赖关系隐式，难以追踪
- 初始化顺序靠人工约定
- 定制需要修改核心代码
- 事件系统类型不安全
- 资源清理需要手动管理

**下一章预告**：

Kernel-X 架构将彻底解决这些问题：
- Token 系统：类型安全的身份标识
- 显式依赖：Manifest + dependencies
- 自动编排：依赖图 + 拓扑排序
- 三层架构：层级隔离 + 单向依赖
- 类型安全事件：EventToken<T>

---

> 📖 **系列文档导航**
> 
> - [x] 第一篇：业务现状与基座化需求
> - [x] **第二篇：第一代基座方案实现**（本文）
> - [ ] 第三篇：Kernel-X 架构详解
> - [ ] 第四篇：架构演进总结
