# ä¸­æ–­ä¸æ¢å¤æœºåˆ¶æ·±å…¥åŸç†

> **ç†è§£çŠ¶æ€ç®¡ç†çš„æ ¸å¿ƒï¼šå¦‚ä½•æš‚åœå’Œç»§ç»­**

---

## ä¸€ã€ä¸ºä»€ä¹ˆéœ€è¦ä¸­æ–­ä¸æ¢å¤ï¼Ÿ

### 1.1 çœŸå®åœºæ™¯

**åœºæ™¯ 1ï¼šç¨¿è±†ä¸è¶³**

```
ç”¨æˆ·ï¼šç”Ÿæˆä¸€å¼ å›¾ç‰‡
  â†“
Agentï¼šæ£€æŸ¥ç¨¿è±†ä½™é¢ â†’ ä¸è¶³
  â†“
[ä¸­æ–­] æç¤ºç”¨æˆ·å……å€¼
  â†“
ç”¨æˆ·å……å€¼å®Œæˆ
  â†“
ç”¨æˆ·ï¼šç»§ç»­
  â†“
[æ¢å¤] ä»ä¸­æ–­ç‚¹ç»§ç»­ç”Ÿæˆå›¾ç‰‡
```

**åœºæ™¯ 2ï¼šToken è¿‡æœŸ**

```
ç”¨æˆ·ï¼šå¸®æˆ‘è®¾è®¡æµ·æŠ¥
  â†“
Agentï¼šè°ƒç”¨å·¥å…· â†’ Token è¿‡æœŸ
  â†“
[ä¸­æ–­] é™é»˜åˆ·æ–° Token
  â†“
[è‡ªåŠ¨æ¢å¤] ç»§ç»­æ‰§è¡Œ
```

**åœºæ™¯ 3ï¼šå†…å®¹é£é™©**

```
ç”¨æˆ·ï¼šç”Ÿæˆæ•æ„Ÿå†…å®¹
  â†“
Agentï¼šç”Ÿæˆä¸­... â†’ Guardrails æ£€æµ‹åˆ°é£é™©
  â†“
[ä¸­æ–­å¹¶æ’¤å›] åœæ­¢ç”Ÿæˆï¼Œæ’¤å›å·²è¾“å‡ºå†…å®¹
```

### 1.2 æ²¡æœ‰ä¸­æ–­æ¢å¤çš„é—®é¢˜

**é—®é¢˜ 1ï¼šç”¨æˆ·ä½“éªŒå·®**

```
ä¼ ç»Ÿæ–¹å¼ï¼š
ç”¨æˆ·ï¼šç”Ÿæˆå›¾ç‰‡
Agentï¼šç¨¿è±†ä¸è¶³
ç”¨æˆ·ï¼šå……å€¼
ç”¨æˆ·ï¼šå†æ¬¡è¾“å…¥"ç”Ÿæˆå›¾ç‰‡"  â† é‡å¤è¾“å…¥
```

**é—®é¢˜ 2ï¼šçŠ¶æ€ä¸¢å¤±**

```
ç”¨æˆ·ï¼šå¸®æˆ‘è®¾è®¡ä¸€å¥—å“ç‰Œè§†è§‰
Agentï¼š
  1. ç”Ÿæˆ Logo âœ…
  2. ç”Ÿæˆé…è‰²æ–¹æ¡ˆ âœ…
  3. ç”Ÿæˆæµ·æŠ¥ â†’ ç¨¿è±†ä¸è¶³ âŒ

ä¼ ç»Ÿæ–¹å¼ï¼š
ç”¨æˆ·å……å€¼åéœ€è¦é‡æ–°å¼€å§‹ï¼Œå‰é¢çš„å·¥ä½œä¸¢å¤± âŒ
```

**é—®é¢˜ 3ï¼šæˆæœ¬æµªè´¹**

å·²ç»æ¶ˆè€—çš„ LLM Token å’Œç¨¿è±†æ— æ³•å¤ç”¨ã€‚

---

## äºŒã€ä¸­æ–­ä¸æ¢å¤çš„æœ¬è´¨

> ğŸ’¡ **æ ¸å¿ƒæ´å¯Ÿ**  
> ä¸­æ–­ä¸æ¢å¤çš„æœ¬è´¨æ˜¯ï¼š**åœ¨ä»»æ„æ—¶åˆ»ä¿å­˜å®Œæ•´çŠ¶æ€ï¼Œå¹¶èƒ½ä»è¯¥çŠ¶æ€ç»§ç»­æ‰§è¡Œ**ã€‚

### 2.1 çŠ¶æ€æœºè§†è§’

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  State 0    â”‚  åˆå§‹çŠ¶æ€
â”‚  (ç”¨æˆ·è¾“å…¥)  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  State 1    â”‚  LLM å¤„ç†
â”‚  (è°ƒç”¨ LLM)  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  State 2    â”‚  å·¥å…·è°ƒç”¨
â”‚ (æ‰§è¡Œå·¥å…·)   â”‚  â† [ä¸­æ–­ç‚¹]
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â†“
    [æ¢å¤]
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  State 3    â”‚  ç»§ç»­æ‰§è¡Œ
â”‚ (å·¥å…·ç»“æœ)   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  State 4    â”‚  æœ€ç»ˆç»“æœ
â”‚  (å®Œæˆ)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å…³é”®ç‚¹**ï¼š
1. æ¯ä¸ªçŠ¶æ€éƒ½æ˜¯**å®Œæ•´çš„**ï¼ŒåŒ…å«æ‰€æœ‰ä¸Šä¸‹æ–‡
2. ä»ä»»æ„çŠ¶æ€éƒ½å¯ä»¥**ç»§ç»­æ‰§è¡Œ**
3. çŠ¶æ€ä¹‹é—´çš„è½¬ç§»æ˜¯**ç¡®å®šçš„**

### 2.2 Checkpoint çš„ä½œç”¨

**Checkpoint = çŠ¶æ€å¿«ç…§ + æ‰§è¡Œä½ç½®**

```python
@dataclass
class Checkpoint:
    # æ‰§è¡Œä½ç½®
    current_node: str  # å½“å‰åœ¨å“ªä¸ªèŠ‚ç‚¹
    next_node: Optional[str]  # ä¸‹ä¸€ä¸ªè¦æ‰§è¡Œçš„èŠ‚ç‚¹
    
    # å®Œæ•´çŠ¶æ€
    state: AgentState  # åŒ…å«æ‰€æœ‰æ¶ˆæ¯ã€è®¡æ•°å™¨ç­‰
    
    # å…ƒæ•°æ®
    checkpoint_id: str
    thread_id: str
    created_at: datetime
    
    # ä¸­æ–­ä¿¡æ¯ï¼ˆå¦‚æœæœ‰ï¼‰
    interrupt_info: Optional[InterruptInfo]
```

---

## ä¸‰ã€ä¸¤ç§ä¸­æ–­æ–¹å¼è¯¦è§£

### 3.1 èŠ‚ç‚¹çº§ä¸­æ–­ (NodeInterrupt)

**åŸç†**ï¼šåœ¨èŠ‚ç‚¹æ‰§è¡Œè¿‡ç¨‹ä¸­æŠ›å‡ºå¼‚å¸¸

```python
from langgraph.errors import NodeInterrupt

async def tools_node(state: AgentState) -> dict:
    """å·¥å…·èŠ‚ç‚¹"""
    
    tool_calls = extract_tool_calls(state["messages"][-1])
    
    for tool_call in tool_calls:
        # æ‰§è¡Œå·¥å…·
        result = await execute_tool(tool_call, state)
        
        # æ£€æŸ¥ç¨¿è±†
        if result.get("error") == "insufficient_points":
            # æŠ›å‡ºä¸­æ–­å¼‚å¸¸
            raise NodeInterrupt(
                code=-1002,
                message="ç¨¿è±†ä¸è¶³",
                extra={
                    "required_points": result["required_points"],
                    "current_balance": result["current_balance"],
                    "tool_call_id": tool_call["id"]
                }
            )
    
    return {"messages": results}
```

**LangGraph çš„å¤„ç†æµç¨‹**ï¼š

```mermaid
sequenceDiagram
    participant LG as LangGraph
    participant Node as tools_node
    participant CP as Checkpointer

    LG->>Node: execute()
    Node->>Node: æ£€æµ‹ç¨¿è±†ä¸è¶³
    Node->>LG: raise NodeInterrupt(-1002)
    
    Note over LG: æ•è·ä¸­æ–­å¼‚å¸¸
    
    LG->>LG: åœæ­¢æ‰§è¡Œ
    LG->>CP: save checkpoint (åŒ…å«ä¸­æ–­ä¿¡æ¯)
    CP-->>LG: checkpoint_id
    LG->>LG: æ„é€ çŠ¶æ€æ¶ˆæ¯
    LG-->>å¤–éƒ¨: SSE: status message (-1002)
    
    Note over LG: ç­‰å¾…æ¢å¤...
```

**Checkpoint å†…å®¹**ï¼š

```python
{
    "checkpoint_id": "ckpt_123",
    "thread_id": "thread_abc",
    "current_node": "tools",  # ä¸­æ–­æ—¶æ‰€åœ¨èŠ‚ç‚¹
    "state": {
        "messages": [
            {"role": "user", "content": "ç”Ÿæˆå›¾ç‰‡"},
            {"role": "assistant", "content": "<tool_call>...</tool_call>"}
        ],
        "llm_calls": 1,
        "tool_calls": 0
    },
    "interrupt_info": {
        "code": -1002,
        "message": "ç¨¿è±†ä¸è¶³",
        "extra": {
            "required_points": 10,
            "current_balance": 0,
            "tool_call_id": "call_001"
        }
    }
}
```

**æ¢å¤æµç¨‹**ï¼š

```python
async def resume_from_checkpoint(thread_id: str):
    """ä» Checkpoint æ¢å¤"""
    
    # 1. åŠ è½½ Checkpoint
    checkpoint = checkpointer.get(thread_id)
    
    # 2. æ¢å¤çŠ¶æ€
    state = checkpoint.state
    
    # 3. æ·»åŠ æ¢å¤æ¶ˆæ¯
    state["messages"].append({
        "role": "status",
        "content": {
            "code": -2001,
            "message": "æ¢å¤æ‰§è¡Œ"
        }
    })
    
    # 4. ç»§ç»­æ‰§è¡Œï¼ˆä»ä¸­æ–­çš„èŠ‚ç‚¹é‡æ–°å¼€å§‹ï¼‰
    result = await app.ainvoke(
        state,
        config={
            "thread_id": thread_id,
            "checkpoint_id": checkpoint.checkpoint_id  # ä»æ­¤ checkpoint ç»§ç»­
        }
    )
    
    return result
```

**ä¸ºä»€ä¹ˆä»ä¸­æ–­èŠ‚ç‚¹é‡æ–°æ‰§è¡Œï¼Ÿ**

```
ä¸­æ–­å‰ï¼š
llm_node â†’ tools_node [ä¸­æ–­] â†’ (æœªæ‰§è¡Œ)

æ¢å¤åï¼š
[åŠ è½½çŠ¶æ€] â†’ tools_node [é‡æ–°æ‰§è¡Œ] â†’ llm_node â†’ END
```

è¿™æ ·å¯ä»¥ç¡®ä¿å·¥å…·è°ƒç”¨åœ¨å……å€¼åæˆåŠŸæ‰§è¡Œã€‚

### 3.2 å·¥å…·çº§ä¸­æ–­ (çŠ¶æ€æ ‡è®°)

**åŸç†**ï¼šä¸æŠ›å¼‚å¸¸ï¼Œè€Œæ˜¯åœ¨çŠ¶æ€ä¸­è®¾ç½®æ ‡è®°

```python
async def tools_node(state: AgentState) -> dict:
    """å·¥å…·èŠ‚ç‚¹"""
    
    tool_calls = extract_tool_calls(state["messages"][-1])
    results = []
    
    for tool_call in tool_calls:
        # æ‰§è¡Œå·¥å…·
        result = await execute_tool(tool_call, state)
        
        # æ£€æŸ¥ç¨¿è±†
        if result.get("error") == "insufficient_points":
            # ä¸æŠ›å¼‚å¸¸ï¼Œè®¾ç½®çŠ¶æ€æ ‡è®°
            return {
                "messages": [{
                    "role": "status",
                    "content": {
                        "code": -1002,
                        "message": "ç¨¿è±†ä¸è¶³"
                    }
                }],
                "needs_resume": True,  # æ ‡è®°éœ€è¦æ¢å¤
                "interrupted_at": "tools",
                "tool_call_id": tool_call["id"]
            }
        
        results.append(result)
    
    return {"messages": results}


def should_continue(state: AgentState) -> str:
    """è·¯ç”±å‡½æ•°"""
    
    # æ£€æŸ¥æ˜¯å¦éœ€è¦æ¢å¤
    if state.get("needs_resume"):
        return "interrupt"  # è·¯ç”±åˆ° ENDï¼Œç­‰å¾…æ¢å¤
    
    # æ­£å¸¸æµç¨‹
    last_message = state["messages"][-1]
    if has_tool_call(last_message):
        return "continue"
    
    return "end"
```

**ä¸¤ç§æ–¹å¼å¯¹æ¯”**ï¼š

| ç»´åº¦ | NodeInterrupt | çŠ¶æ€æ ‡è®° |
|------|---------------|----------|
| **å®ç°æ–¹å¼** | æŠ›å¼‚å¸¸ | è®¾ç½®æ ‡è®° |
| **LangGraphæ„ŸçŸ¥** | æ˜¯ | å¦ |
| **Checkpointä¿å­˜** | è‡ªåŠ¨ | æ‰‹åŠ¨ |
| **æ¢å¤ä½ç½®** | ä¸­æ–­èŠ‚ç‚¹ | ä»»æ„èŠ‚ç‚¹ |
| **é€‚ç”¨åœºæ™¯** | ç³»ç»Ÿçº§ä¸­æ–­ï¼ˆå¦‚èµ„æºä¸è¶³ï¼‰ | ä¸šåŠ¡çº§ä¸­æ–­ï¼ˆå¦‚å®¡æ ¸å¤±è´¥ï¼‰ |
| **å¤æ‚åº¦** | ä½ | ä¸­ |

**é€‰æ‹©å»ºè®®**ï¼š

- **NodeInterrupt**ï¼šæ¨èç”¨äºä¸å¯æ¢å¤æˆ–éœ€è¦å¤–éƒ¨æ“ä½œçš„ä¸­æ–­ï¼ˆç¨¿è±†ä¸è¶³ã€Tokenè¿‡æœŸï¼‰
- **çŠ¶æ€æ ‡è®°**ï¼šç”¨äºå¯æ¢å¤æˆ–éœ€è¦å¤æ‚æ§åˆ¶æµçš„ä¸­æ–­ï¼ˆå®¡æ ¸å¤±è´¥ã€éœ€è¦äººå·¥ä»‹å…¥ï¼‰

---

## å››ã€å®Œæ•´çš„ä¸­æ–­æ¢å¤å®ç°

### 4.1 ä¸­æ–­ä¿¡æ¯çš„è®¾è®¡

```python
@dataclass
class InterruptInfo:
    """ä¸­æ–­ä¿¡æ¯"""
    
    # çŠ¶æ€ç 
    code: int  # -1002, -1004, etc.
    
    # æè¿°ä¿¡æ¯
    message: str
    
    # ä¸­æ–­æ—¶é—´
    interrupted_at: datetime
    
    # ä¸­æ–­ä½ç½®
    node: str  # å“ªä¸ªèŠ‚ç‚¹ä¸­æ–­çš„
    
    # é¢å¤–ä¿¡æ¯
    extra: Dict[str, Any]
    
    # æ˜¯å¦å¯æ¢å¤
    recoverable: bool
```

### 4.2 å®Œæ•´çš„ Agent å®ç°

```python
from langgraph.graph import StateGraph, END
from langgraph.errors import NodeInterrupt

class AgentWithResume:
    """æ”¯æŒä¸­æ–­æ¢å¤çš„ Agent"""
    
    def __init__(self, checkpointer):
        self.checkpointer = checkpointer
        self.app = self._build_graph()
    
    def _build_graph(self):
        """æ„å»ºå›¾"""
        graph = StateGraph(AgentState)
        
        # æ·»åŠ èŠ‚ç‚¹
        graph.add_node("llm", self.llm_node)
        graph.add_node("tools", self.tools_node)
        
        # è®¾ç½®å…¥å£
        graph.set_entry_point("llm")
        
        # æ·»åŠ æ¡ä»¶è¾¹
        graph.add_conditional_edges(
            "llm",
            self.should_continue,
            {
                "continue": "tools",
                "end": END,
                "interrupt": END
            }
        )
        
        # tools -> llm
        graph.add_edge("tools", "llm")
        
        # ç¼–è¯‘
        return graph.compile(checkpointer=self.checkpointer)
    
    async def llm_node(self, state: AgentState) -> dict:
        """LLM èŠ‚ç‚¹"""
        # ... LLM è°ƒç”¨é€»è¾‘ ...
        pass
    
    async def tools_node(self, state: AgentState) -> dict:
        """å·¥å…·èŠ‚ç‚¹"""
        tool_calls = extract_tool_calls(state["messages"][-1])
        results = []
        
        for tool_call in tool_calls:
            result = await execute_tool(tool_call, state)
            
            # æ£€æŸ¥å„ç§é”™è¯¯
            if result.get("error") == "insufficient_points":
                raise NodeInterrupt(
                    code=-1002,
                    message="ç¨¿è±†ä¸è¶³",
                    extra=result
                )
            
            elif result.get("error") == "token_expired":
                raise NodeInterrupt(
                    code=-1004,
                    message="Token è¿‡æœŸ",
                    extra=result
                )
            
            results.append({
                "role": "function",
                "content": {
                    "type": "function_response",
                    "text": result
                }
            })
        
        return {"messages": results}
    
    def should_continue(self, state: AgentState) -> str:
        """è·¯ç”±å‡½æ•°"""
        if state.get("needs_resume"):
            return "interrupt"
        
        last_message = state["messages"][-1]
        if has_tool_call(last_message):
            return "continue"
        
        return "end"
    
    async def run(self, user_input: str, thread_id: str, user_id: str):
        """æ‰§è¡Œ Agent"""
        
        # 1. æ„é€ åˆå§‹çŠ¶æ€
        state = {
            "messages": [{
                "role": "user",
                "content": {"type": "plain", "text": user_input}
            }],
            "llm_calls": 0,
            "tool_calls": 0,
            "user_id": user_id,
            "thread_id": thread_id
        }
        
        # 2. é…ç½®
        config = {"thread_id": thread_id}
        
        # 3. æ‰§è¡Œ
        try:
            async for event in self.app.astream(state, config=config):
                yield event
        
        except NodeInterrupt as e:
            # ä¸­æ–­ï¼šå‘é€çŠ¶æ€æ¶ˆæ¯
            yield {
                "type": "status",
                "content": {
                    "code": e.code,
                    "message": e.message,
                    "extra": e.extra
                }
            }
    
    async def resume(self, thread_id: str):
        """æ¢å¤æ‰§è¡Œ"""
        
        # 1. åŠ è½½æœ€æ–°çš„ Checkpoint
        checkpoint = self.checkpointer.get(thread_id)
        
        if not checkpoint:
            raise ValueError("No checkpoint found")
        
        # 2. æ¢å¤çŠ¶æ€
        state = checkpoint.state
        
        # 3. æ¸…é™¤ä¸­æ–­æ ‡è®°
        if "needs_resume" in state:
            state["needs_resume"] = False
        
        # 4. æ·»åŠ æ¢å¤æ¶ˆæ¯
        state["messages"].append({
            "role": "status",
            "content": {
                "code": -2001,
                "message": "æ¢å¤æ‰§è¡Œ"
            }
        })
        
        # 5. ç»§ç»­æ‰§è¡Œ
        config = {"thread_id": thread_id}
        async for event in self.app.astream(state, config=config):
            yield event
```

### 4.3 API å±‚å®ç°

```python
from fastapi import FastAPI, HTTPException
from fastapi.responses import StreamingResponse
from pydantic import BaseModel

app = FastAPI()
agent = AgentWithResume(checkpointer=redis_checkpointer)

class ChatRequest(BaseModel):
    message: Optional[str]
    thread_id: Optional[str]
    user_id: str
    resume: bool = False

@app.post("/api/agent/chat")
async def chat(request: ChatRequest):
    """èŠå¤©æ¥å£"""
    
    # ç”Ÿæˆ thread_idï¼ˆå¦‚æœæ˜¯æ–°ä¼šè¯ï¼‰
    thread_id = request.thread_id or generate_thread_id()
    
    async def event_generator():
        """SSE äº‹ä»¶ç”Ÿæˆå™¨"""
        
        if request.resume:
            # æ¢å¤æ‰§è¡Œ
            async for event in agent.resume(thread_id):
                yield f"data: {json.dumps(event)}\n\n"
        
        else:
            # æ–°æ¶ˆæ¯
            if not request.message:
                raise HTTPException(400, "Message required")
            
            async for event in agent.run(
                request.message,
                thread_id,
                request.user_id
            ):
                yield f"data: {json.dumps(event)}\n\n"
    
    return StreamingResponse(
        event_generator(),
        media_type="text/event-stream"
    )
```

---

## äº”ã€ç‰¹æ®Šåœºæ™¯å¤„ç†

### 5.1 å¹¶å‘æ¢å¤

**é—®é¢˜**ï¼šç”¨æˆ·åœ¨ä¸åŒè®¾å¤‡ä¸ŠåŒæ—¶ç‚¹å‡»"ç»§ç»­"

```python
import asyncio
from contextlib import asynccontextmanager

class ConcurrentResumeGuard:
    """å¹¶å‘æ¢å¤ä¿æŠ¤"""
    
    def __init__(self, redis_client):
        self.redis = redis_client
        self.locks = {}
    
    @asynccontextmanager
    async def acquire(self, thread_id: str):
        """è·å–é”"""
        lock_key = f"resume_lock:{thread_id}"
        
        # å°è¯•è·å–é”ï¼ˆ5ç§’è¶…æ—¶ï¼‰
        acquired = await self.redis.set(
            lock_key,
            "locked",
            ex=5,
            nx=True
        )
        
        if not acquired:
            raise HTTPException(409, "Another resume is in progress")
        
        try:
            yield
        finally:
            # é‡Šæ”¾é”
            await self.redis.delete(lock_key)

# ä½¿ç”¨
resume_guard = ConcurrentResumeGuard(redis_client)

@app.post("/api/agent/chat")
async def chat(request: ChatRequest):
    if request.resume:
        async with resume_guard.acquire(request.thread_id):
            # æ‰§è¡Œæ¢å¤
            ...
```

### 5.2 è¶…æ—¶æ¢å¤

**é—®é¢˜**ï¼šç”¨æˆ·å……å€¼åå¾ˆä¹…æ‰ç‚¹å‡»"ç»§ç»­"

```python
async def resume(self, thread_id: str):
    """æ¢å¤æ‰§è¡Œ"""
    
    # 1. åŠ è½½ Checkpoint
    checkpoint = self.checkpointer.get(thread_id)
    
    # 2. æ£€æŸ¥æ˜¯å¦è¿‡æœŸï¼ˆå¦‚ 24 å°æ—¶ï¼‰
    if checkpoint.interrupted_at < datetime.now() - timedelta(hours=24):
        raise HTTPException(410, "Checkpoint expired")
    
    # 3. ç»§ç»­æ¢å¤æµç¨‹
    ...
```

### 5.3 éƒ¨åˆ†æ¢å¤

**é—®é¢˜**ï¼šå¤æ‚ä»»åŠ¡ä¸­æ–­åï¼Œç”¨æˆ·åªæƒ³æ¢å¤éƒ¨åˆ†

```python
class ChatRequest(BaseModel):
    resume: bool = False
    resume_from: Optional[str] = None  # ä»å“ªä¸ªæ­¥éª¤æ¢å¤

async def resume(self, thread_id: str, resume_from: Optional[str] = None):
    """éƒ¨åˆ†æ¢å¤"""
    
    checkpoint = self.checkpointer.get(thread_id)
    state = checkpoint.state
    
    if resume_from:
        # æ¸…é™¤æŒ‡å®šæ­¥éª¤ä¹‹åçš„æ¶ˆæ¯
        messages = state["messages"]
        state["messages"] = [
            msg for msg in messages
            if msg.get("step_id", "") <= resume_from
        ]
    
    # ç»§ç»­æ‰§è¡Œ
    ...
```

---

## å…­ã€æœ€ä½³å®è·µ

### 6.1 ä¸­æ–­è®¾è®¡åŸåˆ™

**DOï¼š**
- âœ… ä½¿ç”¨ NodeInterrupt å¤„ç†ç³»ç»Ÿçº§ä¸­æ–­
- âœ… ä¿å­˜å®Œæ•´çš„ä¸Šä¸‹æ–‡ä¿¡æ¯
- âœ… æä¾›æ¸…æ™°çš„é”™è¯¯æè¿°
- âœ… åŒºåˆ†å¯æ¢å¤å’Œä¸å¯æ¢å¤çš„é”™è¯¯
- âœ… è®¾ç½®åˆç†çš„ Checkpoint è¿‡æœŸæ—¶é—´

**DON'Tï¼š**
- âŒ åœ¨ä¸­æ–­ä¿¡æ¯ä¸­å­˜å‚¨æ•æ„Ÿæ•°æ®
- âŒ è¿‡åº¦ä½¿ç”¨ä¸­æ–­ï¼ˆå½±å“ç”¨æˆ·ä½“éªŒï¼‰
- âŒ å¿˜è®°æ¸…ç†è¿‡æœŸçš„ Checkpoint
- âŒ ä¸å¤„ç†å¹¶å‘æ¢å¤

### 6.2 æ¢å¤ç­–ç•¥

| åœºæ™¯ | ç­–ç•¥ |
|------|------|
| **ç¨¿è±†ä¸è¶³** | ç­‰å¾…ç”¨æˆ·å……å€¼ï¼Œæ‰‹åŠ¨æ¢å¤ |
| **Tokenè¿‡æœŸ** | è‡ªåŠ¨åˆ·æ–°ï¼Œè‡ªåŠ¨æ¢å¤ |
| **ç½‘ç»œé”™è¯¯** | è‡ªåŠ¨é‡è¯•ï¼Œè‡ªåŠ¨æ¢å¤ |
| **å†…å®¹é£é™©** | ä¸­æ–­å¹¶æ’¤å›ï¼Œä¸æ¢å¤ |
| **è¶…æ—¶** | æç¤ºç”¨æˆ·ï¼Œæ‰‹åŠ¨æ¢å¤æˆ–æ”¾å¼ƒ |

---

## ä¸ƒã€æ€»ç»“

### 7.1 æ ¸å¿ƒæ¦‚å¿µ

1. **ä¸­æ–­æ¢å¤çš„æœ¬è´¨**ï¼šä¿å­˜å®Œæ•´çŠ¶æ€ï¼Œä»ä»»æ„ç‚¹ç»§ç»­
2. **ä¸¤ç§ä¸­æ–­æ–¹å¼**ï¼šNodeInterruptï¼ˆç³»ç»Ÿçº§ï¼‰å’ŒçŠ¶æ€æ ‡è®°ï¼ˆä¸šåŠ¡çº§ï¼‰
3. **Checkpoint æœºåˆ¶**ï¼šçŠ¶æ€å¿«ç…§ + æ‰§è¡Œä½ç½®
4. **æ¢å¤æµç¨‹**ï¼šåŠ è½½çŠ¶æ€ â†’ æ¸…é™¤æ ‡è®° â†’ ç»§ç»­æ‰§è¡Œ

### 7.2 å…³é”®å®ç°

- âœ… NodeInterrupt å¼‚å¸¸å¤„ç†
- âœ… Checkpoint åºåˆ—åŒ–å’Œå­˜å‚¨
- âœ… å¹¶å‘æ¢å¤ä¿æŠ¤
- âœ… è¶…æ—¶å’Œè¿‡æœŸå¤„ç†
- âœ… å®Œæ•´çš„ API è®¾è®¡

---

*æ–‡æ¡£ç‰ˆæœ¬ï¼šv1.0*  
*æœ€åæ›´æ–°ï¼š2026-01-26*

**ä¸Šä¸€ç¯‡**ï¼š[â† ç½‘ç»œæ¶æ„](05-ç½‘ç»œæ¶æ„.md) | **ä¸‹ä¸€ç¯‡**ï¼š[ä¸šåŠ¡åŠŸèƒ½ â†’](07-ä¸šåŠ¡åŠŸèƒ½.md)
