# å·¥å…·è°ƒç”¨æ·±å…¥åŸç†

> **Function Calling çš„æœ¬è´¨ä¸å®ç°**

---

## ä¸€ã€ä»€ä¹ˆæ˜¯ Function Callingï¼Ÿ

### 1.1 ä»é—®é¢˜å‡ºå‘

**é—®é¢˜**ï¼šLLM çš„çŸ¥è¯†æ˜¯é™æ€çš„

```
ç”¨æˆ·ï¼šåŒ—äº¬æ˜å¤©å¤©æ°”æ€ä¹ˆæ ·ï¼Ÿ
LLMï¼š[æŸ¥è¯¢è®­ç»ƒæ•°æ®] æˆ‘çš„çŸ¥è¯†æˆªæ­¢åˆ° 2024å¹´1æœˆ...

ç”¨æˆ·ï¼šå¸®æˆ‘ç”Ÿæˆä¸€å¼ å›¾ç‰‡
LLMï¼š[åªèƒ½å›å¤æ–‡å­—] æŠ±æ­‰ï¼Œæˆ‘æ— æ³•ç”Ÿæˆå›¾ç‰‡...
```

**è§£å†³æ–¹æ¡ˆ**ï¼šè®© LLM è°ƒç”¨å¤–éƒ¨å·¥å…·

```
ç”¨æˆ·ï¼šåŒ—äº¬æ˜å¤©å¤©æ°”æ€ä¹ˆæ ·ï¼Ÿ
LLMï¼šæˆ‘éœ€è¦è°ƒç”¨å¤©æ°”æŸ¥è¯¢å·¥å…·
  â†“
[è°ƒç”¨ get_weather("åŒ—äº¬", "æ˜å¤©")]
  â†“
å·¥å…·è¿”å›ï¼š{"weather": "æ™´", "temp": "20-25â„ƒ"}
  â†“
LLMï¼šæ ¹æ®æŸ¥è¯¢ç»“æœï¼ŒåŒ—äº¬æ˜å¤©æ™´ï¼Œæ¸©åº¦ 20-25â„ƒ
```

### 1.2 Function Calling çš„æœ¬è´¨

> ğŸ’¡ **æ ¸å¿ƒæ´å¯Ÿ**  
> Function Calling çš„æœ¬è´¨æ˜¯ï¼š**è®© LLM è¾“å‡ºç»“æ„åŒ–çš„å‡½æ•°è°ƒç”¨æŒ‡ä»¤**ï¼Œè€Œä¸æ˜¯è‡ªç„¶è¯­è¨€ã€‚

**ä¼ ç»Ÿæ–¹å¼ï¼ˆè‡ªç„¶è¯­è¨€ï¼‰**ï¼š
```
LLMè¾“å‡ºï¼šè¯·è°ƒç”¨å¤©æ°”æŸ¥è¯¢APIï¼ŒåŸå¸‚å‚æ•°æ˜¯åŒ—äº¬ï¼Œæ—¥æœŸæ˜¯æ˜å¤©
```
é—®é¢˜ï¼šéœ€è¦å¤æ‚çš„ NLP è§£æ

**Function Callingï¼ˆç»“æ„åŒ–ï¼‰**ï¼š
```json
{
  "name": "get_weather",
  "arguments": {
    "city": "åŒ—äº¬",
    "date": "æ˜å¤©"
  }
}
```
ä¼˜åŠ¿ï¼šç›´æ¥å¯æ‰§è¡Œ

### 1.3 å·¥ä½œæµç¨‹

```mermaid
sequenceDiagram
    participant User
    participant Agent
    participant LLM
    participant Tool

    User->>Agent: åŒ—äº¬æ˜å¤©å¤©æ°”ï¼Ÿ
    Agent->>Agent: åœ¨ System Prompt ä¸­æ³¨å…¥å·¥å…·æè¿°
    Agent->>LLM: è°ƒç”¨ LLMï¼ˆé™„å¸¦å·¥å…·æè¿°ï¼‰
    
    Note over LLM: LLM ç†è§£éœ€è¦è°ƒç”¨å·¥å…·
    
    LLM-->>Agent: <tool_call>{"name":"get_weather",...}</tool_call>
    Agent->>Agent: è§£æå·¥å…·è°ƒç”¨
    Agent->>Tool: æ‰§è¡Œå·¥å…·
    Tool-->>Agent: è¿”å›ç»“æœ
    Agent->>LLM: å°†å·¥å…·ç»“æœä½œä¸ºæ–°æ¶ˆæ¯
    LLM-->>Agent: ç”Ÿæˆæœ€ç»ˆå›å¤
    Agent->>User: åŒ—äº¬æ˜å¤©æ™´ï¼Œ20-25â„ƒ
```

---

## äºŒã€System Prompt æ³¨å…¥å·¥å…·æè¿°

### 2.1 FN_CALL_TEMPLATE å‰–æ

ä»å›¾ç‰‡ `image2025-7-4_14-16-44.png` å¯ä»¥çœ‹åˆ°å®Œæ•´çš„æ¨¡æ¿ï¼š

```python
FN_CALL_TEMPLATE = """# Tools

You may call one or more functions to assist with the user query.

You are provided with function signatures within XML tags:

{tool_descs}

For each function call, return a json object with function name and arguments within XML tags:

<tool_call>
{{"name": <function_name>, "arguments": <args_dict>}}
</tool_call>
"""
```

**è®¾è®¡åˆ†æ**ï¼š

1. **ä½¿ç”¨ XML æ ‡ç­¾**
   - `<tool_call>` ä½œä¸ºè¾¹ç•Œæ ‡è®°
   - æ˜“äºè§£æï¼ˆä¸ä¾èµ–å¤æ‚çš„æ­£åˆ™è¡¨è¾¾å¼ï¼‰
   - å¯ä»¥å¤„ç†åµŒå¥—çš„ JSON

2. **JSON æ ¼å¼çš„å‚æ•°**
   - æ ‡å‡†åŒ–çš„æ•°æ®æ ¼å¼
   - LLM ç”ŸæˆJSONçš„èƒ½åŠ›å¼º
   - å¯ä»¥ç›´æ¥ååºåˆ—åŒ–

3. **æ”¯æŒå¤šä¸ªå·¥å…·è°ƒç”¨**
   - "one or more functions"
   - LLM å¯ä»¥åœ¨ä¸€æ¬¡å›å¤ä¸­è°ƒç”¨å¤šä¸ªå·¥å…·

### 2.2 å·¥å…·æè¿°çš„ç”Ÿæˆ

ä»å›¾ç‰‡ `image2025-7-4_14-17-4.png` å¯ä»¥çœ‹åˆ°å·¥å…·æè¿°çš„XMLæ ¼å¼ï¼š

```xml
<tool>
  <name>é€šç”¨</name>
  <description>æ ¹æ®éœ€æ±‚ç”Ÿæˆå›¾ç‰‡</description>
  <parameters>
    <parameter>
      <name>width</name>
      <type>string</type>
      <description>å®½åº¦ã€‚Enum: ["512", "768", "1024"]</description>
      <required>true</required>
    </parameter>
    <parameter>
      <name>height</name>
      <type>string</type>
      <description>é«˜åº¦ã€‚Enum: ["512", "768", "1024"]</description>
      <required>true</required>
    </parameter>
    <parameter>
      <name>user_prompt</name>
      <type>string</type>
      <description>ç”¨æˆ·çš„å›¾ç‰‡éœ€æ±‚æè¿°</description>
      <required>true</required>
    </parameter>
  </parameters>
</tool>
```

**ä»£ç å®ç°**ï¼ˆä»å›¾ç‰‡ `image2025-7-4_16-34-8.png` æ¨å¯¼ï¼‰ï¼š

```python
def generate_tool_description(tool: Tool) -> str:
    """ç”Ÿæˆå•ä¸ªå·¥å…·çš„ XML æè¿°"""
    
    params_xml = []
    for param_name, param_def in tool.parameters.items():
        param_xml = f"""
    <parameter>
      <name>{param_name}</name>
      <type>{param_def['type']}</type>
      <description>{param_def['description']}</description>
      <required>{str(param_def.get('required', False)).lower()}</required>
    </parameter>"""
        params_xml.append(param_xml)
    
    tool_xml = f"""<tool>
  <name>{tool.name}</name>
  <description>{tool.description}</description>
  <parameters>
{''.join(params_xml)}
  </parameters>
</tool>"""
    
    return tool_xml


def generate_all_tools_description(tools: List[Tool]) -> str:
    """ç”Ÿæˆæ‰€æœ‰å·¥å…·çš„æè¿°"""
    tool_descs = [generate_tool_description(tool) for tool in tools]
    return '\n\n'.join(tool_descs)
```

### 2.3 å®Œæ•´çš„ System Prompt æ„é€ 

```python
def build_system_prompt(tools: List[Tool]) -> str:
    """æ„é€ åŒ…å«å·¥å…·æè¿°çš„ System Prompt"""
    
    # 1. åŸºç¡€æŒ‡ä»¤
    base_instruction = """ä½ æ˜¯ç¨¿å®š AI Agentï¼Œä¸€ä¸ªæ“…é•¿è®¾è®¡å’Œåˆ›ä½œçš„åŠ©æ‰‹ã€‚
ä½ å¯ä»¥è°ƒç”¨å·¥å…·æ¥å¸®åŠ©ç”¨æˆ·å®Œæˆä»»åŠ¡ã€‚"""
    
    # 2. ç”Ÿæˆå·¥å…·æè¿°
    if tools:
        tool_descs = generate_all_tools_description(tools)
        fn_call_instruction = FN_CALL_TEMPLATE.format(
            tool_descs=tool_descs
        )
    else:
        fn_call_instruction = ""
    
    # 3. åˆå¹¶
    system_prompt = base_instruction
    if fn_call_instruction:
        system_prompt += "\n\n" + fn_call_instruction
    
    return system_prompt
```

**ç¤ºä¾‹è¾“å‡º**ï¼š

```
ä½ æ˜¯ç¨¿å®š AI Agentï¼Œä¸€ä¸ªæ“…é•¿è®¾è®¡å’Œåˆ›ä½œçš„åŠ©æ‰‹ã€‚
ä½ å¯ä»¥è°ƒç”¨å·¥å…·æ¥å¸®åŠ©ç”¨æˆ·å®Œæˆä»»åŠ¡ã€‚

# Tools

You may call one or more functions to assist with the user query.

You are provided with function signatures within XML tags:

<tool>
  <name>é€šç”¨</name>
  <description>æ ¹æ®éœ€æ±‚ç”Ÿæˆå›¾ç‰‡</description>
  <parameters>
    <parameter>
      <name>width</name>
      <type>string</type>
      <description>å®½åº¦ã€‚Enum: ["512", "768", "1024"]</description>
      <required>true</required>
    </parameter>
    ...
  </parameters>
</tool>

For each function call, return a json object with function name and arguments within XML tags:

<tool_call>
{"name": <function_name>, "arguments": <args_dict>}
</tool_call>
```

---

## ä¸‰ã€æµå¼è§£æå·¥å…·è°ƒç”¨

### 3.1 ä¸ºä»€ä¹ˆéœ€è¦æµå¼è§£æï¼Ÿ

**é—®é¢˜**ï¼šLLM æ˜¯æµå¼è¾“å‡ºçš„

```
Chunk 1: "æˆ‘"
Chunk 2: "æ¥"
Chunk 3: "å¸®"
Chunk 4: "ä½ "
Chunk 5: "ç”Ÿ"
Chunk 6: "æˆ"
Chunk 7: "<tool_call>"
Chunk 8: '{"name"'
Chunk 9: ':"generate'
Chunk 10: '_image"'
...
```

**æŒ‘æˆ˜**ï¼š
1. å·¥å…·è°ƒç”¨å¯èƒ½è·¨è¶Šå¤šä¸ª chunk
2. éœ€è¦æ£€æµ‹ `<tool_call>` æ ‡ç­¾çš„å¼€å§‹å’Œç»“æŸ
3. éœ€è¦å¤„ç†ä¸å®Œæ•´çš„ JSON

### 3.2 æµå¼è§£æç®—æ³•

ä»å›¾ç‰‡ `image2025-7-4_14-41-48.png` å¯ä»¥çœ‹åˆ°å…³é”®æ£€æµ‹ç‚¹ï¼š

```python
def parse_tool_call_streaming(response_stream):
    """
    æµå¼è§£æå·¥å…·è°ƒç”¨
    
    çŠ¶æ€æœºï¼š
    - NORMAL: æ™®é€šæ–‡æœ¬
    - IN_TOOL_CALL: åœ¨ <tool_call> æ ‡ç­¾å†…
    - COMPLETE: å·¥å…·è°ƒç”¨å®Œæˆ
    """
    
    buffer = ""
    state = "NORMAL"
    tool_call_content = ""
    
    for chunk in response_stream:
        buffer += chunk
        
        if state == "NORMAL":
            # æ£€æµ‹å·¥å…·è°ƒç”¨å¼€å§‹
            if "<tool_call>" in buffer:
                # æå– <tool_call> ä¹‹å‰çš„å†…å®¹ï¼ˆçº¯æ–‡æœ¬å›å¤ï¼‰
                idx = buffer.index("<tool_call>")
                if idx > 0:
                    yield {
                        "type": "text",
                        "content": buffer[:idx]
                    }
                
                # è¿›å…¥å·¥å…·è°ƒç”¨çŠ¶æ€
                state = "IN_TOOL_CALL"
                buffer = buffer[idx + len("<tool_call>"):]
                tool_call_content = ""
        
        elif state == "IN_TOOL_CALL":
            # æ£€æµ‹å·¥å…·è°ƒç”¨ç»“æŸ
            if "</tool_call>" in buffer:
                # æå–å®Œæ•´çš„å·¥å…·è°ƒç”¨
                idx = buffer.index("</tool_call>")
                tool_call_content += buffer[:idx]
                
                # è§£æ JSON
                try:
                    tool_call = json.loads(tool_call_content)
                    yield {
                        "type": "tool_call",
                        "content": tool_call
                    }
                except json.JSONDecodeError as e:
                    yield {
                        "type": "error",
                        "content": f"Invalid tool call JSON: {e}"
                    }
                
                # æ¢å¤æ™®é€šçŠ¶æ€
                state = "NORMAL"
                buffer = buffer[idx + len("</tool_call>"):]
                tool_call_content = ""
            else:
                # è¿˜åœ¨å·¥å…·è°ƒç”¨å†…ï¼Œç»§ç»­ç´¯ç§¯
                tool_call_content += buffer
                buffer = ""
    
    # å¤„ç†å‰©ä½™å†…å®¹
    if buffer:
        yield {
            "type": "text",
            "content": buffer
        }
```

### 3.3 è¾¹ç•Œæƒ…å†µå¤„ç†

**æƒ…å†µ 1ï¼šå·¥å…·è°ƒç”¨è·¨ chunk è¾¹ç•Œ**

```
Chunk N:   ...{"name":"gen
Chunk N+1: erate_image"...
```

è§£å†³æ–¹æ¡ˆï¼šç´¯ç§¯åˆ° buffer ä¸­ï¼Œç›´åˆ°é‡åˆ° `</tool_call>`

**æƒ…å†µ 2ï¼šJSON æ ¼å¼é”™è¯¯**

```xml
<tool_call>
{"name": "generate_image", "arguments": {invalid json}}
</tool_call>
```

è§£å†³æ–¹æ¡ˆï¼šæ•è· `json.JSONDecodeError`ï¼Œè¿”å›é”™è¯¯æ¶ˆæ¯

**æƒ…å†µ 3ï¼šå¤šä¸ªå·¥å…·è°ƒç”¨**

```xml
<tool_call>
{"name": "tool1", ...}
</tool_call>
ä¸€äº›æ–‡æœ¬
<tool_call>
{"name": "tool2", ...}
</tool_call>
```

è§£å†³æ–¹æ¡ˆï¼šçŠ¶æ€æœºåœ¨ `NORMAL` å’Œ `IN_TOOL_CALL` ä¹‹é—´åˆ‡æ¢

---

## å››ã€å·¥å…·è°ƒç”¨çš„æ‰§è¡Œ

### 4.1 ToolRegistry è®¾è®¡

ä»å›¾ç‰‡ `image2025-7-4_16-35-6.png` å¯ä»¥çœ‹åˆ°å·¥å…·æ³¨å†Œè¡¨çš„è®¾è®¡ï¼š

```python
class ToolRegistry:
    """å·¥å…·æ³¨å†Œè¡¨"""
    
    def __init__(self):
        self._tools: Dict[str, Tool] = {}
    
    def register(self, tool: Tool):
        """æ³¨å†Œå·¥å…·"""
        if tool.name in self._tools:
            raise ValueError(f"Tool {tool.name} already registered")
        
        self._tools[tool.name] = tool
        logger.info(f"Registered tool: {tool.name}")
    
    def get(self, name: str) -> Optional[Tool]:
        """è·å–å·¥å…·"""
        return self._tools.get(name)
    
    def list_all(self) -> List[Tool]:
        """åˆ—å‡ºæ‰€æœ‰å·¥å…·"""
        return list(self._tools.values())
    
    def get_descriptions(self) -> str:
        """è·å–æ‰€æœ‰å·¥å…·çš„æè¿°ï¼ˆç”¨äº System Promptï¼‰"""
        return generate_all_tools_description(self.list_all())


# å…¨å±€å•ä¾‹
tool_registry = ToolRegistry()
```

### 4.2 Tool æŠ½è±¡

```python
from abc import ABC, abstractmethod
from typing import Dict, Any

class Tool(ABC):
    """å·¥å…·åŸºç±»"""
    
    def __init__(
        self,
        name: str,
        description: str,
        parameters: Dict[str, Any]
    ):
        self.name = name
        self.description = description
        self.parameters = parameters
    
    @abstractmethod
    async def execute(self, **kwargs) -> Dict[str, Any]:
        """æ‰§è¡Œå·¥å…·"""
        pass
    
    def validate_parameters(self, kwargs: Dict[str, Any]):
        """éªŒè¯å‚æ•°"""
        for param_name, param_def in self.parameters.items():
            # æ£€æŸ¥å¿…éœ€å‚æ•°
            if param_def.get('required', False) and param_name not in kwargs:
                raise ValueError(f"Missing required parameter: {param_name}")
            
            # æ£€æŸ¥å‚æ•°ç±»å‹
            if param_name in kwargs:
                value = kwargs[param_name]
                expected_type = param_def['type']
                
                if expected_type == 'string' and not isinstance(value, str):
                    raise TypeError(f"Parameter {param_name} must be string")
                elif expected_type == 'number' and not isinstance(value, (int, float)):
                    raise TypeError(f"Parameter {param_name} must be number")
                elif expected_type == 'boolean' and not isinstance(value, bool):
                    raise TypeError(f"Parameter {param_name} must be boolean")
```

### 4.3 å·¥å…·å®ç°ç¤ºä¾‹

**å›¾åƒç”Ÿæˆå·¥å…·**ï¼š

```python
class GenerateImageTool(Tool):
    """å›¾åƒç”Ÿæˆå·¥å…·"""
    
    def __init__(self):
        super().__init__(
            name="é€šç”¨",
            description="æ ¹æ®éœ€æ±‚ç”Ÿæˆå›¾ç‰‡",
            parameters={
                "user_prompt": {
                    "type": "string",
                    "description": "ç”¨æˆ·çš„å›¾ç‰‡éœ€æ±‚æè¿°",
                    "required": True
                },
                "width": {
                    "type": "string",
                    "description": "å®½åº¦ã€‚Enum: ['512', '768', '1024']",
                    "required": True
                },
                "height": {
                    "type": "string",
                    "description": "é«˜åº¦ã€‚Enum: ['512', '768', '1024']",
                    "required": True
                }
            }
        )
    
    async def execute(
        self,
        user_prompt: str,
        width: str,
        height: str,
        **kwargs
    ) -> Dict[str, Any]:
        """æ‰§è¡Œå›¾åƒç”Ÿæˆ"""
        
        # 1. éªŒè¯å‚æ•°
        self.validate_parameters(locals())
        
        # 2. æ£€æŸ¥ç¨¿è±†ä½™é¢
        user_id = kwargs.get('user_id')
        required_points = self.calculate_points(width, height)
        
        balance = get_user_balance(user_id)
        if balance < required_points:
            return {
                "tool_name": self.name,
                "result": "failed",
                "error": "insufficient_points",
                "message": "ç¨¿è±†ä¸è¶³",
                "required_points": required_points,
                "current_balance": balance
            }
        
        # 3. è°ƒç”¨å›¾åƒç”ŸæˆæœåŠ¡
        try:
            result = await image_service.generate(
                prompt=user_prompt,
                width=int(width),
                height=int(height)
            )
            
            # 4. æ‰£é™¤ç¨¿è±†
            deduct_points(user_id, required_points)
            
            # 5. è¿”å›ç»“æœ
            return {
                "tool_name": self.name,
                "result": "success",
                "image_url": result['url'],
                "task_id": result['task_id'],
                "width": width,
                "height": height,
                "deduct_points": required_points
            }
        
        except Exception as e:
            logger.error(f"Image generation failed: {e}")
            return {
                "tool_name": self.name,
                "result": "failed",
                "error": "generation_failed",
                "message": str(e)
            }
    
    def calculate_points(self, width: str, height: str) -> int:
        """è®¡ç®—éœ€è¦çš„ç¨¿è±†"""
        w = int(width)
        h = int(height)
        pixels = w * h
        
        # ç®€å•ç¤ºä¾‹ï¼šæ¯ 100k åƒç´ æ¶ˆè€— 1 ç¨¿è±†
        return max(1, pixels // 100000)


# æ³¨å†Œå·¥å…·
tool_registry.register(GenerateImageTool())
```

### 4.4 ToolExecutor è®¾è®¡

ä»å›¾ç‰‡ `image2025-7-4_16-36-34.png` å¯ä»¥çœ‹åˆ°æ‰§è¡Œå™¨çš„è®¾è®¡ï¼š

```python
class ToolExecutor:
    """å·¥å…·æ‰§è¡Œå™¨"""
    
    def __init__(self, registry: ToolRegistry):
        self.registry = registry
    
    async def execute(
        self,
        tool_call: Dict[str, Any],
        context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        æ‰§è¡Œå·¥å…·è°ƒç”¨
        
        Args:
            tool_call: {"name": "tool_name", "arguments": {...}}
            context: {"user_id": "...", "thread_id": "...", ...}
        
        Returns:
            å·¥å…·æ‰§è¡Œç»“æœ
        """
        
        tool_name = tool_call['name']
        arguments = tool_call['arguments']
        
        # 1. è·å–å·¥å…·
        tool = self.registry.get(tool_name)
        if not tool:
            return {
                "tool_name": tool_name,
                "result": "failed",
                "error": "tool_not_found",
                "message": f"Tool '{tool_name}' not found"
            }
        
        # 2. åˆå¹¶ä¸Šä¸‹æ–‡
        kwargs = {**arguments, **context}
        
        # 3. æ‰§è¡Œå·¥å…·
        try:
            result = await tool.execute(**kwargs)
            return result
        
        except Exception as e:
            logger.error(f"Tool execution failed: {tool_name}, error: {e}")
            return {
                "tool_name": tool_name,
                "result": "failed",
                "error": "execution_failed",
                "message": str(e)
            }
```

---

## äº”ã€å¤šæ¨¡å‹é€‚é…

### 5.1 ä¸åŒ LLM çš„å·¥å…·è°ƒç”¨æ ¼å¼

| LLM | æ ‡ç­¾æ ¼å¼ | JSON æ ¼å¼ | æ˜¯å¦ç»Ÿä¸€ |
|-----|----------|-----------|---------|
| **OpenAI** | æ— ï¼ˆä½¿ç”¨ç‰¹æ®Šå­—æ®µï¼‰| æ ‡å‡† | âœ… |
| **Claude** | `<tool_call>` | æ ‡å‡† | âœ… |
| **Doubao** | `<FunctionCallBegin>` | éæ ‡å‡† | âŒ |
| **Qwen** | `<tool_call>` æˆ– `âœ¿FUNCTIONâœ¿` | æ ‡å‡† | âš ï¸ |

### 5.2 Doubao çš„ç‰¹æ®Šæ ¼å¼

**Doubao è¾“å‡º**ï¼š
```xml
<FunctionCallBegin>
[{"name":"é€šç”¨","parameters":{"user_prompt":"...","width":"512","height":"512"}}]
</FunctionCallEnd>
```

**ä¸æ ‡å‡†æ ¼å¼çš„åŒºåˆ«**ï¼š
1. ä½¿ç”¨ `<FunctionCallBegin>` è€Œä¸æ˜¯ `<tool_call>`
2. ä½¿ç”¨ `parameters` è€Œä¸æ˜¯ `arguments`
3. æ˜¯ä¸€ä¸ªæ•°ç»„ï¼ˆæ”¯æŒå¤šä¸ªå·¥å…·è°ƒç”¨ï¼‰

### 5.3 ç»Ÿä¸€é€‚é…å±‚

```python
class LLMAdapter(ABC):
    """LLM é€‚é…å™¨åŸºç±»"""
    
    @abstractmethod
    def parse_tool_call(self, response: str) -> List[Dict[str, Any]]:
        """è§£æå·¥å…·è°ƒç”¨"""
        pass


class DoubaoAdapter(LLMAdapter):
    """Doubao é€‚é…å™¨"""
    
    def parse_tool_call(self, response: str) -> List[Dict[str, Any]]:
        """è§£æ Doubao çš„å·¥å…·è°ƒç”¨"""
        
        # 1. æå– FunctionCall æ ‡ç­¾å†…å®¹
        pattern = r'<FunctionCallBegin>(.*?)</FunctionCallEnd>'
        matches = re.findall(pattern, response, re.DOTALL)
        
        if not matches:
            return []
        
        # 2. è§£æ JSON æ•°ç»„
        tool_calls = []
        for match in matches:
            try:
                calls = json.loads(match)
                
                # 3. è½¬æ¢ä¸ºæ ‡å‡†æ ¼å¼
                for call in calls:
                    tool_calls.append({
                        "name": call['name'],
                        "arguments": call['parameters']  # è½¬æ¢å­—æ®µå
                    })
            
            except json.JSONDecodeError as e:
                logger.error(f"Failed to parse Doubao tool call: {e}")
        
        return tool_calls


class ClaudeAdapter(LLMAdapter):
    """Claude é€‚é…å™¨"""
    
    def parse_tool_call(self, response: str) -> List[Dict[str, Any]]:
        """è§£æ Claude çš„å·¥å…·è°ƒç”¨"""
        
        # Claude ä½¿ç”¨æ ‡å‡†æ ¼å¼ï¼Œç›´æ¥è§£æ
        pattern = r'<tool_call>(.*?)</tool_call>'
        matches = re.findall(pattern, response, re.DOTALL)
        
        tool_calls = []
        for match in matches:
            try:
                call = json.loads(match)
                tool_calls.append(call)
            except json.JSONDecodeError as e:
                logger.error(f"Failed to parse Claude tool call: {e}")
        
        return tool_calls


# é€‚é…å™¨å·¥å‚
class AdapterFactory:
    _adapters = {
        "doubao": DoubaoAdapter(),
        "claude": ClaudeAdapter(),
        "gpt": ClaudeAdapter(),  # GPT ä½¿ç”¨æ ‡å‡†æ ¼å¼
        "qwen": ClaudeAdapter()  # Qwen ä¹Ÿä½¿ç”¨æ ‡å‡†æ ¼å¼
    }
    
    @classmethod
    def get_adapter(cls, model: str) -> LLMAdapter:
        """æ ¹æ®æ¨¡å‹è·å–é€‚é…å™¨"""
        for key, adapter in cls._adapters.items():
            if key in model.lower():
                return adapter
        
        # é»˜è®¤ä½¿ç”¨ Claude é€‚é…å™¨ï¼ˆæ ‡å‡†æ ¼å¼ï¼‰
        return cls._adapters["claude"]
```

### 5.4 ç»Ÿä¸€çš„å·¥å…·è°ƒç”¨æµç¨‹

```python
async def call_llm_with_tools(
    messages: List[Dict],
    tools: List[Tool],
    model: str = "doubao"
) -> AsyncGenerator:
    """
    è°ƒç”¨ LLM å¹¶æ”¯æŒå·¥å…·è°ƒç”¨
    """
    
    # 1. æ„é€  System Prompt
    system_prompt = build_system_prompt(tools)
    
    # 2. è°ƒç”¨ LLM
    response_stream = await llm_client.complete(
        model=model,
        messages=[
            {"role": "system", "content": system_prompt},
            *messages
        ],
        stream=True
    )
    
    # 3. è·å–é€‚é…å™¨
    adapter = AdapterFactory.get_adapter(model)
    
    # 4. æµå¼è§£æ
    buffer = ""
    async for chunk in response_stream:
        buffer += chunk
        
        # å°è¯•è§£æå·¥å…·è°ƒç”¨
        if "</tool_call>" in buffer or "</FunctionCallEnd>" in buffer:
            tool_calls = adapter.parse_tool_call(buffer)
            
            if tool_calls:
                # è¿”å›å·¥å…·è°ƒç”¨
                yield {
                    "type": "tool_calls",
                    "content": tool_calls
                }
                
                # æ¸…ç©º buffer
                buffer = ""
        else:
            # è¿”å›æ™®é€šæ–‡æœ¬
            yield {
                "type": "text",
                "content": chunk
            }
```

---

## å…­ã€å·¥å…·è°ƒç”¨çš„é«˜çº§ç‰¹æ€§

### 6.1 å¹¶è¡Œå·¥å…·è°ƒç”¨

**é—®é¢˜**ï¼šä¸€æ¬¡è°ƒç”¨å¤šä¸ªå·¥å…·

```
ç”¨æˆ·ï¼šå¸®æˆ‘æŸ¥è¯¢åŒ—äº¬å’Œä¸Šæµ·çš„å¤©æ°”

LLMè¾“å‡ºï¼š
<tool_call>
{"name": "get_weather", "arguments": {"city": "åŒ—äº¬"}}
</tool_call>
<tool_call>
{"name": "get_weather", "arguments": {"city": "ä¸Šæµ·"}}
</tool_call>
```

**å¤„ç†æ–¹å¼**ï¼š

```python
async def execute_tool_calls_parallel(
    tool_calls: List[Dict],
    context: Dict
) -> List[Dict]:
    """å¹¶è¡Œæ‰§è¡Œå¤šä¸ªå·¥å…·è°ƒç”¨"""
    
    tasks = [
        tool_executor.execute(call, context)
        for call in tool_calls
    ]
    
    results = await asyncio.gather(*tasks, return_exceptions=True)
    
    # å¤„ç†å¼‚å¸¸
    final_results = []
    for i, result in enumerate(results):
        if isinstance(result, Exception):
            final_results.append({
                "tool_name": tool_calls[i]['name'],
                "result": "failed",
                "error": "execution_failed",
                "message": str(result)
            })
        else:
            final_results.append(result)
    
    return final_results
```

### 6.2 å·¥å…·è°ƒç”¨é“¾

**é—®é¢˜**ï¼šä¸€ä¸ªå·¥å…·çš„è¾“å‡ºä½œä¸ºå¦ä¸€ä¸ªå·¥å…·çš„è¾“å…¥

```
ç”¨æˆ·ï¼šç”Ÿæˆä¸€å¼ å›¾ç‰‡ï¼Œç„¶åå¸®æˆ‘åˆ†æå›¾ç‰‡å†…å®¹

æµç¨‹ï¼š
1. è°ƒç”¨ generate_image
2. è·å– image_url
3. è°ƒç”¨ analyze_image(image_url)
```

**å®ç°æ–¹å¼**ï¼š

```python
async def execute_tool_chain(
    messages: List[Dict],
    tools: List[Tool],
    max_iterations: int = 10
) -> List[Dict]:
    """æ‰§è¡Œå·¥å…·è°ƒç”¨é“¾"""
    
    current_messages = messages.copy()
    iteration = 0
    
    while iteration < max_iterations:
        iteration += 1
        
        # 1. è°ƒç”¨ LLM
        response = await call_llm_with_tools(
            current_messages,
            tools
        )
        
        # 2. æ£€æŸ¥æ˜¯å¦æœ‰å·¥å…·è°ƒç”¨
        tool_calls = extract_tool_calls(response)
        
        if not tool_calls:
            # æ²¡æœ‰å·¥å…·è°ƒç”¨ï¼Œè¿”å›æœ€ç»ˆç»“æœ
            return current_messages + [response]
        
        # 3. æ‰§è¡Œå·¥å…·è°ƒç”¨
        tool_results = await execute_tool_calls_parallel(
            tool_calls,
            context
        )
        
        # 4. å°†å·¥å…·è°ƒç”¨å’Œç»“æœæ·»åŠ åˆ°æ¶ˆæ¯å†å²
        current_messages.append({
            "role": "assistant",
            "content": {
                "type": "function_call",
                "text": tool_calls
            }
        })
        
        for tool_result in tool_results:
            current_messages.append({
                "role": "function",
                "content": {
                    "type": "function_response",
                    "text": tool_result
                }
            })
    
    raise Exception("Max iterations reached")
```

### 6.3 å·¥å…·è°ƒç”¨çš„é‡è¯•æœºåˆ¶

```python
async def execute_tool_with_retry(
    tool_call: Dict,
    context: Dict,
    max_retries: int = 3
) -> Dict:
    """å¸¦é‡è¯•çš„å·¥å…·æ‰§è¡Œ"""
    
    for attempt in range(max_retries):
        try:
            result = await tool_executor.execute(tool_call, context)
            
            # æ£€æŸ¥ç»“æœ
            if result['result'] == 'success':
                return result
            
            # å¤±è´¥ä½†å¯é‡è¯•ï¼ˆå¦‚ç½‘ç»œé”™è¯¯ï¼‰
            if result.get('error') in ['network_error', 'timeout']:
                logger.warning(
                    f"Tool execution failed (attempt {attempt + 1}): "
                    f"{result.get('message')}"
                )
                await asyncio.sleep(2 ** attempt)  # æŒ‡æ•°é€€é¿
                continue
            
            # ä¸å¯é‡è¯•çš„é”™è¯¯ï¼ˆå¦‚å‚æ•°é”™è¯¯ï¼‰
            return result
        
        except Exception as e:
            logger.error(f"Tool execution exception: {e}")
            if attempt == max_retries - 1:
                return {
                    "tool_name": tool_call['name'],
                    "result": "failed",
                    "error": "max_retries_exceeded",
                    "message": str(e)
                }
            
            await asyncio.sleep(2 ** attempt)
    
    return {
        "tool_name": tool_call['name'],
        "result": "failed",
        "error": "max_retries_exceeded"
    }
```

---

## ä¸ƒã€æœ€ä½³å®è·µ

### 7.1 å·¥å…·è®¾è®¡åŸåˆ™

**DOï¼š**
- âœ… å•ä¸€èŒè´£ï¼šä¸€ä¸ªå·¥å…·åªåšä¸€ä»¶äº‹
- âœ… å¹‚ç­‰æ€§ï¼šç›¸åŒè¾“å…¥äº§ç”Ÿç›¸åŒè¾“å‡º
- âœ… è¯¦ç»†æè¿°ï¼šè®© LLM ç†è§£å·¥å…·çš„ç”¨é€”
- âœ… å‚æ•°éªŒè¯ï¼šæ£€æŸ¥å‚æ•°ç±»å‹å’Œå¿…éœ€æ€§
- âœ… é”™è¯¯å¤„ç†ï¼šè¿”å›ç»“æ„åŒ–çš„é”™è¯¯ä¿¡æ¯

**DON'Tï¼š**
- âŒ å·¥å…·å¤ªå¤æ‚ï¼ˆåº”è¯¥æ‹†åˆ†ï¼‰
- âŒ ç¼ºå°‘æè¿°ï¼ˆLLM ä¸çŸ¥é“ä½•æ—¶è°ƒç”¨ï¼‰
- âŒ å‚æ•°å¤ªå¤šï¼ˆLLM å®¹æ˜“å‡ºé”™ï¼‰
- âŒ è¿”å›æ ¼å¼ä¸ä¸€è‡´

### 7.2 å‚æ•°è®¾è®¡å»ºè®®

**å¥½çš„å‚æ•°è®¾è®¡**ï¼š

```python
{
    "user_prompt": {
        "type": "string",
        "description": "ç”¨æˆ·çš„å›¾ç‰‡éœ€æ±‚æè¿°ï¼Œä¾‹å¦‚ï¼š'ä¸€å¼ ç‰™è†äº§å“å›¾ï¼Œç®€çº¦é£æ ¼'",
        "required": True
    },
    "style": {
        "type": "string",
        "description": "å›¾ç‰‡é£æ ¼ã€‚å¯é€‰å€¼ï¼šç®€çº¦ã€å¤å¤ã€ç°ä»£ã€å¡é€š",
        "enum": ["ç®€çº¦", "å¤å¤", "ç°ä»£", "å¡é€š"],
        "required": False
    }
}
```

**ä¸å¥½çš„å‚æ•°è®¾è®¡**ï¼š

```python
{
    "params": {
        "type": "string",
        "description": "æ‰€æœ‰å‚æ•°çš„ JSON å­—ç¬¦ä¸²",  # âŒ å¤ªæ¨¡ç³Š
        "required": True
    }
}
```

### 7.3 å·¥å…·æè¿°çš„ Prompt Engineering

**å¥½çš„æè¿°**ï¼š

```
name: generate_image
description: æ ¹æ®ç”¨æˆ·çš„æ–‡å­—æè¿°ç”Ÿæˆå›¾ç‰‡ã€‚æ”¯æŒå¤šç§å°ºå¯¸å’Œé£æ ¼ã€‚

ä½¿ç”¨åœºæ™¯ï¼š
- ç”¨æˆ·è¦æ±‚ç”Ÿæˆå›¾ç‰‡
- ç”¨æˆ·æè¿°äº†æƒ³è¦çš„å›¾ç‰‡å†…å®¹
- ç”¨æˆ·æ²¡æœ‰æä¾›ç°æˆçš„å›¾ç‰‡

ä¸é€‚ç”¨åœºæ™¯ï¼š
- ç”¨æˆ·å·²ç»ä¸Šä¼ äº†å›¾ç‰‡ï¼ˆåº”è¯¥ä½¿ç”¨ analyze_imageï¼‰
- ç”¨æˆ·åªæ˜¯åœ¨è®¨è®ºå›¾ç‰‡ï¼Œä½†æ²¡æœ‰æ˜ç¡®è¦æ±‚ç”Ÿæˆ
```

**ä¸å¥½çš„æè¿°**ï¼š

```
name: generate_image
description: ç”Ÿæˆå›¾ç‰‡  # âŒ å¤ªç®€å•ï¼ŒLLM ä¸çŸ¥é“ä½•æ—¶è°ƒç”¨
```

---

## å…«ã€æ€»ç»“

### 8.1 æ ¸å¿ƒæ¦‚å¿µ

1. **Function Calling çš„æœ¬è´¨**ï¼šè®© LLM è¾“å‡ºç»“æ„åŒ–æŒ‡ä»¤
2. **System Prompt æ³¨å…¥**ï¼šå°†å·¥å…·æè¿°æ³¨å…¥åˆ°ç³»ç»Ÿæç¤ºä¸­
3. **æµå¼è§£æ**ï¼šå¤„ç† LLM çš„æµå¼è¾“å‡º
4. **å¤šæ¨¡å‹é€‚é…**ï¼šç»Ÿä¸€ä¸åŒ LLM çš„å·¥å…·è°ƒç”¨æ ¼å¼

### 8.2 å…³é”®å®ç°

- âœ… ToolRegistryï¼šå·¥å…·æ³¨å†Œè¡¨
- âœ… ToolExecutorï¼šå·¥å…·æ‰§è¡Œå™¨
- âœ… LLMAdapterï¼šå¤šæ¨¡å‹é€‚é…å™¨
- âœ… å¹¶è¡Œæ‰§è¡Œï¼šæ”¯æŒå¤šä¸ªå·¥å…·åŒæ—¶è°ƒç”¨
- âœ… é‡è¯•æœºåˆ¶ï¼šå¤„ç†ä¸´æ—¶å¤±è´¥

### 8.3 ä¸‹ä¸€æ­¥

- **[å·¥ä½œæµç¼–æ’](04-å·¥ä½œæµç¼–æ’.md)**ï¼šäº†è§£ LangGraph å¦‚ä½•ç¼–æ’å·¥å…·è°ƒç”¨
- **[ä¸­æ–­ä¸æ¢å¤](06-ä¸­æ–­ä¸æ¢å¤.md)**ï¼šå­¦ä¹ å¦‚ä½•å¤„ç†å·¥å…·è°ƒç”¨ä¸­æ–­

---

*æ–‡æ¡£ç‰ˆæœ¬ï¼šv1.0*  
*æœ€åæ›´æ–°ï¼š2026-01-26*

**ä¸Šä¸€ç¯‡**ï¼š[â† æ¶ˆæ¯ç³»ç»Ÿ](02-æ¶ˆæ¯ç³»ç»Ÿ.md) | **ä¸‹ä¸€ç¯‡**ï¼š[å·¥ä½œæµç¼–æ’ â†’](04-å·¥ä½œæµç¼–æ’.md)
