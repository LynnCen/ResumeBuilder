# ä¸šåŠ¡åŠŸèƒ½å®è·µ

> **çœŸå®åœºæ™¯çš„è§£å†³æ–¹æ¡ˆ**

---

## ä¸€ã€ä¼šè¯æ ‡é¢˜ç”Ÿæˆ

### 1.1 ä¸ºä»€ä¹ˆéœ€è¦è‡ªåŠ¨ç”Ÿæˆæ ‡é¢˜ï¼Ÿ

**ä¼ ç»Ÿæ–¹å¼çš„é—®é¢˜**ï¼š

```
ä¼šè¯åˆ—è¡¨ï¼š
- æ–°çš„èŠå¤©
- æ–°çš„èŠå¤© (1)
- æ–°çš„èŠå¤© (2)
- æ–°çš„èŠå¤© (3)
```

ç”¨æˆ·æ— æ³•å¿«é€Ÿæ‰¾åˆ°å†å²ä¼šè¯ã€‚

**è‡ªåŠ¨ç”Ÿæˆæ ‡é¢˜å**ï¼š

```
ä¼šè¯åˆ—è¡¨ï¼š
- ç‰™è†äº§å“å›¾è®¾è®¡
- å“ç‰Œ Logo ç”Ÿæˆ
- æµ·æŠ¥æ’ç‰ˆä¼˜åŒ–
- ...
```

ç”¨æˆ·å¯ä»¥ä¸€çœ¼çœ‹å‡ºæ¯ä¸ªä¼šè¯çš„ä¸»é¢˜ã€‚

### 1.2 è®¾è®¡åŸåˆ™

**1. å¼‚æ­¥éé˜»å¡**

æ ‡é¢˜ç”Ÿæˆä¸åº”è¯¥é˜»å¡ä¸»å¯¹è¯æµç¨‹ã€‚

```python
ç”¨æˆ·ï¼šç”Ÿæˆå›¾ç‰‡
  â†“
Agentï¼š[ç«‹å³å“åº”] å¼€å§‹ç”Ÿæˆ...
  â†“
[åå°å¼‚æ­¥] ç”Ÿæˆä¼šè¯æ ‡é¢˜
```

**2. è½»é‡çº§å®ç°**

åŸºäºæœåŠ¡å†…éƒ¨é˜Ÿåˆ—ï¼Œæ— éœ€é¢å¤–æœåŠ¡ã€‚

```python
# ä½¿ç”¨ Python çš„ Queue
import queue
import threading

title_queue = queue.Queue()

# Worker çº¿ç¨‹
def title_generation_worker():
    while True:
        task = title_queue.get()
        generate_title(task)
        title_queue.task_done()

# å¯åŠ¨ Worker
threading.Thread(target=title_generation_worker, daemon=True).start()
```

**3. æ™ºèƒ½è§¦å‘**

ä»…åœ¨æ–°ä¼šè¯æ—¶è§¦å‘ã€‚

```python
def should_generate_title(thread_id: str) -> bool:
    """åˆ¤æ–­æ˜¯å¦éœ€è¦ç”Ÿæˆæ ‡é¢˜"""
    
    # 1. æ£€æŸ¥æ˜¯å¦å·²æœ‰æ ‡é¢˜
    if has_title(thread_id):
        return False
    
    # 2. æ£€æŸ¥æ¶ˆæ¯æ•°é‡ï¼ˆåªæœ‰é¦–æ¬¡å¯¹è¯åæ‰ç”Ÿæˆï¼‰
    message_count = count_messages(thread_id)
    return message_count == 2  # user + assistant
```

**4. å®¹é”™æ€§å¼º**

ç”Ÿæˆå¤±è´¥ä¸å½±å“æ­£å¸¸å¯¹è¯ã€‚

```python
try:
    title = await generate_title_with_llm(context)
except Exception as e:
    logger.error(f"Title generation failed: {e}")
    # é™çº§ï¼šä½¿ç”¨ç”¨æˆ·è¾“å…¥çš„å‰ 10 ä¸ªå­—
    title = user_query[:10] + "..."
```

### 1.3 å®Œæ•´æµç¨‹

```mermaid
sequenceDiagram
    participant User
    participant Agent
    participant Queue as Title Queue
    participant Worker
    participant LLM
    participant DB

    User->>Agent: å‘é€ç¬¬ä¸€æ¡æ¶ˆæ¯
    Agent->>Agent: ç”Ÿæˆå›å¤
    Agent-->>User: è¿”å›å›å¤
    
    Agent->>Agent: æ£€æŸ¥æ˜¯å¦ä¸ºæ–°ä¼šè¯
    Agent->>Queue: åŠ å…¥æ ‡é¢˜ç”Ÿæˆä»»åŠ¡
    
    Note over Worker: å¼‚æ­¥æ‰§è¡Œ
    
    Worker->>Queue: è·å–ä»»åŠ¡
    Worker->>LLM: è°ƒç”¨ LLM ç”Ÿæˆæ ‡é¢˜
    
    alt æˆåŠŸ
        LLM-->>Worker: è¿”å›æ ‡é¢˜
        Worker->>DB: ä¿å­˜æ ‡é¢˜
    else å¤±è´¥
        Worker->>Worker: ä½¿ç”¨é™çº§ç­–ç•¥
        Worker->>DB: ä¿å­˜é™çº§æ ‡é¢˜
    end
```

### 1.4 å®ç°ä»£ç 

**æ ‡é¢˜ç”Ÿæˆä»»åŠ¡**ï¼š

```python
from dataclasses import dataclass
from typing import Optional

@dataclass
class TitleGenerationTask:
    """æ ‡é¢˜ç”Ÿæˆä»»åŠ¡"""
    thread_id: str
    user_query: str
    assistant_response: str
    created_at: datetime


class TitleGenerator:
    """æ ‡é¢˜ç”Ÿæˆå™¨"""
    
    def __init__(self, llm_client, db):
        self.llm = llm_client
        self.db = db
        self.queue = queue.Queue()
        self._start_worker()
    
    def _start_worker(self):
        """å¯åŠ¨ Worker çº¿ç¨‹"""
        def worker():
            while True:
                try:
                    task = self.queue.get(timeout=1)
                    self._process_task(task)
                except queue.Empty:
                    continue
                except Exception as e:
                    logger.error(f"Worker error: {e}")
        
        thread = threading.Thread(target=worker, daemon=True)
        thread.start()
    
    def enqueue(self, task: TitleGenerationTask):
        """åŠ å…¥é˜Ÿåˆ—"""
        self.queue.put(task)
    
    def _process_task(self, task: TitleGenerationTask):
        """å¤„ç†ä»»åŠ¡"""
        try:
            # 1. è°ƒç”¨ LLM ç”Ÿæˆæ ‡é¢˜
            title = self._generate_with_llm(task)
        
        except Exception as e:
            logger.warning(f"LLM title generation failed: {e}")
            # 2. é™çº§ç­–ç•¥
            title = self._fallback_title(task)
        
        # 3. ä¿å­˜åˆ°æ•°æ®åº“
        self._save_title(task.thread_id, title)
    
    def _generate_with_llm(self, task: TitleGenerationTask) -> str:
        """ä½¿ç”¨ LLM ç”Ÿæˆæ ‡é¢˜"""
        
        prompt = f"""æ ¹æ®ä»¥ä¸‹å¯¹è¯ï¼Œç”Ÿæˆä¸€ä¸ªç®€çŸ­çš„æ ‡é¢˜ï¼ˆä¸è¶…è¿‡ 15 ä¸ªå­—ï¼‰ã€‚

ç”¨æˆ·ï¼š{task.user_query}
åŠ©æ‰‹ï¼š{task.assistant_response}

æ ‡é¢˜ï¼š"""
        
        response = self.llm.complete(
            messages=[{"role": "user", "content": prompt}],
            max_tokens=30,
            temperature=0.7
        )
        
        title = response.strip()
        
        # é™åˆ¶é•¿åº¦
        if len(title) > 15:
            title = title[:15] + "..."
        
        return title
    
    def _fallback_title(self, task: TitleGenerationTask) -> str:
        """é™çº§ç­–ç•¥"""
        # ä½¿ç”¨ç”¨æˆ·è¾“å…¥çš„å‰ 10 ä¸ªå­—
        return task.user_query[:10] + ("..." if len(task.user_query) > 10 else "")
    
    def _save_title(self, thread_id: str, title: str):
        """ä¿å­˜æ ‡é¢˜"""
        self.db.execute(
            "UPDATE threads SET title = ? WHERE thread_id = ?",
            (title, thread_id)
        )
```

**é›†æˆåˆ° Agent**ï¼š

```python
class AgentService:
    def __init__(self):
        self.title_generator = TitleGenerator(llm_client, db)
    
    async def chat(self, user_input: str, thread_id: str):
        """èŠå¤©æ¥å£"""
        
        # 1. å¤„ç†ç”¨æˆ·æ¶ˆæ¯
        response = await self.process_message(user_input, thread_id)
        
        # 2. æ£€æŸ¥æ˜¯å¦éœ€è¦ç”Ÿæˆæ ‡é¢˜
        if self._should_generate_title(thread_id):
            # 3. å¼‚æ­¥ç”Ÿæˆæ ‡é¢˜
            task = TitleGenerationTask(
                thread_id=thread_id,
                user_query=user_input,
                assistant_response=response,
                created_at=datetime.now()
            )
            self.title_generator.enqueue(task)
        
        return response
    
    def _should_generate_title(self, thread_id: str) -> bool:
        """åˆ¤æ–­æ˜¯å¦éœ€è¦ç”Ÿæˆæ ‡é¢˜"""
        # æ£€æŸ¥æ˜¯å¦å·²æœ‰æ ‡é¢˜
        thread = self.db.get_thread(thread_id)
        if thread and thread.title:
            return False
        
        # æ£€æŸ¥æ¶ˆæ¯æ•°é‡
        message_count = self.db.count_messages(thread_id)
        return message_count == 2
```

### 1.5 æ•°æ®åº“è®¾è®¡

```sql
-- threads è¡¨
CREATE TABLE threads (
    thread_id VARCHAR(100) PRIMARY KEY,
    user_id VARCHAR(100) NOT NULL,
    title VARCHAR(255),  -- ä¼šè¯æ ‡é¢˜
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_user_id (user_id),
    INDEX idx_created_at (created_at)
);

-- æˆ–è€…å•ç‹¬çš„ metadata è¡¨
CREATE TABLE thread_metadata (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    thread_id VARCHAR(100) NOT NULL,
    key VARCHAR(100) NOT NULL,
    value TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE KEY uk_thread_key (thread_id, key),
    INDEX idx_thread_id (thread_id)
);

-- å­˜å‚¨æ ‡é¢˜
INSERT INTO thread_metadata (thread_id, key, value)
VALUES ('thread_123', 'title', 'ç‰™è†äº§å“å›¾è®¾è®¡')
ON DUPLICATE KEY UPDATE value = VALUES(value);
```

---

## äºŒã€å…¶ä»–ä¸šåŠ¡åŠŸèƒ½

### 2.1 æŠ€èƒ½ï¼ˆSkillï¼‰ç®¡ç†

**æŠ€èƒ½çš„æœ¬è´¨**ï¼šé¢„å®šä¹‰çš„å·¥å…·é›†åˆ + System Prompt

```python
@dataclass
class Skill:
    """æŠ€èƒ½å®šä¹‰"""
    skill_id: int
    name: str
    description: str
    system_prompt: str
    available_tools: List[str]
    icon: str


# ç¤ºä¾‹æŠ€èƒ½
SKILLS = {
    1: Skill(
        skill_id=1,
        name="é€šç”¨åŠ©æ‰‹",
        description="å¯ä»¥å›ç­”å„ç§é—®é¢˜ï¼Œè¿›è¡Œå¯¹è¯",
        system_prompt="ä½ æ˜¯ä¸€ä¸ªé€šç”¨åŠ©æ‰‹...",
        available_tools=[],
        icon="ğŸ’¬"
    ),
    2: Skill(
        skill_id=2,
        name="å›¾åƒç”Ÿæˆ",
        description="æ ¹æ®æè¿°ç”Ÿæˆå›¾ç‰‡",
        system_prompt="ä½ æ˜¯ä¸€ä¸ªå›¾åƒç”ŸæˆåŠ©æ‰‹ï¼Œæ“…é•¿ç†è§£ç”¨æˆ·éœ€æ±‚å¹¶ç”Ÿæˆå›¾ç‰‡...",
        available_tools=["é€šç”¨", "AIä¿®å›¾", "å›¾ç‰‡ç¼–è¾‘"],
        icon="ğŸ¨"
    ),
    3: Skill(
        skill_id=3,
        name="è§†é¢‘ç”Ÿæˆ",
        description="ç”ŸæˆçŸ­è§†é¢‘",
        system_prompt="ä½ æ˜¯ä¸€ä¸ªè§†é¢‘ç”ŸæˆåŠ©æ‰‹...",
        available_tools=["è§†é¢‘ç”Ÿæˆ", "è§†é¢‘ç¼–è¾‘"],
        icon="ğŸ¬"
    )
}


def get_skill_config(skill_id: int) -> Skill:
    """è·å–æŠ€èƒ½é…ç½®"""
    return SKILLS.get(skill_id, SKILLS[1])  # é»˜è®¤é€šç”¨åŠ©æ‰‹
```

**åœ¨ Agent ä¸­ä½¿ç”¨æŠ€èƒ½**ï¼š

```python
async def chat(self, user_input: str, thread_id: str, skill_id: int = 1):
    """èŠå¤©æ¥å£"""
    
    # 1. è·å–æŠ€èƒ½é…ç½®
    skill = get_skill_config(skill_id)
    
    # 2. æ„é€  System Prompt
    system_prompt = skill.system_prompt
    
    # 3. è·å–å¯ç”¨å·¥å…·
    available_tools = [
        tool_registry.get(tool_name)
        for tool_name in skill.available_tools
    ]
    
    # 4. æ‰§è¡Œ Agent
    result = await agent.run(
        user_input=user_input,
        thread_id=thread_id,
        system_prompt=system_prompt,
        tools=available_tools
    )
    
    return result
```

### 2.2 é™„ä»¶å¤„ç†

**æ”¯æŒçš„é™„ä»¶ç±»å‹**ï¼š
- å›¾ç‰‡ï¼šç”¨äºå›¾ç”Ÿå›¾ã€å›¾ç‰‡ç¼–è¾‘
- æ–‡ä»¶ï¼šç”¨äºæ–‡æ¡£ç†è§£ã€æ•°æ®åˆ†æ

**é™„ä»¶æ•°æ®ç»“æ„**ï¼š

```python
@dataclass
class Attachment:
    """é™„ä»¶"""
    attachment_id: str
    type: str  # "image", "file"
    url: str
    file_name: str
    file_size: int
    mime_type: str


# åœ¨æ¶ˆæ¯ä¸­æºå¸¦é™„ä»¶
{
    "role": "user",
    "content": {
        "type": "plain",
        "text": "å¸®æˆ‘ä¿®è¿™å¼ å›¾"
    },
    "attachments": [
        {
            "attachment_id": "att_123",
            "type": "image",
            "url": "https://cdn.gaoding.com/xxx.jpg",
            "file_name": "åŸå›¾.jpg",
            "file_size": 102400,
            "mime_type": "image/jpeg"
        }
    ]
}
```

**åœ¨å·¥å…·ä¸­ä½¿ç”¨é™„ä»¶**ï¼š

```python
class ImageEditTool(Tool):
    """å›¾ç‰‡ç¼–è¾‘å·¥å…·"""
    
    async def execute(
        self,
        user_prompt: str,
        attachments: List[Attachment],
        **kwargs
    ) -> Dict:
        """æ‰§è¡Œå›¾ç‰‡ç¼–è¾‘"""
        
        # 1. æ£€æŸ¥æ˜¯å¦æœ‰å›¾ç‰‡é™„ä»¶
        image_attachments = [
            att for att in attachments
            if att.type == "image"
        ]
        
        if not image_attachments:
            return {
                "tool_name": self.name,
                "result": "failed",
                "error": "no_image",
                "message": "è¯·ä¸Šä¼ å›¾ç‰‡"
            }
        
        # 2. è°ƒç”¨å›¾ç‰‡ç¼–è¾‘æœåŠ¡
        original_image_url = image_attachments[0].url
        edited_image_url = await edit_image_service.edit(
            image_url=original_image_url,
            prompt=user_prompt
        )
        
        # 3. è¿”å›ç»“æœ
        return {
            "tool_name": self.name,
            "result": "success",
            "original_image_url": original_image_url,
            "edited_image_url": edited_image_url
        }
```

---

## ä¸‰ã€æ€»ç»“

### 3.1 ä¸šåŠ¡åŠŸèƒ½è®¾è®¡åŸåˆ™

**DOï¼š**
- âœ… å¼‚æ­¥éé˜»å¡ï¼ˆä¸å½±å“ä¸»æµç¨‹ï¼‰
- âœ… å®¹é”™æ€§å¼ºï¼ˆé™çº§ç­–ç•¥ï¼‰
- âœ… è½»é‡çº§å®ç°ï¼ˆé¿å…è¿‡åº¦è®¾è®¡ï¼‰
- âœ… ç”¨æˆ·ä½“éªŒä¼˜å…ˆ

**DON'Tï¼š**
- âŒ é˜»å¡ä¸»æµç¨‹
- âŒ æ²¡æœ‰é™çº§æ–¹æ¡ˆ
- âŒ è¿‡åº¦ä¾èµ–å¤–éƒ¨æœåŠ¡
- âŒ å¿½ç•¥è¾¹ç•Œæƒ…å†µ

### 3.2 å…³é”®å®ç°

- âœ… å¼‚æ­¥é˜Ÿåˆ— + Worker çº¿ç¨‹
- âœ… LLM ç”Ÿæˆ + é™çº§ç­–ç•¥
- âœ… æŠ€èƒ½ç®¡ç†
- âœ… é™„ä»¶å¤„ç†

---

*æ–‡æ¡£ç‰ˆæœ¬ï¼šv1.0*  
*æœ€åæ›´æ–°ï¼š2026-01-26*

**ä¸Šä¸€ç¯‡**ï¼š[â† ä¸­æ–­ä¸æ¢å¤](06-ä¸­æ–­ä¸æ¢å¤.md) | **ä¸‹ä¸€ç¯‡**ï¼š[å¯è§‚æµ‹æ€§ â†’](08-å¯è§‚æµ‹æ€§.md)
