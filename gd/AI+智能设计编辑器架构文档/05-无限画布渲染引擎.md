# 05 - 无限画布渲染引擎

> **导航**：[📚 返回总目录](./README.md) | [⬅️ 上一篇：扩展插件系统](./04-扩展插件系统.md) | [➡️ 下一篇：AI对话系统核心技术](./06-AI对话系统核心技术.md)
>
> **所属**：AI+ 智能设计编辑器架构文档

---

## 5.1 为什么需要"无限画布"？

**传统 DOM 渲染的瓶颈**：

```
场景：用户生成了 1000 张 AI 图片
  ├─ DOM 方案：创建 1000 个 <img> 元素
  ├─ 问题1：DOM 节点过多，浏览器卡顿
  ├─ 问题2：滚动和缩放性能差
  └─ 问题3：内存占用过高

结果：页面崩溃 💥
```

**PixiJS (WebGL) 方案**：

```
同样 1000 张图片：
  ├─ 只创建可见区域的渲染对象（如 50 个）
  ├─ 其他对象按需创建/销毁
  ├─ WebGL 硬件加速，60fps 流畅
  └─ 支持无限滚动、缩放

结果：丝般顺滑 ✨
```

---

## 5.2 渲染架构 - 三层结构

```
┌───────────────────────────────────────────────────────┐
│  Surface（画布表面）                                    │
│  ─────────────────────────────────────────────────   │
│  • 最顶层管理者                                        │
│  • 协调下层组件工作                                    │
│  • 控制渲染循环（Ticker：16ms/帧）                     │
└───────────────────────────────────────────────────────┘
              ↓              ↓              ↓
    ┌─────────────┐  ┌─────────────┐  ┌─────────────┐
    │  Viewport   │  │ Processor   │  │ PluginSystem│
    │  (视口)      │  │  (处理器)    │  │  (插件)     │
    └─────────────┘  └─────────────┘  └─────────────┘
```

**各层职责**：

```
1️⃣ Viewport（视口层）
  ├─ 管理相机（Camera）
  │   ├─ 缩放（Zoom）：0.1x ~ 10x
  │   ├─ 平移（Pan）：拖拽画布移动
  │   └─ 旋转（Rotate）：支持画布旋转
  ├─ 坐标转换
  │   ├─ 屏幕坐标 ⇄ 画布坐标
  │   └─ 处理鼠标/触摸事件的坐标映射
  └─ 碰撞检测
      └─ 判断点击是否命中元素

2️⃣ Processor（处理器层）
  ├─ VmEngine（视图模型引擎）
  │   ├─ 数据模型 → PixiJS 渲染对象
  │   ├─ 虚拟化渲染（只渲染可见元素）
  │   └─ 增量更新（只更新变化部分）
  └─ EventBoundary（事件边界）
      └─ 事件分发和冒泡处理

3️⃣ PluginSystem（插件层）
  ├─ BackgroundPlugin（背景）
  │   └─ 渲染背景色/图片/渐变
  ├─ GridPlugin（网格）
  │   └─ 显示辅助网格线
  ├─ SelectionPlugin（选择）
  │   └─ 选中框、控制点
  └─ GuidePlugin（参考线）
      └─ 对齐辅助线
```

---

## 5.3 虚拟化渲染 - 核心优化

**核心思想**：只渲染用户能看到的，看不到的不渲染。

```
全量渲染（慢）：
  画布上有 10000 个元素
  → 创建 10000 个 PixiJS 对象
  → 每帧都要处理 10000 个对象
  → 卡顿！

虚拟化渲染（快）：
  画布上有 10000 个元素
  → 只创建视口内的 50 个对象
  → 滚动时动态换入/换出对象
  → 流畅！
```

**实现机制**：

```
视口变化时（滚动/缩放）：
  1. 计算当前视口范围
  2. 找出视口内的元素列表
  3. 比对上次的列表：
     ├─ 新进入视口的 → 创建渲染对象
     ├─ 移出视口的 → 销毁渲染对象
     └─ 仍在视口的 → 更新位置/样式
  4. 渲染当前帧
```

---

## 5.4 性能优化策略

| 优化策略       | 具体实现                             | 性能提升          |
| -------------- | ------------------------------------ | ----------------- |
| **虚拟化渲染** | 只渲染视口内元素                     | 降低 90% CPU 占用 |
| **对象池复用** | 复用 PixiJS 对象，避免频繁创建/销毁  | 减少 GC 压力 70%  |
| **懒加载纹理** | 图片进入视口才加载，支持渐进式加载   | 节省 80% 内存     |
| **脏矩形检测** | 只重绘变化区域，而不是全画布         | 提升 3x 渲染速度  |
| **LOD分级**    | 缩小时显示低精度版本，放大时加载高清 | 优化缩放体验      |
| **WebGL加速**  | 硬件加速，GPU并行计算                | 支持万级元素流畅  |

---

> **下一步**：进入核心章节 [AI对话框系统](./06-AI对话系统核心技术.md)，了解产品的灵魂功能。
