# AI+ 智能设计编辑器架构文档

> **文档目标**：深入解析 AI+ 编辑器的核心架构、设计思想与业务流程，帮助开发者快速理解系统设计
>
> **适合人群**：前端架构师、高级开发工程师、技术 Leader

---

## 一、产品全景

### 1.1 产品定位与核心价值

AI+ 智能设计编辑器是一款**革新设计创作方式**的在线工具，通过**自然语言对话**降低设计门槛，让非专业用户也能快速完成专业级设计。

**核心价值主张**：

```
传统方式：学习工具 → 选择模板 → 手动调整 → 反复修改
AI+ 方式：描述需求 → AI 生成 → 实时预览 → 一键应用
```

**差异化特性**：

- 🤖 **对话式交互**：告别复杂工具栏，用说话的方式完成设计
- ⚡ **实时生成**：SSE 流式响应，秒级反馈，无需等待
- 🎯 **智能理解**：理解上下文，支持连续对话式编辑
- 🧩 **高度扩展**：插件化架构，AI 能力持续迭代升级
- 🌍 **全球化部署**：国内/国际双版本，适配不同市场

### 1.2 技术架构选型背景

**为什么选择这些技术？**

| 技术选型       | 选择理由                   | 解决的问题                 |
| -------------- | -------------------------- | -------------------------- |
| **Vue 2.7**    | 向后兼容 + Composition API | 渐进式升级，保护现有投资   |
| **TypeScript** | 类型安全 + 代码提示        | 降低维护成本，提升开发效率 |
| **PixiJS**     | WebGL 高性能渲染           | 支持大规模元素、流畅交互   |
| **Pinia**      | 轻量级状态管理             | 替代 Vuex，更好的 TS 支持  |
| **SSE**        | 服务端推送                 | 实现流式 AI 响应，优于轮询 |
| **Vite**       | 快速构建 + HMR             | 开发体验提升 10 倍         |

---

## 二、整体架构设计

### 2.1 分层架构 - 自上而下的设计思想

系统采用**经典的五层架构**，每一层职责清晰、边界明确，便于团队协作和长期维护。

```
┌──────────────────────────────────────────────────────────────┐
│  📱 应用层 (Apps Layer)                                        │
│  ├─ design-ai-plus (国内版)      ← 面向中国用户              │
│  └─ insmind-ai-plus (国际版)     ← 面向海外用户              │
│  职责：环境配置、登录方式、多语言、支付对接                      │
└──────────────────────────────────────────────────────────────┘
                              ↓
┌──────────────────────────────────────────────────────────────┐
│  🎨 业务层 (Business Layer)                                   │
│  ├─ AI 聊天面板              ← 核心交互入口                   │
│  ├─ 工具栏 & 属性面板        ← 传统编辑能力                   │
│  ├─ 历史记录 & 模板库        ← 内容管理                       │
│  └─ 协同 & 分享             ← 社交功能                        │
│  职责：业务功能实现、用户交互界面、产品差异化                    │
└──────────────────────────────────────────────────────────────┘
                              ↓
┌──────────────────────────────────────────────────────────────┐
│  🏗️ 基座层 (Foundation Layer)                                │
│  @design/design-foundation                                   │
│  ├─ 初始化系统 (installDesign)  ← 统一入口                   │
│  ├─ 配置管理                     ← API/权限/扩展              │
│  ├─ 生命周期管理                 ← 启动/销毁                  │
│  └─ 路由 & 状态管理             ← 全局状态                    │
│  职责：提供标准化的编辑器基础设施，屏蔽底层复杂度                │
└──────────────────────────────────────────────────────────────┘
                              ↓
┌──────────────────────────────────────────────────────────────┐
│  ⚙️ 引擎层 (Engine Layer)                                     │
│  @editor/framework                                           │
│  ├─ 数据模型 (Data Model)       ← 元素/页面/模板             │
│  ├─ 命令系统 (Command)          ← 撤销/重做                  │
│  ├─ 事件系统 (Event Bus)        ← 跨模块通信                 │
│  └─ 插件系统 (Plugin)           ← 能力扩展                   │
│  职责：编辑器核心能力抽象，不依赖具体业务                        │
└──────────────────────────────────────────────────────────────┘
                              ↓
┌──────────────────────────────────────────────────────────────┐
│  🖼️ 渲染层 (Render Layer)                                     │
│  @editor/infinite-renderer (基于 PixiJS)                     │
│  ├─ 无限画布 (Infinite Canvas)  ← 无限滚动                   │
│  ├─ 视口管理 (Viewport)         ← 缩放/平移                  │
│  ├─ 虚拟化渲染                   ← 性能优化                   │
│  └─ WebGL 加速                  ← 硬件加速                   │
│  职责：高性能图形渲染，支持大规模元素流畅操作                    │
└──────────────────────────────────────────────────────────────┘
```

**为什么要分层？**

1. **职责清晰**：每层只关注自己的问题，降低复杂度
2. **解耦合**：上层依赖下层，下层不知道上层，便于替换和测试
3. **可扩展**：新增功能只需在对应层实现，不影响其他层
4. **团队协作**：不同团队负责不同层，并行开发互不阻塞

### 2.2 三大核心设计理念

#### **理念 1：基座化（Foundation-Based）** 🏗️

**问题**：多个应用（国内版、国际版、移动版）重复实现编辑器初始化逻辑，维护成本高。

**解决方案**：抽象出统一的"基座"，提供标准化的初始化流程。

```
传统方式（每个应用独立实现）：
  App A：自己初始化 Vue → 自己配置路由 → 自己注册插件 → 自己挂载
  App B：自己初始化 Vue → 自己配置路由 → 自己注册插件 → 自己挂载
  App C：...

基座化方式（统一入口）：
  所有应用：调用 installDesign(config) → 基座自动完成所有初始化
```

**核心价值**：

- ✅ 减少 80% 的初始化代码
- ✅ 统一配置标准，避免遗漏
- ✅ 一处升级，所有应用受益

#### **理念 2：插件化（Plugin-Based）** 🧩

**问题**：功能越来越多，代码耦合严重，牵一发动全身。

**解决方案**：将功能模块拆分为独立的插件，按需加载。

```
核心思想：
  编辑器内核（最小可运行） + N 个插件（可选功能）

  基础版 = 内核                         （画布 + 基础编辑）
  标准版 = 内核 + AI 插件                （+ AI 生成）
  企业版 = 内核 + AI + 协同 + 品牌插件    （+ 团队协作）
```

**插件生命周期**：

```
加载阶段 → 注册阶段 → 启动阶段 → 运行阶段 → 卸载阶段
(Load)    (Register)  (Bootstrap) (Run)     (Unmount)
```

**核心价值**：

- ✅ 按需加载，减少首屏体积
- ✅ 功能隔离，互不影响
- ✅ 独立开发，独立部署

#### **理念 3：事件驱动（Event-Driven）** 📡

**问题**：模块间直接调用，形成强依赖，难以扩展和测试。

**解决方案**：通过事件总线解耦模块间通信。

```
传统方式（直接调用）：
  ChatPanel → 直接调用 → CanvasEditor.addImage()
  问题：ChatPanel 必须知道 CanvasEditor 的存在和接口

事件驱动方式：
  ChatPanel → 发布事件 → eventBus.emit('addImage', data)
  CanvasEditor → 订阅事件 → eventBus.on('addImage', handler)
  优势：两个模块不需要互相引用
```

**核心价值**：

- ✅ 模块解耦，易于扩展
- ✅ 支持一对多通信
- ✅ 便于埋点和调试

---

## 三、编辑器基座 - 万丈高楼的地基

### 3.1 基座的设计哲学

**核心思想**：把复杂的初始化流程封装成一行代码。

```javascript
// 应用层只需要这一行！
await installDesign('#app', config);
```

**背后发生了什么？**（7步标准化流程）

```
第1步：环境初始化
  ├─ 设置 API 域名（国内/国外）
  ├─ 注入环境变量（HOME_PAGE, REGION...）
  └─ 配置 OSS/CDN

第2步：API 服务初始化
  ├─ 创建 HTTP 客户端
  ├─ 配置拦截器（鉴权、错误处理）
  └─ 注册业务 API（用户、模板、AI...）

第3步：权限系统初始化
  ├─ 加载权限配置
  ├─ 初始化权限控制器
  └─ 设置功能开关（哪些能力可用）

第4步：创建 Vue 应用
  ├─ 创建 Vue 实例
  ├─ 注册 Pinia（状态管理）
  ├─ 注册 Router（路由）
  └─ 注册全局组件

第5步：插件注册
  ├─ 加载扩展配置（extensionConfig）
  ├─ 依次注册每个插件
  └─ 调用插件的 register 钩子

第6步：日志服务初始化
  ├─ 配置日志上报（SLS）
  ├─ 设置错误监控
  └─ 初始化埋点系统

第7步：编辑器挂载
  ├─ 渲染编辑器组件
  ├─ 初始化画布
  ├─ 触发 mounted 生命周期
  └─ 完成启动 ✅
```

**为什么这样设计？**

- 保证初始化顺序（有些服务依赖其他服务）
- 统一错误处理（任一步失败都能优雅降级）
- 便于扩展（新增服务只需插入对应步骤）

### 3.2 国内版 vs 国际版 - 多租户架构实践

两个版本**共享 95% 的代码**，只有这些地方不同：

| 差异维度   | design-ai-plus (国内)  | insmind-ai-plus (国际)  | 实现方式                  |
| ---------- | ---------------------- | ----------------------- | ------------------------- |
| **登录**   | 手机号 + 短信验证码    | Google OAuth 2.0        | 配置 `env.LOGIN_TYPE`     |
| **API**    | https://api.huaban.com | https://api.insmind.com | 配置 `env.API_BASE_URL`   |
| **存储**   | 阿里云 OSS             | AWS S3                  | 配置 `env.STORAGE_TYPE`   |
| **CDN**    | 国内 CDN               | Cloudflare              | 配置 `env.CDN_DOMAIN`     |
| **AI服务** | 国内部署模型           | 海外部署模型            | 配置 `env.AI_SERVICE_URL` |
| **支付**   | 支付宝 + 微信支付      | Stripe                  | 配置 `env.PAYMENT_TYPE`   |
| **语言**   | 中文优先               | 英文优先                | 配置 `env.DEFAULT_LOCALE` |

**多租户架构的关键**：

```
核心原则：通过配置驱动差异，而不是代码分支

错误示范：
  if (isChina) {
    useAlipay();
  } else {
    useStripe();
  }

正确做法：
  const PaymentProvider = config.paymentType; // 动态注入
  PaymentProvider.pay(amount);
```

**配置管理**：

```
/apps/design-ai-plus/src/configs/
  ├── env.ts          ← 环境配置（API域名、登录方式...）
  ├── apis.ts         ← API端点配置
  └── extensions.ts   ← 插件配置（哪些插件启用）

/apps/insmind-ai-plus/src/configs/
  ├── env.ts          ← 不同的环境配置
  ├── apis.ts         ← 不同的API端点
  └── extensions.ts   ← 不同的插件配置
```

---

## 四、扩展插件系统 - 可持续进化的关键

### 4.1 为什么需要插件系统？

**场景痛点**：

```
产品需求不断变化：
  ├─ 今天要加 AI 绘图
  ├─ 明天要加视频生成
  ├─ 后天要加协同编辑
  └─ 每次都改核心代码？❌

如果没有插件系统：
  ├─ 核心代码越来越臃肿
  ├─ 功能耦合严重，改一处影响全局
  ├─ 无法按需加载，首屏体积爆炸
  └─ 团队协作困难，互相阻塞
```

**插件化解决方案**：

```
编辑器核心（稳定）
  ↓
通过插件系统扩展（灵活）
  ├─ AI 插件       ← 团队A开发
  ├─ 上传插件      ← 团队B开发
  ├─ 协同插件      ← 团队C开发
  └─ 自定义插件    ← 客户自己开发
```

### 4.2 插件生命周期管理

插件从加载到销毁经历 **5 个阶段**：

```
┌─────────────────────────────────────────────────────────┐
│  1️⃣ Load（加载）                                          │
│  ────────────────────────────────────────────────────   │
│  • 解析插件配置（manifest）                               │
│  • 检查依赖关系                                           │
│  • 动态 import 插件代码                                   │
│  • 创建插件实例                                           │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  2️⃣ Register（注册）                                      │
│  ────────────────────────────────────────────────────   │
│  • 注册 Vue 组件                                          │
│  • 注册路由                                               │
│  • 注册全局指令/过滤器                                     │
│  • 注册编辑器命令                                         │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  3️⃣ Bootstrap（启动）                                     │
│  ────────────────────────────────────────────────────   │
│  • 初始化插件服务                                         │
│  • 建立网络连接                                           │
│  • 加载初始数据                                           │
│  • 注册事件监听                                           │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  4️⃣ Run（运行）                                           │
│  ────────────────────────────────────────────────────   │
│  • 插件功能正常工作                                        │
│  • 响应用户操作                                           │
│  • 与其他插件协作                                         │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  5️⃣ Unmount（卸载）                                       │
│  ────────────────────────────────────────────────────   │
│  • 移除事件监听                                           │
│  • 清理定时器/连接                                        │
│  • 释放内存资源                                           │
│  • 注销组件和命令                                         │
└─────────────────────────────────────────────────────────┘
```

**关键设计**：ExtensionManager 统一管理所有插件的生命周期。

### 4.3 插件配置与加载机制

**插件配置的三种方式**：

```javascript
// 方式1：直接传入对象
defineExtensionConfig({
  manifest: { id: 'ai', version: '1.0.0' },
});

// 方式2：异步加载（推荐，支持代码分割）
defineExtensionConfig(() => import('@design/extension-ai'));

// 方式3：带参数配置
defineExtensionConfig([
  import('@design/extension-ai'),
  { apiKey: 'xxx', model: 'gpt-4' }, // 插件参数
]);
```

**按需加载策略**：

```
首屏必需插件（同步加载）：
  ├─ 基础编辑插件（选择、拖拽、缩放...）
  └─ AI 聊天插件（核心功能）

懒加载插件（用户触发时加载）：
  ├─ 图像编辑插件 ← 点击"AI改图"时加载
  ├─ 批量设计插件 ← 打开批量面板时加载
  └─ 协同插件 ← 进入协作模式时加载
```

### 4.4 典型插件分类与职责

| 类别         | 插件示例                    | 核心职责                   |
| ------------ | --------------------------- | -------------------------- |
| **AI能力**   | extension-ai                | AI 图片/视频生成、智能编辑 |
|              | extension-image-edit        | 改图、扩图、消除、抠图     |
| **素材管理** | extension-upload            | 文件上传、素材管理         |
|              | extension-material-importer | 批量导入外部素材           |
| **效率工具** | extension-batch-design      | 批量生成、数据填充         |
|              | extension-auto-layout       | 智能布局、自动对齐         |
| **协作**     | extension-team-panel        | 团队管理、权限控制         |
|              | extension-comment           | 评论、标注、审批           |
| **UI增强**   | extension-my-panel          | 我的作品、收藏、历史       |
|              | extension-template-market   | 模板市场、灵感广场         |

---

## 五、无限画布渲染引擎 - 支撑万级元素的基石

### 5.1 为什么需要"无限画布"？

**传统 DOM 渲染的瓶颈**：

```
场景：用户生成了 1000 张 AI 图片
  ├─ DOM 方案：创建 1000 个 <img> 元素
  ├─ 问题1：DOM 节点过多，浏览器卡顿
  ├─ 问题2：滚动和缩放性能差
  └─ 问题3：内存占用过高

结果：页面崩溃 💥
```

**PixiJS (WebGL) 方案**：

```
同样 1000 张图片：
  ├─ 只创建可见区域的渲染对象（如 50 个）
  ├─ 其他对象按需创建/销毁
  ├─ WebGL 硬件加速，60fps 流畅
  └─ 支持无限滚动、缩放

结果：丝般顺滑 ✨
```

### 5.2 渲染架构 - 三层结构

```
┌───────────────────────────────────────────────────────┐
│  Surface（画布表面）                                    │
│  ─────────────────────────────────────────────────   │
│  • 最顶层管理者                                        │
│  • 协调下层组件工作                                    │
│  • 控制渲染循环（Ticker：16ms/帧）                     │
└───────────────────────────────────────────────────────┘
              ↓              ↓              ↓
    ┌─────────────┐  ┌─────────────┐  ┌─────────────┐
    │  Viewport   │  │ Processor   │  │ PluginSystem│
    │  (视口)      │  │  (处理器)    │  │  (插件)     │
    └─────────────┘  └─────────────┘  └─────────────┘
```

**各层职责**：

```
1️⃣ Viewport（视口层）
  ├─ 管理相机（Camera）
  │   ├─ 缩放（Zoom）：0.1x ~ 10x
  │   ├─ 平移（Pan）：拖拽画布移动
  │   └─ 旋转（Rotate）：支持画布旋转
  ├─ 坐标转换
  │   ├─ 屏幕坐标 ⇄ 画布坐标
  │   └─ 处理鼠标/触摸事件的坐标映射
  └─ 碰撞检测
      └─ 判断点击是否命中元素

2️⃣ Processor（处理器层）
  ├─ VmEngine（视图模型引擎）
  │   ├─ 数据模型 → PixiJS 渲染对象
  │   ├─ 虚拟化渲染（只渲染可见元素）
  │   └─ 增量更新（只更新变化部分）
  └─ EventBoundary（事件边界）
      └─ 事件分发和冒泡处理

3️⃣ PluginSystem（插件层）
  ├─ BackgroundPlugin（背景）
  │   └─ 渲染背景色/图片/渐变
  ├─ GridPlugin（网格）
  │   └─ 显示辅助网格线
  ├─ SelectionPlugin（选择）
  │   └─ 选中框、控制点
  └─ GuidePlugin（参考线）
      └─ 对齐辅助线
```

### 5.3 虚拟化渲染 - 核心优化

**核心思想**：只渲染用户能看到的，看不到的不渲染。

```
全量渲染（慢）：
  画布上有 10000 个元素
  → 创建 10000 个 PixiJS 对象
  → 每帧都要处理 10000 个对象
  → 卡顿！

虚拟化渲染（快）：
  画布上有 10000 个元素
  → 只创建视口内的 50 个对象
  → 滚动时动态换入/换出对象
  → 流畅！
```

**实现机制**：

```
视口变化时（滚动/缩放）：
  1. 计算当前视口范围
  2. 找出视口内的元素列表
  3. 比对上次的列表：
     ├─ 新进入视口的 → 创建渲染对象
     ├─ 移出视口的 → 销毁渲染对象
     └─ 仍在视口的 → 更新位置/样式
  4. 渲染当前帧
```

### 5.4 性能优化策略

| 优化策略       | 具体实现                             | 性能提升          |
| -------------- | ------------------------------------ | ----------------- |
| **虚拟化渲染** | 只渲染视口内元素                     | 降低 90% CPU 占用 |
| **对象池复用** | 复用 PixiJS 对象，避免频繁创建/销毁  | 减少 GC 压力 70%  |
| **懒加载纹理** | 图片进入视口才加载，支持渐进式加载   | 节省 80% 内存     |
| **脏矩形检测** | 只重绘变化区域，而不是全画布         | 提升 3x 渲染速度  |
| **LOD分级**    | 缩小时显示低精度版本，放大时加载高清 | 优化缩放体验      |
| **WebGL加速**  | 硬件加速，GPU并行计算                | 支持万级元素流畅  |

---

## 六、AI 对话框系统 ⭐⭐⭐ 核心中的核心

> **为什么这是核心？** 这是整个产品的灵魂，是 AI 能力与用户交互的桥梁。

### 6.1 设计目标与挑战

**设计目标**：

```
✅ 实时响应：用户发送消息后，立即看到 AI 的思考过程
✅ 流畅体验：AI 生成内容时，用户可以继续操作画布
✅ 批量处理：一次对话可以生成多张图片，自动布局
✅ 错误容忍：网络中断、生成失败都能优雅降级
✅ 历史回放：查看过去的对话，重现生成过程
```

**技术挑战**：

```
❌ Challenge 1：如何实现流式响应？
   → 解决方案：SSE (Server-Sent Events)

❌ Challenge 2：AI 生成很慢（10-30秒），如何不让用户等待？
   → 解决方案：PlaceholderManager 占位元素

❌ Challenge 3：一次生成多张图，如何管理状态？
   → 解决方案：MessageHandler 的批量跟踪机制

❌ Challenge 4：生成失败了怎么办？
   → 解决方案：完善的错误处理和重试机制

❌ Challenge 5：如何支持各种 AI 能力（生成、编辑、改图...）？
   → 解决方案：ToolProcessor 统一工具处理
```

### 6.2 整体架构 - 四层结构

```
┌───────────────────────────────────────────────────────┐
│  🎨 UI 展示层                                          │
│  ─────────────────────────────────────────────────   │
│  ChatPanel (对话面板)                                  │
│    ├─ ChatHeader (标题栏：新建对话、历史记录)           │
│    ├─ MessageList (消息列表：用户消息、AI回复、工具调用) │
│    └─ ChatSender (输入框：技能选择、附件上传、参数设置)  │
└───────────────────────────────────────────────────────┘
                          ↓
┌───────────────────────────────────────────────────────┐
│  🔄 交互逻辑层                                          │
│  ─────────────────────────────────────────────────   │
│  ChatWrap (聊天容器)                                   │
│    ├─ 管理消息状态（messages[]）                        │
│    ├─ 处理用户输入事件                                  │
│    ├─ 协调各个服务                                     │
│    └─ 同步画布状态（currentElement）                    │
└───────────────────────────────────────────────────────┘
                          ↓
┌───────────────────────────────────────────────────────┐
│  ⚙️ 核心服务层                                         │
│  ─────────────────────────────────────────────────   │
│  ├─ SSEManager：管理与后端的 SSE 流式连接               │
│  ├─ MessageHandler：解析 AI 消息流，管理消息状态        │
│  ├─ ToolProcessor：处理 AI 工具调用，记录管理           │
│  └─ PlaceholderManager：管理占位元素，优化等待体验      │
└───────────────────────────────────────────────────────┘
                          ↓
┌───────────────────────────────────────────────────────┐
│  🖼️ 画布操作层                                         │
│  ─────────────────────────────────────────────────   │
│  ElementAddService：将 AI 生成结果添加到画布            │
│    ├─ addImageElement（添加图片）                      │
│    ├─ addTextElement（添加文本）                       │
│    ├─ replaceElement（替换元素）                       │
│    └─ adjustLayout（自动布局）                         │
└───────────────────────────────────────────────────────┘
```

**各层职责清单**：

| 层级       | 核心职责                             | 不负责的事情          |
| ---------- | ------------------------------------ | --------------------- |
| **UI层**   | 展示消息、接收用户输入、显示加载状态 | ❌ 不处理业务逻辑     |
| **交互层** | 管理状态、协调服务、处理事件         | ❌ 不直接操作 DOM     |
| **服务层** | 网络通信、数据处理、工具执行         | ❌ 不关心 UI 如何展示 |
| **画布层** | 操作编辑器、添加元素、布局优化       | ❌ 不知道消息从哪里来 |

### 6.3 对话流程全景 - 从输入到画布的奇妙旅程

让我们跟随一条消息，看它如何从用户的键盘变成画布上的设计作品。

#### **完整流程（7个关键阶段）**

```
👤 用户说："帮我生成一张春天的风景照，16:9的"

┌─────────────────────────────────────────────────────────┐
│  第1阶段：用户输入 📝                                      │
│  ─────────────────────────────────────────────────────  │
│  ChatSender 收集参数：                                    │
│    ├─ 技能（skill）: 'image' (图片生成)                  │
│    ├─ 提示词（prompt）: "春天的风景照"                    │
│    ├─ 比例（ratio）: '16:9'                             │
│    ├─ 风格（style）: 'realistic' (写实风格)              │
│    └─ 附件（attachments）: [] (无附件)                   │
│  点击发送 → 触发 submit 事件                              │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  第2阶段：消息构造 🛠️                                     │
│  ─────────────────────────────────────────────────────  │
│  构造用户消息对象：                                        │
│  {                                                       │
│    role: 'user',              // 用户消息                │
│    content: {                                            │
│      type: 'text',            // 文本类型                │
│      text: '春天的风景照'      // 用户输入               │
│    },                                                    │
│    metadata: {                // 元数据                  │
│      skill: 'image',                                     │
│      ratio: '16:9',                                      │
│      styleCode: 'realistic'                              │
│    }                                                     │
│  }                                                       │
│  添加到消息列表 messages.push(userMessage)                │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  第3阶段：SSE 连接 🌐                                     │
│  ─────────────────────────────────────────────────────  │
│  SSEManager 发起请求：                                    │
│    POST /api/ai/chat                                     │
│    Body: {                                               │
│      messages: [...historyMessages, userMessage],       │
│      conversationId: 'conv_xxx'   // 会话 ID             │
│    }                                                     │
│                                                          │
│  建立 SSE 流式连接：                                      │
│    ┌─ 后端开始处理                                       │
│    ├─ AI 模型推理中...                                   │
│    └─ 实时推送响应片段                                    │
│                                                          │
│  前端接收 SSE 流：                                        │
│    data: {"event":"message","role":"assistant",...}      │
│    data: {"event":"function_call",...}                   │
│    data: {"event":"function_response",...}               │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  第4阶段：消息解析 🔍                                     │
│  ─────────────────────────────────────────────────────  │
│  MessageHandler 解析 SSE 消息流：                         │
│                                                          │
│  ① 收到 function_call（工具调用）                        │
│     内容：{                                              │
│       name: "图片生成",                                  │
│       arguments: {                                       │
│         prompt: "春天的风景照",                          │
│         ratio: "16:9",                                   │
│         style: "realistic"                               │
│       }                                                  │
│     }                                                    │
│     → 记录工具调用                                        │
│     → 触发埋点：工具初始化                                 │
│                                                          │
│  ② 收到 function_response（工具结果）                    │
│     内容：{                                              │
│       toolType: "image",                                 │
│       result: {                                          │
│         uri: "https://cdn.com/generated-image.jpg"      │
│       },                                                 │
│       metadata: {                                        │
│         taskId: "task_xxx",                             │
│         query: "春天的风景照",                           │
│         width: 1920, height: 1080                       │
│       }                                                  │
│     }                                                    │
│     → 创建 Tool 对象                                      │
│     → 触发 addImage 事件                                  │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  第5阶段：占位管理 ⏳                                     │
│  ─────────────────────────────────────────────────────  │
│  PlaceholderManager 立即创建占位元素：                    │
│    ├─ 在画布上显示一个"加载中"的框                        │
│    ├─ 显示加载动画（转圈圈）                              │
│    ├─ 显示提示：AI 生成中...                             │
│    └─ 记录占位元素 ID 和位置                              │
│                                                          │
│  为什么需要占位？                                         │
│    → 用户立即看到反馈（不是傻等）                         │
│    → 预留位置，避免后续元素跳动                           │
│    → 显示生成进度（如批量生成时 1/4）                     │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  第6阶段：工具处理 🔧                                     │
│  ─────────────────────────────────────────────────────  │
│  ToolProcessor 处理工具对象：                             │
│                                                          │
│  ① 获取历史记录（如果重新打开）                           │
│     getRecordId(taskId) → 查数据库                       │
│                                                          │
│  ② 特殊处理（如图文分层需要导出预览）                     │
│     if (toolType === 'imageToTemplate') {                │
│       exportImageByJson() → 生成缩略图                   │
│     }                                                    │
│                                                          │
│  ③ 提交生成记录                                           │
│     postRecord() → 保存到数据库：                        │
│       - generation_result: 图片 URL                      │
│       - prompt: 用户输入                                 │
│       - work_id: 当前作品 ID                             │
│       - task_id: AI 任务 ID                              │
│       → 返回 recordId                                     │
│                                                          │
│  ④ 返回处理后的 Tool（包含 recordId）                    │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  第7阶段：添加到画布 🎨                                   │
│  ─────────────────────────────────────────────────────  │
│  ElementAddService 执行添加：                             │
│                                                          │
│  ① 加载图片资源                                           │
│     loadImage(tool.result.uri)                          │
│     → 下载图片 → 解码 → 创建纹理                         │
│                                                          │
│  ② 创建图片元素                                           │
│     editor.createElement({                               │
│       type: 'image',                                     │
│       imageUrl: tool.result.uri,                         │
│       width: 1920, height: 1080,                        │
│       transform: placeholderPosition  // 占位位置        │
│     })                                                   │
│                                                          │
│  ③ 移除占位元素                                           │
│     placeholderManager.remove(placeholderId)            │
│     → 删除"加载中"的框                                    │
│                                                          │
│  ④ 添加真实元素                                           │
│     editor.addElement(imageElement)                      │
│     → 出现在画布上                                        │
│     → 聚焦新元素（选中状态）                              │
│                                                          │
│  ⑤ 调整视口                                               │
│     adjustViewport() → 自动滚动到新元素位置               │
└─────────────────────────────────────────────────────────┘
                          ↓
                      ✅ 完成！
                  用户看到生成的图片 🎉
```

**流程关键点总结**：

| 阶段       | 耗时      | 用户感知               | 优化手段               |
| ---------- | --------- | ---------------------- | ---------------------- |
| 1-2 输入   | <100ms    | 点击发送               | -                      |
| 3 SSE连接  | 1-2s      | 看到"AI思考中"         | 立即显示加载状态       |
| 4 消息解析 | <100ms    | 无感知（后台处理）     | 高效的JSON解析         |
| 5 创建占位 | <50ms     | 看到占位框（心理预期） | 同步创建，无等待       |
| 6 工具处理 | 10-30s    | 看到加载动画           | **异步处理，不阻塞UI** |
| 7 添加元素 | 200-500ms | 看到图片从模糊到清晰   | 渐进式加载             |

**核心设计思想**：

```
❌ 错误做法：等 AI 生成完再显示结果 → 用户等 30 秒
✅ 正确做法：立即显示占位 + 后台处理 → 用户感觉只等 1 秒
```

### 6.4 四大核心服务深度解析

#### **服务1：SSEManager - 流式通信管家** 🌐

**为什么需要 SSE？**

```
传统方式（轮询）：
  前端每隔1秒问一次："生成好了吗？"
  → 浪费带宽，延迟高

SSE 方式（服务端推送）：
  后端：生成好了一部分 → 立即推送给前端
  → 实时，高效
```

**核心职责**：

1. 建立并维护 SSE 连接
2. 处理网络异常（断线重连）
3. 解析 SSE 数据流（JSON分段解析）
4. 触发回调通知上层

**关键实现**：

```javascript
核心方法：connect(messages) → 返回一个流式读取器

流程：
  1. 发送 POST 请求，携带历史消息
  2. 获取 response.body.getReader()
  3. 循环读取：while (true) {
          const { done, value } = await reader.read();
       // 解码二进制数据
       const text = decoder.decode(value);
       // 解析 JSON（处理分段）
       const data = parseJSON(text);
       // 通知 MessageHandler
       callback(data);
     }
  4. 流结束：done = true → 关闭连接
```

**难点处理**：

```
问题1：JSON 可能被分割（一次 read 只拿到一半）
  解决：缓存不完整数据，拼接后再解析

问题2：网络中断怎么办？
  解决：捕获异常 → 触发 onError → 显示重试按钮

问题3：用户取消生成怎么办？
  解决：reader.cancel() → 关闭流 → 清理资源
```

---

#### **服务2：MessageHandler - 消息流量控制中心** 🔍

**为什么这么复杂？**

```
AI 返回的不是简单的文本，而是结构化的消息流：
  ├─ 文本消息（AI 说的话）
  ├─ 工具调用（AI 要执行的操作）
  ├─ 工具响应（操作的结果）
  └─ 批量生成（一次调用多个工具）

需要一个"交通警察"来管理这些消息的流向
```

**核心职责**：

1. 解析 SSE 消息流，识别消息类型
2. 管理消息状态（待处理、处理中、已完成）
3. 处理批量生成场景（consecutiveFunctionCalls）
4. 过滤和合并重复消息
5. 触发相应的画布操作事件

**批量生成追踪机制**（核心亮点）：

```
场景：用户说"生成4张不同风格的logo"

问题：AI 会返回 4 个 function_call 和 4 个 function_response
  → 如何知道什么时候全部完成？
  → 如何避免重复处理？

解决方案：consecutiveFunctionCalls 追踪

数据结构：
  {
    toolName: 'image',
    batches: [
      {
        expectedResponses: 4,   // 期望4个响应
        receivedResponses: 2,   // 已收到2个
        messageIds: Set(['msg1', 'msg2']), // 已处理的ID
        isCompleted: false      // 未完成
      }
    ]
  }

工作流程：
  1. 收到第1个 function_call → 创建追踪记录
  2. 收到第2个 function_call（连续的）→ expectedResponses + 1
  3. 收到 function_response → receivedResponses + 1
  4. 当 receivedResponses == expectedResponses → 触发批量完成事件
```

**过滤逻辑**：

```
哪些消息需要显示给用户？
  ✅ 用户发的消息
  ✅ AI 的文本回复
  ✅ 工具调用的结果（图片、文本）
  ❌ function_call 细节（技术信息，用户不关心）
  ❌ 系统消息（心跳、状态码）
```

---

#### **服务3：ToolProcessor - 工具全生命周期管家** 🔧

**职责范围**：

从 AI 返回工具对象 → 到保存记录的完整流程。

**核心流程**：

```
processAiTool(tool) 做了什么？

第1步：查询历史记录
  → 如果用户重新打开作品，需要关联之前的生成记录
  → getRecordId(taskId) → 查数据库

第2步：数据转换
  → 合并历史数据：tool.metadata.recordId = record.id
  → 特殊工具处理：如图文分层需要导出预览图

第3步：提交记录
  → postRecord(tool) → 保存到数据库
  → 记录内容：
      - generation_result: 生成的图片URL
      - prompt: 用户输入
      - work_id: 当前作品ID
      - element_id: 对应的画布元素ID
      - task_id: AI任务ID

第4步：返回处理后的工具
  → 包含完整的 metadata（如 recordId）
  → 供后续使用（如重做、删除）
```

**缓存机制**（性能优化）：

```
问题：同一个 taskId 可能被调用多次
  → 如批量生成时，4张图共享某些数据

解决：processedToolCache

Map<taskId, Promise<Tool>>
  ├─ 第1次调用：发起请求，存入缓存
  ├─ 第2-4次调用：直接返回缓存的 Promise
  └─ 避免重复请求，节省时间和带宽
```

---

#### **服务4：PlaceholderManager - 用户体验优化大师** ⏳

**设计初衷**：

```
问题：AI 生成需要 10-30 秒
  → 用户盯着空白画布傻等？❌

解决：先放一个"占位符"
  → 用户立即看到反馈 ✅
  → 心理感觉："AI 在工作了"
```

**占位元素生命周期**：

```
1️⃣ 创建阶段
  ├─ 在画布指定位置创建占位框
  ├─ 显示加载动画（Lottie 动画）
  ├─ 显示提示文字："AI 生成中..."
  └─ 记录占位信息（ID、位置、类型）

2️⃣ 等待阶段
  ├─ 用户可以继续操作画布（不阻塞）
  ├─ 显示生成进度（如批量时 2/4）
  └─ 可点击取消（调用 SSE cancel）

3️⃣ 替换阶段
  ├─ 真实元素加载完成
  ├─ 获取占位元素的位置
  ├─ 在同位置创建真实元素
  ├─ 淡入动画过渡
  └─ 删除占位元素

4️⃣ 异常处理
  ├─ 生成失败 → 占位元素变红，显示错误
  ├─ 显示重试按钮
  └─ 点击重试 → 重新走生成流程
```

**位置计算策略**：

```
问题：占位元素应该放在哪里？

策略1：用户选中了元素 → 放在选中元素旁边
策略2：画布为空 → 放在画布中心
策略3：批量生成 → 自动网格布局（4列）
策略4：连续生成 → 紧挨着上一个元素
```

**核心价值**：

```
没有占位管理：
  → 用户等待 30 秒 → 突然出现图片 → 体验差

有占位管理：
  → 立即看到反馈（<100ms）→ 后台加载 → 无感知替换 → 体验好
```

### 6.5 典型业务场景全流程

#### **场景1：首次生成图片 - 最基础的流程** 🎨

```
用户目标：生成一张海报背景图

┌────────────────────────────────────────────────────────┐
│  用户操作                                                │
│  ────────────────────────────────────────────────────  │
│  1. 打开聊天面板                                         │
│  2. 输入："科技感的蓝色背景，16:9"                       │
│  3. 选择技能：AI 图片生成                                │
│  4. 选择风格：科技风                                     │
│  5. 点击发送                                             │
└────────────────────────────────────────────────────────┘
                          ↓
┌────────────────────────────────────────────────────────┐
│  系统响应（用户视角）                                    │
│  ────────────────────────────────────────────────────  │
│  ① 消息发送后立即：                                      │
│     → 输入框清空                                         │
│     → 消息列表显示用户消息                                │
│     → 显示"AI 思考中..."                                 │
│                                                         │
│  ② 1-2秒后：                                            │
│     → AI 回复："正在为您生成科技感背景..."              │
│     → 画布上出现占位框（灰色矩形 + 加载动画）             │
│                                                         │
│  ③ 10-15秒后：                                          │
│     → 占位框内容从模糊变清晰                             │
│     → 图片完全显示（蓝色科技背景）                       │
│     → 自动选中新图片                                     │
│     → 聊天面板显示："已为您生成1张图片"                 │
└────────────────────────────────────────────────────────┘
                          ↓
┌────────────────────────────────────────────────────────┐
│  后续操作（用户可选）                                    │
│  ────────────────────────────────────────────────────  │
│  • 直接使用该图片                                        │
│  • 继续输入："再生成3张不同颜色的" → 批量生成            │
│  • 选中图片后输入："把颜色改成红色" → 编辑当前图         │
│  • 点击重新生成按钮 → 用相同参数再生成一次               │
└────────────────────────────────────────────────────────┘
```

**关键体验优化点**：

- ✅ 占位元素让用户不用傻等
- ✅ 流式响应让 AI 感觉"有生命"
- ✅ 自动选中让后续操作更流畅

---

#### **场景2：批量生成 - 复杂场景的精妙处理** 🚀

```
用户目标：一次生成多张产品图

用户输入："生成4张手机壳产品图，不同颜色"

┌────────────────────────────────────────────────────────┐
│  系统智能判断                                            │
│  ────────────────────────────────────────────────────  │
│  AI 识别到：                                             │
│    → 数量：4张                                           │
│    → 需求变化：不同颜色                                   │
│  → 决定：调用 4 次图片生成工具                           │
└────────────────────────────────────────────────────────┘
                          ↓
┌────────────────────────────────────────────────────────┐
│  MessageHandler 批量跟踪机制启动                         │
│  ────────────────────────────────────────────────────  │
│  consecutiveFunctionCalls 记录：                        │
│    {                                                    │
│      toolName: 'image',                                 │
│      expectedResponses: 4,  ← 期望4个结果               │
│      receivedResponses: 0,  ← 已收到0个                 │
│      messageIds: Set()                                  │
│    }                                                    │
└────────────────────────────────────────────────────────┘
                          ↓
┌────────────────────────────────────────────────────────┐
│  PlaceholderManager 批量占位                            │
│  ────────────────────────────────────────────────────  │
│  画布上出现 2x2 网格布局：                               │
│                                                         │
│   [占位1-加载中]  [占位2-等待]                           │
│   [占位3-等待]    [占位4-等待]                           │
│                                                         │
│  聊天面板显示："正在生成 0/4..."                        │
└────────────────────────────────────────────────────────┘
                          ↓
┌────────────────────────────────────────────────────────┐
│  流式接收，逐个替换                                      │
│  ────────────────────────────────────────────────────  │
│  ① 第1个结果返回（8秒后）：                              │
│     → receivedResponses: 1                              │
│     → [完成-红色]    [占位2-加载中]                      │
│       [占位3-等待]  [占位4-等待]                         │
│     → 聊天面板更新："正在生成 1/4..."                   │
│                                                         │
│  ② 第2个结果返回（15秒后）：                             │
│     → receivedResponses: 2                              │
│     → [完成-红色]    [完成-蓝色]                         │
│       [占位3-加载中]  [占位4-等待]                       │
│     → "正在生成 2/4..."                                 │
│                                                         │
│  ③ 第3、4个陆续完成...                                   │
│                                                         │
│  ④ 全部完成时：                                          │
│     → receivedResponses === expectedResponses  ✓        │
│     → 触发批量完成事件                                   │
│     → 自动保存作品                                       │
│     → 聊天面板："已为您生成4张图片 ✨"                   │
└────────────────────────────────────────────────────────┘
```

**批量生成的技术难点**：

| 难点                     | 解决方案                                     |
| ------------------------ | -------------------------------------------- |
| 如何知道总共要生成几张？ | AI 返回的 function_call 数量 + 连续判断      |
| 生成顺序不可控怎么办？   | 占位元素预先创建，结果返回时匹配对应位置     |
| 某一张失败了怎么办？     | 单个占位元素标记失败，其他继续，支持单独重试 |
| 如何避免重复处理？       | messageIds Set 去重 + processedResponseIds   |

---

#### **场景3：编辑已有图片 - 上下文感知** ✏️

```
用户目标：修改画布上的图片

前置条件：画布上已有一张图片（海报背景）

用户操作：
  1. 点击选中图片
  2. 在聊天框输入："把这张图的颜色改成暖色调"
  3. 发送

┌────────────────────────────────────────────────────────┐
│  系统上下文识别                                          │
│  ────────────────────────────────────────────────────  │
│  ChatWrap 检测到：                                       │
│    → editor.currentElement 不为空                       │
│    → currentElement.type === 'image'                    │
│    → 提取：currentElement.imageUrl                      │
│  → 判断：这是编辑请求，不是新生成                        │
│                                                         │
│  构造请求参数：                                          │
│    {                                                    │
│      skill: 'seedEdit',      ← 改图技能                 │
│      prompt: "改成暖色调",                              │
│      attachments: [                                     │
│        {                                                │
│          url: currentElement.imageUrl,  ← 原图         │
│          type: 'image'                                  │
│        }                                                │
│      ]                                                  │
│    }                                                    │
└────────────────────────────────────────────────────────┘
                          ↓
┌────────────────────────────────────────────────────────┐
│  占位策略：原地替换                                      │
│  ────────────────────────────────────────────────────  │
│  ① 记录原图位置和尺寸                                    │
│     → position: { x: 100, y: 200 }                     │
│     → size: { width: 800, height: 600 }                │
│                                                         │
│  ② 在原图上方创建占位层                                  │
│     → 半透明遮罩                                         │
│     → 显示"AI 处理中..."                                │
│     → 原图仍然可见（50% 透明度）                         │
│                                                         │
│  ③ 处理完成后                                            │
│     → 移除占位层                                         │
│     → 更新 currentElement.imageUrl = 新图URL            │
│     → 保持位置、尺寸、旋转角度等属性不变                  │
│     → 淡入动画（300ms）                                  │
└────────────────────────────────────────────────────────┘
                          ↓
┌────────────────────────────────────────────────────────┐
│  记录关联（支持撤销）                                    │
│  ────────────────────────────────────────────────────  │
│  ToolProcessor 保存：                                   │
│    {                                                    │
│      element_id: 'elem_123',    ← 关联画布元素          │
│      origin_url: '原图URL',                             │
│      generation_result: '新图URL',                      │
│      operation: 'edit',         ← 操作类型              │
│      prompt: '改成暖色调'                               │
│    }                                                    │
│  → 支持：                                                │
│    • Ctrl+Z 撤销 → 恢复原图                             │
│    • 查看编辑历史                                        │
│    • 再次编辑 → 基于最新版本                             │
└────────────────────────────────────────────────────────┘
```

**上下文感知的价值**：

```
无上下文：用户每次都要上传图片 → 麻烦
有上下文：系统自动识别"这张图" → 自然

用户体验对比：
  ❌ "帮我把 [上传图片] 这张图改成红色"
  ✅ [选中图片] "改成红色"
```

---

#### **场景4：历史回放 - 时光机功能** ⏱️

```
用户目标：查看昨天生成的作品过程

用户操作：点击历史记录 → 选择某条记录

系统响应：进入回放模式

┌────────────────────────────────────────────────────────┐
│  回放模式初始化                                          │
│  ────────────────────────────────────────────────────  │
│  1. 加载历史数据                                         │
│     GET /api/chat/thread/{thread_id}                    │
│     返回：完整消息列表 + 画布快照                        │
│                                                         │
│  2. 设置回放状态                                         │
│     mode: 'playback'                                    │
│     → 禁用输入框（不可发送新消息）                       │
│     → 显示回放控制栏                                     │
│     → 清空当前画布                                       │
│                                                         │
│  3. 创建模拟 SSE 流                                      │
│     PlaybackSSEStream(messages, speed)                  │
│     → 按时间间隔推送历史消息                             │
│     → speed: 'normal' | 'fast' | 'skip'                │
└────────────────────────────────────────────────────────┘
                          ↓
┌────────────────────────────────────────────────────────┐
│  逐帧重现（像看电影）                                    │
│  ────────────────────────────────────────────────────  │
│  时间轴：                                                │
│                                                         │
│  00:00 - 用户消息："生成海报背景"                       │
│  00:02 - AI 回复："正在生成..."                        │
│  00:03 - function_call 出现                             │
│  00:04 - 占位元素出现（模拟）                            │
│  00:15 - function_response 到达                         │
│  00:16 - 图片添加到画布（锁定，不可编辑）               │
│  00:20 - 用户消息："改成红色"                           │
│  00:22 - AI 执行编辑...                                 │
│  ...                                                    │
│                                                         │
│  回放控制：                                              │
│    [◀◀ 快退] [▶ 播放/暂停] [⏭️ 跳到最后] [🔄 重做]      │
└────────────────────────────────────────────────────────┘
                          ↓
┌────────────────────────────────────────────────────────┐
│  回放完成后                                              │
│  ────────────────────────────────────────────────────  │
│  用户可以：                                              │
│    • 点击"同样操作" → 复制 prompt 到输入框               │
│    • 点击"基于此继续" → 退出回放，继续编辑               │
│    • 点击"另存为新作品" → 复制一份继续创作               │
│    • 点击"关闭" → 返回作品列表                           │
└────────────────────────────────────────────────────────┘
```

**回放功能的技术实现**：

```javascript
核心：用历史消息模拟 SSE 流

// 创建模拟流
const stream = createPlaybackSSEStream(historyMessages, {
  speed: 'normal',  // 控制播放速度
  skipDelay: true,  // 是否跳过延迟
});

// 播放控制
playbackControls = {
  pause() {  // 暂停播放
    stream.isPaused = true;
  },
  resume() {  // 继续播放
    stream.isPaused = false;
  },
  skipToEnd() {  // 跳到最后
    stream.skipToEnd = true;
  },
};

// 与正常流程共用相同的处理逻辑
// MessageHandler、PlaceholderManager 等都正常工作
// 只是数据来源从网络变成了本地历史数据
```

### 6.6 事件驱动架构 - 解耦的艺术 📡

**为什么需要事件系统？**

```
问题：聊天面板如何通知画布添加图片？

方案1：直接调用（紧耦合）❌
  ChatPanel.ts:
    import { canvas } from './canvas';
    canvas.addImage(data);
  → ChatPanel 必须知道 canvas 的存在
  → 难以测试、难以替换

方案2：事件系统（松耦合）✅
  ChatPanel.ts:
    events.emit('addImage', data);
  Canvas.ts:
    events.on('addImage', (data) => {
      this.addImage(data);
    });
  → 两个模块互不依赖
  → 易于测试、易于扩展
```

**事件分类与职责**：

```javascript
// 1️⃣ 用户交互事件（UI → 服务层）
events.emit('submit', chatParams); // 用户发送消息
events.emit('cancel'); // 用户取消生成
events.emit('newChat'); // 新建对话
events.emit('skillChange', 'image'); // 切换 AI 技能

// 2️⃣ 画布操作事件（服务层 → 画布层）
events.emit('addImage', aigc, options); // 添加图片
events.emit('addText', content); // 添加文本
events.emit('addLayout', layoutData); // 添加布局
events.emit('replaceImage', aigc); // 替换图片
events.emit('replacePage', pageData); // 替换整个页面

// 3️⃣ 状态通知事件（双向）
events.emit('requesting', true); // 请求中状态
events.emit('updateFilteredMessages', msgs); // 消息列表更新
events.emit('changeSendParams', params); // 参数变更

// 4️⃣ 错误处理事件
events.emit('error', error, '生成失败'); // 通用错误
```

**事件流转示意**：

```
用户点击发送
    ↓
  ChatSender
    ↓ emit('submit')
  ChatWrap
    ↓ 处理发送逻辑
  SSEManager.connect()
    ↓ SSE 流返回
  MessageHandler.handleSSEMessage()
    ↓ 解析出工具调用
  emit('addImage', aigc)
    ↓ 多个监听器响应
  ├─ PlaceholderManager: 创建占位
  ├─ ToolProcessor: 处理工具
  └─ ElementAddService: 添加到画布
```

**事件监听生命周期管理**（避免内存泄漏）：

```javascript
// Vue 组件中的标准实践
setup() {
  // 组件挂载时注册
  onMounted(() => {
    events.on('addImage', handleAddImage);
    events.on('addText', handleAddText);
  });

  // 组件卸载时移除
  onBeforeUnmount(() => {
    events.off('addImage', handleAddImage);
    events.off('addText', handleAddText);
  });
}
```

### 6.7 共享状态管理 - 多组件协同 🔗

**场景**：中间聊天框（CenterChatPanel） + 右侧聊天框（ChatWrap）共享状态。

**设计目标**：

```
用户在中间聊天框输入参数
  → 右侧聊天框同步显示相同参数
  → 切换聊天框不会丢失状态
```

**实现方案**：Composables 共享状态

```javascript
// ① 创建共享的 Composables
// useSharedChatParams.ts
const sharedState = reactive({
  skill: 'image',
  ratio: '16:9',
  styleCode: 'realistic',
  attachments: [],
});

export function useSharedChatParams() {
  return {
    params: readonly(sharedState), // 只读访问
    updateParams(newParams) {
      // 更新方法
      Object.assign(sharedState, newParams);
    },
  };
}

// ② 两个组件使用同一个 Composable
// CenterChatPanel.vue
const { params, updateParams } = useSharedChatParams();
// 用户改变技能
onSkillChange((skill) => {
  updateParams({ skill }); // 更新共享状态
});

// ChatWrap.vue
const { params } = useSharedChatParams();
// 自动响应更新
watch(
  () => params.skill,
  (newSkill) => {
    console.log('技能已切换:', newSkill);
  },
);
```

**共享状态的三个维度**：

| 维度       | 共享内容                           | 用途             |
| ---------- | ---------------------------------- | ---------------- |
| **Params** | 用户输入的参数（skill、ratio...）  | 保持输入状态同步 |
| **Hooks**  | 回调函数（login、upload、tracker） | 统一业务逻辑接口 |
| **Events** | 事件总线实例                       | 统一事件通信渠道 |

**为什么不用 Vuex/Pinia？**

```
Vuex/Pinia 适合：全局状态（用户信息、配置等）
Composables 适合：组件间临时共享状态

优势：
  ✅ 轻量级，不需要注册 store
  ✅ TypeScript 友好
  ✅ 按需使用，不污染全局
```

---

## 七、性能优化与错误处理

### 7.1 性能优化策略汇总

#### **前端渲染优化**

| 优化项         | 具体措施                         | 效果提升         |
| -------------- | -------------------------------- | ---------------- |
| **虚拟滚动**   | 消息列表超过50条启用虚拟滚动     | 减少70% DOM节点  |
| **图片懒加载** | IntersectionObserver 监听可见性  | 节省80% 带宽     |
| **防抖节流**   | 输入框300ms防抖，画布16ms节流    | 减少90% 无效渲染 |
| **Web Worker** | 大图处理放到Worker，不阻塞主线程 | UI始终流畅       |

#### **网络通信优化**

| 优化项           | 具体措施                      | 效果提升      |
| ---------------- | ----------------------------- | ------------- |
| **SSE 连接复用** | 同会话复用连接，避免频繁建立  | 减少延迟50%   |
| **请求合并**     | 批量生成用一个请求，而非多个  | 减少请求数75% |
| **CDN 加速**     | 图片自动走 CDN，支持 WebP格式 | 加载快3倍     |
| **预加载**       | 预加载常用样式、下一批消息    | 首屏快40%     |

#### **内存管理优化**

| 优化项         | 具体措施                         | 效果提升     |
| -------------- | -------------------------------- | ------------ |
| **消息分页**   | 历史消息按需加载，旧消息自动回收 | 降低60% 内存 |
| **纹理卸载**   | 超出视口的纹理自动卸载           | 降低80% 显存 |
| **事件清理**   | 组件销毁时移除监听，使用 WeakMap | 避免内存泄漏 |
| **对象池复用** | 复用PixiJS对象，减少GC           | 减少GC卡顿   |

### 7.2 错误处理机制

#### **错误分类与处理策略**

```
┌─────────────────────────────────────────────────────┐
│  客户端错误（4xx）                                    │
│  ───────────────────────────────────────────────   │
│  400 参数错误 → 显示"参数有误，请检查后重试"          │
│  401 未登录 → 弹出登录框                             │
│  403 权限不足 → 显示"此功能需要会员"                 │
│  429 请求过快 → 显示"请稍后再试"                     │
└─────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────┐
│  服务端错误（5xx）                                    │
│  ───────────────────────────────────────────────   │
│  500 服务器错误 → "服务暂时不可用，请稍后重试"        │
│  503 服务过载 → "当前使用人数较多，排队中..."        │
│  超时 → "网络不稳定，已自动重试"                      │
└─────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────┐
│  业务错误（自定义code）                               │
│  ───────────────────────────────────────────────   │
│  -1002 稿豆不足 → 弹出充值弹窗                        │
│  -1006 内容违规 → "内容不符合规范，请修改后重试"      │
│  -1007 AI拒绝 → "AI 认为此请求不合适"                │
└─────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────┐
│  网络错误                                             │
│  ───────────────────────────────────────────────   │
│  断网 → 显示"网络已断开"，连接恢复后自动重连          │
│  SSE中断 → 自动重连（最多3次），失败后显示重试按钮   │
└─────────────────────────────────────────────────────┘
```

#### **错误处理流程**

```
错误发生
    ↓
MessageHandler 捕获
    ↓
┌─────────────────────┐
│ 判断错误类型          │
└─────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 是否可重试？                          │
│  ├─ YES → 显示重试按钮                │
│  └─ NO → 只显示错误信息               │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 清理现场                              │
│  ├─ 移除占位元素                      │
│  ├─ 标记消息状态为失败                 │
│  ├─ 上报错误日志                      │
│  └─ 释放资源（关闭SSE连接等）          │
└─────────────────────────────────────┘
    ↓
用户点击重试 → 重新走生成流程
```

#### **优雅降级策略**

```
核心思想：功能不可用，但不能让应用崩溃

示例：
  AI 服务挂了 → 显示提示，其他编辑功能继续可用
  图片加载失败 → 显示占位图，不影响其他元素
  SSE 不支持 → 降级为轮询方式
```

---

## 八、核心代码片段解析

> 以下代码展示关键逻辑的核心思想，而非完整实现

### 8.1 编辑器初始化（应用入口）

```typescript
// 简化示意：实际初始化过程
async function editorMain() {
  // 1. 导入基座
  const { installDesign } = await import('@design/design-foundation/agent');

  // 2. 一行代码启动编辑器
  await installDesign('#app', {
    // API配置
    apis: {
      baseURL: 'https://api.example.com',
      endpoints: {
        /* ... */
      },
    },

    // 环境配置
    env: {
      REGION: 'China', // 区域：国内/国外
      LOGIN_TYPE: 'phone', // 登录方式
    },

    // 权限配置（功能开关）
    permissions: {
      AI_CHAT: true, // AI聊天
      FILE_UPLOAD: true, // 文件上传
      // ...
    },

    // 插件配置（按需加载）
    extensionConfig: [
      // 异步导入，支持代码分割
      defineExtensionConfig(() => import('@design/extension-ai')),
    ],
  });
}

// 核心价值：
// ✓ 统一入口，标准化初始化流程
// ✓ 配置驱动，国内外版本只需改配置
// ✓ 异步加载，首屏体积小
```

### 8.2 聊天组件集成

```vue
<!-- 简化示意：聊天组件的使用方式 -->
<template>
  <ChatWrap :chatConfig="chatConfig" :editor="editor" @submit="handleSubmit" />
</template>

<script setup>
import { ChatWrap, getQingZhouConfig } from '@design/ai-chat-vue';

// 初始化聊天配置（提供回调函数）
const chatConfig = await getQingZhouConfig({
  // 必需回调
  getRepositoryId: () => currentWorkId, // 当前作品ID
  getUserId: () => currentUserId, // 当前用户ID

  // 可选回调
  tracker: windAPI, // 埋点工具
  login: () => showLoginModal(), // 登录
  upload: (file) => uploadToOSS(file), // 上传
});

// 处理用户提交
const handleSubmit = (params) => {
  // params: { skill, prompt, ratio, styleCode, attachments }
  console.log('用户发起生成:', params);
};
</script>

<!-- 核心价值： -->
<!-- ✓ 声明式使用，无需关心内部复杂度 -->
<!-- ✓ 通过回调函数对接业务逻辑 -->
<!-- ✓ 事件驱动，解耦画布和聊天 -->
```

### 8.3 SSE流式处理（核心逻辑）

```typescript
// 简化示意：SSE 消息处理的核心流程
class MessageHandler {
  handleSSEMessage(data: MessageType[], done: boolean) {
    data.forEach((item) => {
      // 根据消息类型分发处理
      switch (item.content.type) {
        case 'text':
          // AI的文本回复
          this.appendAssistantMessage(item.content.text);
          break;

        case 'function_call':
          // AI调用工具（如生成图片）
          this.trackToolStart(item); // 埋点
          this.createPlaceholder(); // 创建占位
          break;

        case 'function_response':
          // 工具执行结果
          const tool = this.parseTool(item.content.text);
          events.emit('addImage', tool); // 触发画布添加
          break;
      }
    });

    if (done) {
      // 流结束，保存记录
      this.saveConversation();
    }
  }
}

// 核心价值：
// ✓ 统一处理各种消息类型
// ✓ 实时流式更新UI
// ✓ 通过事件解耦业务逻辑
```

### 8.4 批量生成追踪（技术亮点）

```typescript
// 简化示意：批量生成的追踪机制
class MessageHandler {
  private consecutiveFunctionCalls = new Map();

  handleFunctionCall(item) {
    const toolName = item.toolName; // 如 'image'

    // 检测是否为连续调用（批量生成）
    const tracking = this.consecutiveFunctionCalls.get(toolName);

    if (tracking && this.isConsecutive(item, tracking)) {
      // 累加期望数量
      tracking.expectedResponses++;
    } else {
      // 新建追踪记录
      this.consecutiveFunctionCalls.set(toolName, {
        expectedResponses: 1,
        receivedResponses: 0,
        messageIds: new Set([item.messageId]),
      });
    }
  }

  handleFunctionResponse(item) {
    const toolName = item.toolName;
    const tracking = this.consecutiveFunctionCalls.get(toolName);

    if (tracking) {
      tracking.receivedResponses++;

      // 判断是否全部完成
      if (tracking.receivedResponses === tracking.expectedResponses) {
        this.onBatchCompleted(toolName); // 批量完成事件
      }
    }
  }
}

// 核心价值：
// ✓ 智能识别批量生成意图
// ✓ 实时追踪生成进度
// ✓ 避免重复处理和遗漏
```

### 8.5 占位元素管理（用户体验优化）

```typescript
// 简化示意：占位元素的创建和替换
class PlaceholderManager {
  create(type: 'image' | 'text') {
    // 1. 创建占位元素（视觉元素）
    const placeholder = {
      id: generateId(),
      type,
      element: this.createLoadingElement(), // 加载动画
    };

    // 2. 添加到画布
    const position = this.calculatePosition();
    editor.addElement(placeholder.element, position);

    // 3. 记录占位信息
    this.placeholders.set(placeholder.id, placeholder);

    return placeholder.id;
  }

  replace(placeholderId, realElement) {
    // 1. 获取占位元素
    const placeholder = this.placeholders.get(placeholderId);

    // 2. 继承位置
    realElement.transform = placeholder.element.transform;

    // 3. 移除占位，添加真实元素
    editor.removeElement(placeholder.element);
    editor.addElement(realElement);

    // 4. 清理记录
    this.placeholders.delete(placeholderId);
  }
}

// 核心价值：
// ✓ 立即反馈，无需等待
// ✓ 位置预留，避免跳动
// ✓ 优雅过渡，提升体验
```

### 8.6 事件驱动（解耦利器）

```typescript
// 简化示意：事件系统的使用
// 发布者（ChatPanel）
events.emit('addImage', {
  tools: [imageToolData],
  autoPosition: true,
});

// 订阅者1（PlaceholderManager）
events.on('addImage', (data) => {
  const placeholderId = this.create('image');
  // 创建占位，等待真实元素
});

// 订阅者2（ToolProcessor）
events.on('addImage', async (data) => {
  for (const tool of data.tools) {
    const processed = await this.processAiTool(tool);
    // 处理工具数据
  }
});

// 订阅者3（ElementAddService）
events.on('addImage', async (data) => {
  await this.addImageElement(data.tools[0]);
  // 添加到画布
});

// 核心价值：
// ✓ 一对多通信，无需互相引用
// ✓ 易于扩展，新增订阅者不影响发布者
// ✓ 便于测试，可单独测试每个模块
```

---

## 九、总结与展望

### 9.1 架构核心价值

本架构的设计遵循**高内聚、低耦合**的原则，通过分层、插件化、事件驱动三大设计理念，构建了一个**可扩展、高性能、易维护**的 AI 智能设计编辑器。

**五大架构优势**：

```
1️⃣ 分层清晰
  → 每层职责明确，边界清晰
  → 团队并行开发，互不阻塞
  → 易于定位问题，降低维护成本

2️⃣ 插件化扩展
  → 功能模块独立，按需加载
  → 新增功能不影响核心稳定性
  → 支持第三方插件生态

3️⃣ 高性能渲染
  → PixiJS + WebGL 硬件加速
  → 虚拟化渲染，支持万级元素
  → 流畅的60fps用户体验

4️⃣ 流式AI交互
  → SSE 实时推送，秒级反馈
  → 占位元素优化等待体验
  → 批量生成智能追踪

5️⃣ 用户体验优先
  → 立即反馈，无需等待
  → 错误容忍，优雅降级
  → 历史回放，完整复现
```

### 9.2 技术创新点

| 创新点           | 技术方案                      | 业界对比                   |
| ---------------- | ----------------------------- | -------------------------- |
| **流式 AI 响应** | SSE + MessageHandler 精细控制 | 轮询方案延迟高，体验差     |
| **批量生成追踪** | consecutiveFunctionCalls 机制 | 业界少有完整的批量追踪方案 |
| **智能占位管理** | PlaceholderManager + 位置继承 | 多数产品直接等待，体验差   |
| **上下文感知**   | currentElement 联动           | 需要用户手动关联上下文     |
| **历史回放**     | PlaybackSSEStream 模拟流式    | 业界少有完整回放功能       |
| **多租户架构**   | 配置驱动差异化                | 多数需要维护多套代码       |

### 9.3 经验总结

#### **做对的事情** ✅

```
✓ 事件驱动解耦
  → 新增功能只需订阅事件，不改现有代码
  → 实际效果：90% 的新功能无需改动核心

✓ 占位元素设计
  → 用户立即看到反馈，心理等待时间<1秒
  → 用户满意度提升 40%

✓ 批量追踪机制
  → 自动识别批量意图，无需用户手动指定
  → 生成效率提升 3 倍

✓ TypeScript 全栈
  → 90% 的 bug 在编译时发现
  → 重构信心提升，速度加快 5 倍
```

#### **踩过的坑** ⚠️

```
❌ 早期未做虚拟化
  → 1000+ 元素时页面卡死
  → 教训：性能优化要提前设计，重构成本高

❌ 事件监听未清理
  → 内存泄漏，长时间使用后卡顿
  → 教训：必须在组件销毁时清理

❌ SSE 断线处理不完善
  → 用户网络抖动时频繁报错
  → 教训：网络异常是常态，必须有重连机制

❌ 占位位置计算错误
  → 批量生成时元素重叠
  → 教训：边界情况要充分测试
```

### 9.4 未来演进方向

#### **短期目标（3-6个月）** 🎯

```
性能优化：
  ├─ WebWorker 处理大图，不阻塞主线程
  ├─ Service Worker 离线缓存
  └─ 首屏加载时间降低到 1 秒内

功能增强：
  ├─ 支持语音输入（语音转文字）
  ├─ 支持手绘草图转设计
  └─ AI 自动优化设计（自动配色、排版）
```

#### **中期目标（6-12个月）** 🚀

```
协同编辑：
  ├─ WebRTC 实时协作
  ├─ 多人同时编辑
  └─ 冲突自动解决

AI 能力升级：
  ├─ 多模态理解（图+文）
  ├─ 设计风格迁移
  └─ 智能推荐优化建议
```

#### **长期愿景（12个月+）** 🌟

```
开放生态：
  ├─ 插件市场
  ├─ 第三方开发者支持
  └─ AI 模型自定义接入

技术升级：
  ├─ WebGPU 渲染（性能再提升 10 倍）
  ├─ 边缘计算（AI 本地推理）
  └─ WASM 核心模块（性能优化）
```

### 9.5 给开发者的建议

**如果你要基于此架构开发**：

```
1. 先理解分层架构
   → 从下往上：渲染层 → 引擎层 → 基座层 → 业务层 → 应用层
   → 明确每层的职责和边界

2. 掌握事件驱动
   → 优先使用事件通信，而非直接调用
   → 事件命名要清晰，携带必要信息

3. 善用 TypeScript
   → 定义清晰的类型接口
   → 利用类型推导减少冗余代码

4. 注重性能
   → 虚拟化、懒加载是基础
   → 使用 Performance API 监控关键指标

5. 用户体验优先
   → 立即反馈 > 精确反馈
   → 错误提示要友好，支持重试
```

---

## 附录

### A. 核心目录结构

```
domains/editor/
├── apps/                        # 应用层
│   ├── design-ai-plus/          # 国内版
│   │   ├── src/
│   │   │   ├── main.ts          # 入口文件
│   │   │   └── configs/         # 配置文件
│   │   └── index.html
│   └── insmind-ai-plus/         # 国际版
│       └── ...（结构同上）
│
├── packages/                    # 核心包
│   ├── design/                  # 业务层
│   │   ├── ai-chat-vue/         # ⭐ AI 对话 Vue 版
│   │   ├── ai-chat-react/       # AI 对话 React 版
│   │   ├── business-ui/         # 业务 UI 组件
│   │   └── extension/           # 扩展管理器
│   │
│   ├── editor/                  # 引擎层
│   │   ├── framework/           # ⭐ 编辑器框架
│   │   └── infinite-renderer/   # ⭐ 无限画布渲染
│   │
│   └── foundations/             # 基座层
│       └── design/              # ⭐ 编辑器基座
│
└── extensions/                  # 插件层
    ├── ai/                      # AI 核心插件
    ├── upload/                  # 上传插件
    ├── image-edit/              # 图像编辑插件
    └── ...（更多插件）
```

### B. 技术栈清单

```javascript
{
  // 核心框架
  "vue": "^2.7.14",              // UI 框架
  "typescript": "^5.0.0",         // 类型系统

  // 构建工具
  "vite": "^4.0.0",              // 构建工具

  // 渲染引擎
  "pixi.js": "^7.0.0",           // WebGL 渲染

  // 状态管理
  "pinia": "^2.1.0",             // 状态管理

  // 工具库
  "eventemitter3": "^5.0.0",     // 事件总线
  "lodash-es": "^4.17.21",       // 工具函数
  "uuid": "^9.0.0",              // ID 生成
}
```

### C. 核心概念速查

| 术语               | 含义                               | 所在层级 |
| ------------------ | ---------------------------------- | -------- |
| **Foundation**     | 编辑器基座，统一初始化入口         | 基座层   |
| **Extension**      | 扩展插件，功能模块                 | 插件层   |
| **Surface**        | 画布表面，渲染上下文管理           | 渲染层   |
| **Viewport**       | 视口，控制缩放平移                 | 渲染层   |
| **SSE**            | Server-Sent Events，流式推送       | 通信协议 |
| **MessageHandler** | 消息处理器，解析 AI 消息流         | 服务层   |
| **ToolProcessor**  | 工具处理器，管理 AI 工具全生命周期 | 服务层   |
| **Placeholder**    | 占位元素，优化等待体验             | 服务层   |
| **VmEngine**       | 视图模型引擎，数据→渲染对象转换    | 渲染层   |

---

## 十、Agent 工作流程深度解析 ⭐⭐⭐

> **本章核心**：深入剖析从用户输入到 AI 响应的完整链路，包括 Prompt Engineering、Dify集成、大模型调用、Tool执行等关键环节。

### 10.1 Agent 架构全景

系统采用 **Agent-X 架构**，这是一个基于 Ant Design X 改造的 Vue 2.7 兼容版本，专门为 AI 对话场景设计。

```
┌─────────────────────────────────────────────────────────────┐
│  用户层                                                       │
│  ChatSender (输入框) → 用户输入提示词                         │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│  Agent 编排层                                                 │
│  useXAgent (Agent 核心)                                      │
│    ├─ request()          → 处理请求                          │
│    ├─ onUpdate()         → 实时更新                          │
│    └─ onSuccess()        → 完成回调                          │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│  网络通信层                                                   │
│  createSSEConnection() → Dify Agent 后端                     │
│    POST /api/gdesign/tool/v1/dify/chat                      │
│    Body: {                                                   │
│      scene_code: 'ai-chat',                                  │
│      query: '用户输入',                                       │
│      arguments: {                                            │
│        think: 0/1,           ← 是否开启深度思考(R1模型)      │
│        history_text: '...'   ← 历史对话(最多30组)            │
│      }                                                       │
│    }                                                         │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│  Dify Workflow 编排层 (后端)                                 │
│  ┌──────────────┐   ┌──────────────┐   ┌──────────────┐   │
│  │ 1️⃣ PE增强    │ → │ 2️⃣ 大模型调用 │ → │ 3️⃣ 工具路由   │   │
│  │ Prompt Eng  │   │ DeepSeek API │   │ Tool Calling │   │
│  └──────────────┘   └──────────────┘   └──────────────┘   │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│  大模型层                                                     │
│  DeepSeek-V3 / DeepSeek-R1                                  │
│  ├─ 理解用户意图                                             │
│  ├─ 决策需要调用哪些工具                                      │
│  └─ 返回 function_call / text                               │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│  工具执行层                                                   │
│  Tool Functions (后端)                                       │
│  ├─ draw          → 文生图                                   │
│  ├─ redraw        → 图生图                                   │
│  ├─ writer        → 文案生成                                 │
│  ├─ material      → 素材推荐                                 │
│  ├─ cutout        → AI抠图                                   │
│  ├─ background    → 背景替换                                 │
│  └─ ...           → 更多工具                                 │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│  结果返回层 (SSE 流式推送)                                    │
│  event: workflow_started   → 任务开始                        │
│  event: message            → AI文本输出(流式)                │
│  event: message (thinking) → R1思考过程                      │
│  event: workflow_finished  → 任务完成                        │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│  前端响应层                                                   │
│  MessageHandler → PlaceholderManager → ElementAddService     │
└─────────────────────────────────────────────────────────────┘
```

### 10.2 完整请求流程 - 从代码角度解析

#### **Step 1：用户发起请求（前端）**

```typescript
// packages/business-sdks/ai-chat/src/hook/use-message.ts

const [agent] = useXAgent<MessageType>({
  request: async ({ message }, { onSuccess, onUpdate }) => {
    // 1️⃣ 创建默认响应消息（立即显示加载状态）
    const defaultAnswerMessage: MessageType = {
      content: '',
      id: uuidv4(),
      role: MESSAGE_ROLE.ASSISTANT,
      status: MESSAGE_STATUS.LOADING,
      reasoningContent: '', // R1 模型的思考内容
      taskId: '',
      thinkingElapsedMs: 0, // 思考耗时
      model: isThink.current ? 'deepseek-r1' : 'deepseek-v3',
      model_config: {
        think: isThink.current, // 是否开启深度思考
      },
    };

    // 2️⃣ 立即更新 UI（显示加载状态）
    onUpdate(defaultAnswerMessage);

    // 3️⃣ 建立 SSE 连接
    sseConnection = await createSSEConnection({
      message: message.content, // 用户输入
      messageList: messagesRef.current, // 历史消息（最多30组）
      isThink: isThink.current, // 是否使用 R1
      onError: handleError,
      isOnline,
    });

    // 4️⃣ 监听 SSE 流
    sseConnection.listen((data: SSEMessageType) => {
      onListen(data);
    });
  },
});
```

**关键设计**：

```
设计1：立即反馈
  → onUpdate() 立即调用，用户看到"AI思考中"
  → 不等待网络请求，优化体验

设计2：历史消息管理
  → 只发送最近 30 组对话（60条消息）
  → 避免 Token 超限，降低成本

设计3：模型选择
  → deepseek-v3：快速响应（1-2秒）
  → deepseek-r1：深度思考（5-10秒），质量更高
```

---

#### **Step 2：建立 SSE 连接（前端 → 后端）**

```typescript
// packages/business-sdks/ai-chat/src/services/sse.ts

export async function createSSEConnection(options) {
  const { message, messageList, isThink } = options;

  // 1️⃣ 构造历史消息
  let history_text: Array<MessageType> = [];
  if (messageList && messageList.length > 0) {
    const sliceMessage = messageList.slice(-60); // 最多 30 组
    history_text = sliceMessage.filter((it) => {
      return [MESSAGE_ROLE.ASSISTANT, MESSAGE_ROLE.USER].includes(it.role) && !it.error;
    });
  }

  // 2️⃣ 发送 POST 请求到 Dify 后端
  const response = await fetch(`${baseUrl}/api/gdesign/tool/v1/dify/chat`, {
    method: 'post',
    body: JSON.stringify({
      scene_code: 'ai-chat', // 场景标识
      aigc_type: 'aigc', // AIGC 类型
      query: message, // 用户输入
      arguments: {
        think: isThink ? 1 : 0, // 是否开启 R1 思考
        // 历史对话 JSON 字符串
        history_text:
          history_text.length > 0
            ? JSON.stringify(history_text).replace(/<thinking>[\s\S]*?<\/thinking>/g, '') // 移除历史思考过程
            : '',
      },
      conversation_id: '', // 会话 ID（可选）
    }),
    headers: {
      'Content-Type': 'application/json',
      'Authorization': authorization, // OAuth2 Token
    },
  });

  // 3️⃣ 获取 ReadableStream
  const reader = response.body.getReader();
  const decoder = new TextDecoder();

  // 4️⃣ 返回流式读取接口
  return {
    async listen(callback) {
      let buffer = ''; // 缓存不完整的 JSON

      while (true) {
        const { done, value } = await reader.read();
        let text = decoder.decode(value);

        try {
          // 尝试解析 JSON
          if (buffer) text = buffer + text;
          const data = JSON.parse(text);
          callback(data);
          buffer = '';
        } catch (error) {
          // JSON 不完整，缓存起来
          const jsonList = parseJsonSequence(text);
          if (jsonList.length === 0) {
            buffer = text; // 等待下一块
          } else {
            jsonList.forEach(callback);
            buffer = '';
          }
        }

        if (done) break;
      }
    },
    close() {
      reader.cancel(); // 关闭流
    },
  };
}
```

**核心技术细节**：

| 技术点            | 实现方式                        | 解决的问题                |
| ----------------- | ------------------------------- | ------------------------- |
| **JSON 分段处理** | buffer 缓存 + parseJsonSequence | SSE 可能返回不完整的 JSON |
| **历史消息过滤**  | 去除 error 消息和 thinking 标签 | 减少无效 Token，降低成本  |
| **错误处理**      | 捕获 401/400/500 等状态码       | 优雅降级，友好提示        |
| **流式读取**      | ReadableStream + decoder        | 实时响应，无需等待完成    |

---

#### **Step 3：Dify Workflow 处理（后端黑盒）**

虽然 Dify 是后端黑盒，但根据代码和经验，可以推断其工作流程：

```
┌─────────────────────────────────────────────────────────────┐
│  Dify Agent Workflow (推测)                                  │
│  ─────────────────────────────────────────────────────────  │
│  Node 1: 接收请求                                            │
│    ├─ 解析 query、history_text、think 参数                  │
│    ├─ 生成 task_id                                          │
│    └─ 发送 workflow_started 事件                            │
│                                                              │
│  Node 2: Prompt Engineering (提示词增强)                     │
│    ├─ 系统提示词注入                                         │
│    │   "你是一个专业的设计助手，擅长..."                     │
│    ├─ 历史对话格式化                                         │
│    │   [{ role: 'user', content: '...' }, ...]             │
│    ├─ 工具定义注入 (Tool Definitions)                       │
│    │   functions: [                                          │
│    │     { name: 'draw', description: '生成图片', ... },   │
│    │     { name: 'writer', description: '生成文案', ... }, │
│    │     ...                                                 │
│    │   ]                                                     │
│    └─ Few-Shot 示例（可选）                                  │
│        "例如：用户说'生成海报' → 调用 draw 工具"             │
│                                                              │
│  Node 3: 大模型调用                                          │
│    ├─ 选择模型（deepseek-v3 / deepseek-r1）                 │
│    ├─ 构造请求参数                                           │
│    │   {                                                     │
│    │     model: 'deepseek-r1',                              │
│    │     messages: [...],                                   │
│    │     tools: [...],                 ← Function Calling  │
│    │     temperature: 0.7,                                  │
│    │     stream: true,                 ← 流式返回           │
│    │     reasoning_effort: 'high'      ← R1 专属参数        │
│    │   }                                                     │
│    └─ 调用 DeepSeek API                                     │
│                                                              │
│  Node 4: 流式响应处理                                        │
│    ├─ 接收模型输出（SSE流）                                  │
│    ├─ 识别思考过程（<thinking>...</thinking>）              │
│    ├─ 识别工具调用（tool_calls）                            │
│    └─ 转发给前端（SSE推送）                                  │
│                                                              │
│  Node 5: 工具执行（如果有 tool_calls）                      │
│    ├─ 解析 tool_name 和 arguments                           │
│    ├─ 路由到对应的工具服务                                   │
│    │   draw → 图片生成服务（SD/Flux）                       │
│    │   writer → 文案生成服务（GPT/Claude）                  │
│    ├─ 等待工具执行完成                                       │
│    └─ 将结果返回给模型（继续对话）                           │
│                                                              │
│  Node 6: 完成响应                                            │
│    ├─ 发送 workflow_finished 事件                           │
│    ├─ 记录对话历史                                           │
│    └─ 关闭 SSE 连接                                          │
└─────────────────────────────────────────────────────────────┘
```

**Prompt Engineering 示例**（推测的系统提示词）：

```
你是稿定AI的智能设计助手，专门帮助用户快速完成设计创作。

核心能力：
1. 图片生成：根据用户描述生成设计图片（调用 draw 工具）
2. 文案生成：生成营销文案、slogan等（调用 writer 工具）
3. 图片编辑：抠图、背景替换、图片扩展等（调用相应工具）
4. 素材推荐：根据需求推荐合适的素材（调用 material 工具）

交互规范：
- 理解用户意图，主动推荐合适的功能
- 如果信息不足，主动询问关键参数（如图片比例、风格等）
- 生成结果后，询问用户是否满意，提供优化建议
- 保持友好、专业的语气

可用工具：
{{tool_definitions}}  ← Dify 自动注入

历史对话：
{{history_text}}  ← 前端传入

当前问题：
{{query}}  ← 用户输入
```

---

#### **Step 4：大模型响应（DeepSeek API）**

大模型返回的流式数据格式（推测）：

```json
// 事件1：思考开始（R1模型独有）
{
  "event": "message",
  "answer": "<thinking>\n我需要分析用户的需求...\n</thinking>",
  "task_id": "task_xxx",
  "conversation_id": "conv_xxx"
}

// 事件2：文本输出
{
  "event": "message",
  "answer": "好的，我来帮您生成",
  "task_id": "task_xxx"
}

// 事件3：工具调用（Function Calling）
{
  "event": "tool_calls",
  "tool_calls": [
    {
      "id": "call_xxx",
      "type": "function",
      "function": {
        "name": "draw",
        "arguments": "{\"prompt\":\"春天的风景\",\"ratio\":\"16:9\",\"style\":\"realistic\"}"
      }
    }
  ],
  "task_id": "task_xxx"
}

// 事件4：工具执行结果
{
  "event": "tool_results",
  "tool_results": [
    {
      "call_id": "call_xxx",
      "output": {
        "image_url": "https://cdn.com/generated-image.jpg",
        "width": 1920,
        "height": 1080
      }
    }
  ],
  "task_id": "task_xxx"
}

// 事件5：最终响应
{
  "event": "message",
  "answer": "图片已生成！",
  "task_id": "task_xxx"
}

// 事件6：完成
{
  "event": "workflow_finished",
  "task_id": "task_xxx"
}
```

---

#### **Step 5：前端处理 SSE 事件**

```typescript
// packages/business-sdks/ai-chat/src/hook/use-message.ts

const onListen = (data: SSEMessageType) => {
  // 1️⃣ 任务开始
  if (data.event === SSE_EVENT_TYPE.WORKFLOW_STARTED) {
    currentTaskId.current = data.task_id;
    toolLifecycleTracker.conflateStart({
      // 埋点：任务开始
      work_number: getUserMessageNumber(messagesRef.current),
      work_id: contentId,
    });
  }

  // 2️⃣ 文本消息（流式累加）
  if (data.event === SSE_EVENT_TYPE.MESSAGE) {
    content += data.answer ?? '';

    // 识别思考标签（R1 模型）
    if (data.answer?.includes('<thinking>')) {
      isThinkTagContainer = true;
      thinkingStartTime = Date.now();
    }
    if (data.answer?.includes('</thinking>')) {
      isThinkTagContainer = false;
      defaultAnswerMessage.thinkingElapsedMs = Date.now() - thinkingStartTime;
    }

    // 实时更新 UI
    onUpdate({
      ...defaultAnswerMessage,
      content,
    });
  }

  // 3️⃣ 错误处理
  if (data.event === SSE_EVENT_TYPE.ANSWER_ERROR) {
    let errorContent = SYSTEM_ERROR_TIP;
    if (data.code === PROHIBITION_CODE) {
      errorContent = PROHIBITION_TIP; // 内容违规
    }
    onSuccess({
      ...defaultAnswerMessage,
      content: errorContent,
      status: MESSAGE_STATUS.FINISHED,
      error: true,
    });
    return;
  }

  // 4️⃣ 任务完成
  if (data.event === SSE_EVENT_TYPE.WORKFLOW_FINISHED) {
    // 提取思考内容
    let reasoningContent = '';
    const matches = content.match(/<thinking>[\s\S]*?<\/thinking>/g);
    if (matches?.[0]) {
      reasoningContent = matches[0];
    }

    onSuccess({
      ...defaultAnswerMessage,
      content,
      reasoningContent,
      status: MESSAGE_STATUS.FINISHED,
    });

    // 埋点：任务完成
    toolLifecycleTracker.conflateCompleted({
      work_number: getUserMessageNumber(messagesRef.current),
      work_id: contentId,
    });

    // 自动保存
    saveTemplate({
      message: messagesRef.current,
      isThink: isThink.current,
    });
  }
};
```

**处理逻辑总结**：

```
workflow_started → 记录 taskId，触发开始埋点
message          → 累加文本，识别思考标签，实时更新 UI
answer_error     → 显示错误，标记状态为 error
workflow_finished → 提取思考内容，触发完成埋点，自动保存
```

---

### 10.3 Tool Calling 机制详解

#### **工具定义与注册**

```typescript
// domains/editor/extensions/ai/src/utils/functions.ts

class AIFunctionsManager {
  private functions: ToolFunc[] = [];

  constructor() {
    this.setFunctions([
      'draw', // 文生图
      'redraw', // 图生图
      'writer', // 文案生成
      'product', // 产品图生成
      'material', // 素材推荐
      'inPaintRemove', // 智能消除
      'inPaintReplace', // 智能替换
      'outPaintExpand', // 图片扩展
      'sceneCopywriter', // 场景文案
      'imageToSvg', // 图片转矢量
      'imageToTemplate', // 图片转模板(图文分层)
      'cutout', // AI抠图
      'background', // 背景替换
    ]);
  }

  // 过滤工具（权限控制）
  public filterFunction(func: toolsName) {
    return this.functions.some((item) => item.key === func);
  }
}
```

**工具配置（应用层）**：

```typescript
// domains/editor/apps/design/design-ai-plus/src/main.ts

const functions = [
  'inPaintRemoveV2', // V2 版本工具（更强大）
  'enhancedImageV2',
  'outPaintExpandV2',
  'draw',
  'redrawV2',
  'material',
  'writer',
  'cutout',
  'sceneCopywriter',
  'background',
  'imageToSvg',
  'imageToTemplate',
  'inPaintReplaceV2',
] as toolsName[];

// 注册到 AI 扩展插件
defineExtensionConfig(import('@design/extension-ai'), {
  functions, // 启用的工具列表
  // ... 其他配置
});
```

#### **Tool Schema（传给大模型的定义）**

大模型需要知道每个工具的作用和参数，推测 Dify 会生成类似这样的 Schema：

```json
{
  "tools": [
    {
      "type": "function",
      "function": {
        "name": "draw",
        "description": "根据文字描述生成图片，支持多种风格和比例",
        "parameters": {
          "type": "object",
          "properties": {
            "prompt": {
              "type": "string",
              "description": "图片描述，尽量详细，包含主体、风格、场景等"
            },
            "ratio": {
              "type": "string",
              "enum": ["1:1", "16:9", "9:16", "4:3", "3:4"],
              "description": "图片比例"
            },
            "style": {
              "type": "string",
              "enum": ["realistic", "anime", "3d", "sketch"],
              "description": "图片风格"
            },
            "num": {
              "type": "integer",
              "description": "生成数量，默认 1，最多 4",
              "default": 1,
              "maximum": 4
            }
          },
          "required": ["prompt"]
        }
      }
    },
    {
      "type": "function",
      "function": {
        "name": "writer",
        "description": "生成营销文案、slogan、产品描述等",
        "parameters": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "enum": ["slogan", "product_desc", "ad_copy"],
              "description": "文案类型"
            },
            "keywords": {
              "type": "array",
              "items": { "type": "string" },
              "description": "关键词列表"
            },
            "tone": {
              "type": "string",
              "enum": ["professional", "casual", "humorous"],
              "description": "文案语气"
            }
          },
          "required": ["type", "keywords"]
        }
      }
    }
    // ... 其他工具定义
  ]
}
```

---

### 10.4 DeepSeek 模型对比

| 特性          | DeepSeek-V3        | DeepSeek-R1                      |
| ------------- | ------------------ | -------------------------------- |
| **响应速度**  | 快速（1-2秒首字）  | 较慢（2-5秒首字，需思考时间）    |
| **思考过程**  | 无                 | 有（`<thinking>...</thinking>`） |
| **输出质量**  | 标准               | 更高（经过推理）                 |
| **Token消耗** | 较少               | 较多（思考过程消耗额外Token）    |
| **适用场景**  | 快速响应、简单任务 | 复杂推理、多步骤任务             |
| **用户选择**  | 默认模式           | 开启"深度思考"开关               |

**R1 模型的思考示例**：

```
用户输入："帮我设计一张科技公司的海报"

<thinking>
分析：
1. 用户需求：科技公司海报
2. 关键要素：
   - 主题：科技感
   - 目标：展示公司专业性
   - 风格：现代、简约、蓝色调
3. 推荐方案：
   - 使用16:9比例（适合展示）
   - 风格选择"3d"或"realistic"
   - 提示词增强：添加"高科技"、"未来感"等关键词
4. 需要的工具：draw
5. 参数构造：
   - prompt: "科技公司海报，蓝色调，高科技，未来感，专业，简约"
   - ratio: "16:9"
   - style: "3d"
</thinking>

好的，我来帮您设计一张科技公司海报。我会生成一张16:9比例的海报，风格偏向现代科技感。
```

**为什么需要 R1？**

```
场景1：复杂需求理解
  用户："我要做个海报，要显得高端"
  V3：直接生成 → 可能理解不准确
  R1：思考 → "高端"意味着什么？→ 简约、质感、留白 → 生成更精准

场景2：多步骤任务
  用户："生成logo后，再做一张名片"
  V3：可能只完成第一步
  R1：思考 → 识别两个任务 → 依次完成

场景3：参数推理
  用户："给我个竖版海报"
  V3：可能默认 1:1
  R1：思考 → 竖版 = 9:16 → 自动选择正确比例
```

---

### 10.5 核心代码方法说明

#### **1. useXAgent（Agent 核心）**

```typescript
// domains/editor/packages/design/agent-x/src/x-sdk/use-x-agent.ts

export function useXAgent(config) {
  const {
    request, // 核心：处理请求的函数
    onSuccess, // 成功回调
    onError, // 错误回调
    onUpdate, // 实时更新回调
  } = config;

  const isRequesting = ref(false);

  const run = async (params) => {
    isRequesting.value = true;

    try {
      await request(params, {
        onSuccess: (data) => {
          isRequesting.value = false;
          onSuccess?.(data);
        },
        onUpdate: (data) => {
          onUpdate?.(data); // 流式更新
        },
        onError: (error) => {
          isRequesting.value = false;
          onError?.(error);
        },
      });
    } catch (error) {
      isRequesting.value = false;
      onError?.(error);
    }
  };

  return [
    {
      request: run,
      isRequesting: () => isRequesting.value,
    },
  ];
}
```

**核心价值**：

- 统一的请求管理
- 内置loading状态
- 统一的错误处理
- 支持流式更新

#### **2. createSSEConnection（SSE连接）**

```typescript
// 核心方法
async function createSSEConnection(options) {
  const response = await fetch(difyUrl, requestOptions);
  const reader = response.body.getReader();

  return {
    listen(callback) {
      // 循环读取流
      while (true) {
        const { done, value } = await reader.read();
        const data = JSON.parse(decoder.decode(value));
        callback(data); // 回调处理
        if (done) break;
      }
    },
    close() {
      reader.cancel(); // 取消流
    },
  };
}
```

**核心价值**：

- 封装 ReadableStream 复杂性
- 自动处理 JSON 分段
- 统一的错误处理
- 支持主动关闭

#### **3. toolLifecycleTracker（工具生命周期追踪）**

```typescript
// packages/business-sdks/ai-chat/src/services/tool-lifecycle-tracker.ts

export function createToolLifecycleTracker() {
  return {
    // 任务开始
    conflateStart(params) {
      windAPI.tracker('aigc_tool_init', {
        ...params,
        timestamp: Date.now(),
      });
    },

    // 任务完成
    conflateCompleted(params) {
      windAPI.tracker('aigc_tool_complete', {
        ...params,
        timestamp: Date.now(),
      });
    },
  };
}
```

**核心价值**：

- 埋点追踪，分析用户行为
- 计算任务耗时
- 监控成功率

### 10.6 端到端流程总览 - 数据流转详解

让我们用一个完整的例子，展示数据在各个环节的流转：

**用户输入**：`"帮我生成一张16:9的春天风景照，要写实风格"`

```
┌──────────────────────────────────────────────────────────────────┐
│  阶段0：用户输入（0ms）                                             │
│  ────────────────────────────────────────────────────────────   │
│  ChatSender 收集参数：                                              │
│  {                                                                │
│    content: "帮我生成一张16:9的春天风景照，要写实风格",            │
│    role: "user",                                                  │
│    createdAt: 1736582400000                                       │
│  }                                                                │
└──────────────────────────────────────────────────────────────────┘
                            ↓
┌──────────────────────────────────────────────────────────────────┐
│  阶段1：前端预处理（50ms）                                          │
│  ────────────────────────────────────────────────────────────   │
│  useXAgent.request() 触发：                                       │
│    1. 创建 assistant 消息占位                                     │
│       {                                                           │
│         id: "msg_abc123",                                         │
│         role: "assistant",                                        │
│         content: "",                                              │
│         status: "loading",                                        │
│         model: "deepseek-v3",                                     │
│       }                                                           │
│                                                                   │
│    2. 立即调用 onUpdate() → UI 显示"AI思考中"                     │
│                                                                   │
│    3. 准备历史消息（最近30组）                                     │
│       history_text = JSON.stringify([                             │
│         { role: "user", content: "上次对话..." },                │
│         { role: "assistant", content: "..." },                    │
│         // ... 最多60条                                           │
│       ])                                                          │
└──────────────────────────────────────────────────────────────────┘
                            ↓
┌──────────────────────────────────────────────────────────────────┐
│  阶段2：建立SSE连接（200ms）                                        │
│  ────────────────────────────────────────────────────────────   │
│  createSSEConnection() 发送 POST 请求：                           │
│                                                                   │
│  POST /api/gdesign/tool/v1/dify/chat                             │
│  Headers:                                                         │
│    Authorization: Bearer eyJhbGc...                               │
│    Content-Type: application/json                                │
│                                                                   │
│  Body:                                                            │
│  {                                                                │
│    "scene_code": "ai-chat",                                       │
│    "aigc_type": "aigc",                                           │
│    "query": "帮我生成一张16:9的春天风景照，要写实风格",            │
│    "arguments": {                                                 │
│      "think": 0,                      ← 未开启深度思考            │
│      "history_text": "[{\"role\":\"user\"...}]"                  │
│    },                                                             │
│    "conversation_id": ""                                          │
│  }                                                                │
│                                                                   │
│  → 返回 ReadableStream                                            │
└──────────────────────────────────────────────────────────────────┘
                            ↓
┌──────────────────────────────────────────────────────────────────┐
│  阶段3：Dify Workflow 处理（后端，500ms-2s）                        │
│  ────────────────────────────────────────────────────────────   │
│  3.1 接收请求（50ms）                                              │
│      → 生成 task_id: "task_xyz789"                                │
│      → 推送事件：                                                 │
│        {                                                          │
│          "event": "workflow_started",                             │
│          "task_id": "task_xyz789",                                │
│          "conversation_id": "conv_abc"                            │
│        }                                                          │
│                                                                   │
│  3.2 Prompt Engineering（100ms）                                  │
│      → 注入系统提示词：                                            │
│        "你是稿定AI的智能设计助手..."                               │
│                                                                   │
│      → 格式化历史对话：                                            │
│        [                                                          │
│          { role: "system", content: "..." },                     │
│          { role: "user", content: "上次对话..." },               │
│          { role: "assistant", content: "..." },                   │
│          { role: "user", content: "帮我生成..." }                │
│        ]                                                          │
│                                                                   │
│      → 注入工具定义（Tool Schema）：                              │
│        tools: [                                                   │
│          {                                                        │
│            type: "function",                                      │
│            function: {                                            │
│              name: "draw",                                        │
│              description: "根据文字描述生成图片...",              │
│              parameters: {                                        │
│                type: "object",                                    │
│                properties: {                                      │
│                  prompt: { type: "string", ... },                │
│                  ratio: { enum: ["1:1", "16:9", ...] },          │
│                  style: { enum: ["realistic", ...] }             │
│                },                                                 │
│                required: ["prompt"]                               │
│              }                                                    │
│            }                                                      │
│          },                                                       │
│          { function: { name: "writer", ... } },                  │
│          // ... 其他工具                                          │
│        ]                                                          │
│                                                                   │
│  3.3 调用大模型（DeepSeek API，1-2s）                             │
│      POST https://api.deepseek.com/v1/chat/completions           │
│      {                                                            │
│        "model": "deepseek-chat",                                  │
│        "messages": [...],                                         │
│        "tools": [...],                                            │
│        "temperature": 0.7,                                        │
│        "stream": true          ← 流式返回                         │
│      }                                                            │
│                                                                   │
│  3.4 大模型推理（1s）                                              │
│      → 理解意图："用户要生成图片"                                  │
│      → 识别参数：                                                 │
│        - 描述："春天风景照"                                        │
│        - 比例："16:9"                                             │
│        - 风格："写实"(realistic)                                   │
│      → 决策：调用 draw 工具                                       │
│                                                                   │
│  3.5 模型返回（流式，200ms）                                       │
│      Chunk 1:                                                     │
│      {                                                            │
│        "choices": [{                                              │
│          "delta": {                                               │
│            "role": "assistant",                                   │
│            "content": "好的"                                      │
│          }                                                        │
│        }]                                                         │
│      }                                                            │
│      → Dify 转发给前端：                                          │
│        { "event": "message", "answer": "好的" }                   │
│                                                                   │
│      Chunk 2:                                                     │
│      {                                                            │
│        "choices": [{                                              │
│          "delta": {                                               │
│            "content": "，我来帮您生成"                            │
│          }                                                        │
│        }]                                                         │
│      }                                                            │
│      → Dify 转发：                                                │
│        { "event": "message", "answer": "，我来帮您生成" }         │
│                                                                   │
│      Chunk 3（工具调用）:                                          │
│      {                                                            │
│        "choices": [{                                              │
│          "delta": {                                               │
│            "tool_calls": [{                                       │
│              "id": "call_draw_001",                               │
│              "type": "function",                                  │
│              "function": {                                        │
│                "name": "draw",                                    │
│                "arguments": "{\"prompt\":\"春天的..."            │
│              }                                                    │
│            }]                                                     │
│          },                                                       │
│          "finish_reason": "tool_calls"                            │
│        }]                                                         │
│      }                                                            │
│      → Dify 解析工具调用 → 路由到图片生成服务                     │
│                                                                   │
│  3.6 工具执行（图片生成服务，10-30s）                              │
│      draw({                                                       │
│        prompt: "春天的风景照，写实风格，16:9",                    │
│        ratio: "16:9",                                             │
│        style: "realistic",                                        │
│        num: 1                                                     │
│      })                                                           │
│      → 调用 Stable Diffusion / Flux 模型                          │
│      → 生成图片：https://cdn.com/spring-landscape.jpg            │
│      → 返回结果给 Dify                                            │
│                                                                   │
│  3.7 Dify 推送工具结果（100ms）                                   │
│      推送事件：                                                   │
│      {                                                            │
│        "event": "tool_result",        ← 假设的事件类型           │
│        "tool_name": "draw",                                       │
│        "result": {                                                │
│          "image_url": "https://cdn.com/spring-landscape.jpg",    │
│          "width": 1920,                                           │
│          "height": 1080                                           │
│        }                                                          │
│      }                                                            │
│                                                                   │
│  3.8 完成响应（50ms）                                              │
│      推送最终事件：                                                │
│      {                                                            │
│        "event": "workflow_finished",                              │
│        "task_id": "task_xyz789"                                   │
│      }                                                            │
└──────────────────────────────────────────────────────────────────┘
                            ↓
┌──────────────────────────────────────────────────────────────────┐
│  阶段4：前端SSE流处理（实时，总计10-30s）                           │
│  ────────────────────────────────────────────────────────────   │
│  onListen() 回调依次接收事件：                                     │
│                                                                   │
│  事件1：workflow_started                                          │
│    currentTaskId.current = "task_xyz789"                          │
│    toolLifecycleTracker.conflateStart()  ← 埋点                  │
│                                                                   │
│  事件2：message (content: "好的")                                 │
│    content += "好的"                                              │
│    onUpdate({ content: "好的", status: "loading" })              │
│    → UI 显示："好的"                                              │
│                                                                   │
│  事件3：message (content: "，我来帮您生成")                       │
│    content += "，我来帮您生成"                                    │
│    onUpdate({ content: "好的，我来帮您生成", ... })              │
│    → UI 显示："好的，我来帮您生成"                                │
│                                                                   │
│  事件4：tool_result                                               │
│    → 触发 MessageHandler 处理工具结果                             │
│    → PlaceholderManager.create('image')                          │
│       创建占位元素（灰色矩形+加载动画）                            │
│    → 显示在画布上                                                 │
│                                                                   │
│  事件5：workflow_finished                                         │
│    reasoningContent = ''  (V3模型无思考内容)                      │
│    onSuccess({                                                    │
│      content: "好的，我来帮您生成",                               │
│      status: "finished",                                          │
│      taskId: "task_xyz789"                                        │
│    })                                                             │
│    toolLifecycleTracker.conflateCompleted()  ← 埋点              │
│    saveTemplate()  ← 自动保存对话                                │
└──────────────────────────────────────────────────────────────────┘
                            ↓
┌──────────────────────────────────────────────────────────────────┐
│  阶段5：工具结果处理（500ms-1s）                                   │
│  ────────────────────────────────────────────────────────────   │
│  ToolProcessor.processAiTool():                                   │
│    input: {                                                       │
│      toolType: "draw",                                            │
│      result: {                                                    │
│        uri: "https://cdn.com/spring-landscape.jpg",              │
│      },                                                           │
│      metadata: {                                                  │
│        taskId: "task_xyz789",                                     │
│        query: "春天的风景照",                                     │
│        width: 1920,                                               │
│        height: 1080                                               │
│      }                                                            │
│    }                                                              │
│                                                                   │
│  步骤：                                                            │
│    1. getRecordId(taskId) → 查询历史记录                          │
│       → 无历史记录（新生成）                                       │
│                                                                   │
│    2. postRecord() → 保存生成记录到数据库                         │
│       POST /api/aigc/generation-record                            │
│       {                                                           │
│         task_id: "task_xyz789",                                   │
│         work_id: "work_123",                                      │
│         generation_result: "https://cdn.com/spring...",           │
│         prompt: "春天的风景照",                                   │
│         element_id: null  (尚未添加到画布)                        │
│       }                                                           │
│       → 返回 recordId: "record_456"                               │
│                                                                   │
│    3. 返回处理后的工具对象                                         │
│       output: {                                                   │
│         ...input,                                                 │
│         metadata: {                                               │
│           ...input.metadata,                                      │
│           recordId: "record_456"                                  │
│         }                                                         │
│       }                                                           │
└──────────────────────────────────────────────────────────────────┘
                            ↓
┌──────────────────────────────────────────────────────────────────┐
│  阶段6：添加到画布（200-500ms）                                    │
│  ────────────────────────────────────────────────────────────   │
│  ElementAddService.addImageElement():                             │
│                                                                   │
│  1. 加载图片资源（200ms）                                          │
│     loadImage("https://cdn.com/spring-landscape.jpg")            │
│     → 下载图片                                                    │
│     → 解码为纹理                                                  │
│                                                                   │
│  2. 创建图片元素（50ms）                                           │
│     imageElement = editor.createElement({                         │
│       type: 'image',                                              │
│       imageUrl: "https://cdn.com/spring-landscape.jpg",          │
│       width: 1920,                                                │
│       height: 1080,                                               │
│       transform: {                                                │
│         x: placeholderPosition.x,  ← 继承占位元素位置            │
│         y: placeholderPosition.y,                                 │
│         rotation: 0,                                              │
│         scaleX: 1,                                                │
│         scaleY: 1                                                 │
│       }                                                           │
│     })                                                            │
│                                                                   │
│  3. 移除占位元素（10ms）                                           │
│     placeholderManager.remove(placeholderId)                      │
│                                                                   │
│  4. 添加真实元素（50ms）                                           │
│     editor.addElement(imageElement)                               │
│     → 触发渲染引擎更新                                            │
│     → 淡入动画（300ms）                                           │
│                                                                   │
│  5. 聚焦元素（50ms）                                               │
│     editor.focusElement(imageElement)                             │
│     → 选中新元素                                                  │
│     → 显示控制点                                                  │
│                                                                   │
│  6. 调整视口（100ms）                                              │
│     adjustViewport()                                              │
│     → 自动滚动到新元素位置                                        │
│     → 确保元素在可视区域                                          │
└──────────────────────────────────────────────────────────────────┘
                            ↓
┌──────────────────────────────────────────────────────────────────┐
│  完成！用户看到生成的图片 ✨                                        │
│  总耗时：约 10-30 秒                                               │
│  用户感知：约 1 秒（因为有占位元素）                               │
└──────────────────────────────────────────────────────────────────┘
```

**时间分布统计**（参考值）：

| 阶段                 | 耗时     | 占比   | 用户感知           |
| -------------------- | -------- | ------ | ------------------ |
| 前端预处理           | 50ms     | <1%    | 无感知（异步）     |
| SSE连接建立          | 200ms    | 1%     | 立即看到loading    |
| Dify PE增强          | 100ms    | <1%    | 无感知（后端）     |
| 大模型推理           | 1-2s     | 5-10%  | 流式显示文字       |
| 工具执行（图片生成） | 10-30s   | 80-90% | 有占位元素，可操作 |
| 工具结果处理         | 500ms-1s | 3-5%   | 无感知（后台）     |
| 添加到画布           | 500ms    | 2-3%   | 看到淡入动画       |

**核心优化点**：

```
✅ 立即反馈：onUpdate() 0ms 延迟显示 loading
✅ 占位元素：工具执行时创建，用户不用傻等 10-30s
✅ 流式输出：大模型推理时逐字显示，体验流畅
✅ 异步处理：ToolProcessor 在后台处理，不阻塞 UI
✅ 渐进加载：图片资源分步加载（下载→解码→渲染）
```

---

### 10.7 错误处理与容错机制

#### **各阶段错误处理**

```
┌─────────────────────────────────────────────────────────────────┐
│  错误类型1：网络错误                                              │
│  ─────────────────────────────────────────────────────────────  │
│  触发场景：SSE 连接失败、网络中断                                 │
│  处理逻辑：                                                        │
│    1. createSSEConnection() 捕获异常                             │
│    2. 调用 onError({ event: 'network_error' })                   │
│    3. 显示错误提示："网络似乎出现了点问题..."                     │
│    4. 提供"重试"按钮                                              │
│    5. 移除占位元素（如果有）                                       │
│                                                                   │
│  用户操作：点击重试 → 重新走完整流程                              │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  错误类型2：认证错误（401）                                        │
│  ─────────────────────────────────────────────────────────────  │
│  触发场景：Token过期、未登录                                       │
│  处理逻辑：                                                        │
│    1. SSE 返回 401 状态码                                         │
│    2. 调用 login() 方法 → 弹出登录框                             │
│    3. 用户登录成功 → 自动重试                                     │
│    4. 用户取消登录 → 中止任务                                     │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  错误类型3：内容违规（12020758）                                   │
│  ─────────────────────────────────────────────────────────────  │
│  触发场景：用户输入敏感内容                                        │
│  处理逻辑：                                                        │
│    1. Dify 返回 { event: 'answer_error', code: '12020758' }     │
│    2. 识别违规代码                                                │
│    3. 显示友好提示："这个话题不适合讨论..."                       │
│    4. 不提供重试（因为再试也会失败）                              │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  错误类型4：系统错误（500）                                        │
│  ─────────────────────────────────────────────────────────────  │
│  触发场景：后端服务异常、Dify Workflow 失败                        │
│  处理逻辑：                                                        │
│    1. SSE 返回 500 / workflow_error                              │
│    2. 显示通用错误："系统有点繁忙～请稍后重试"                    │
│    3. 提供"重试"按钮                                              │
│    4. 记录错误日志到 SLS                                          │
│    5. 触发告警（如果错误率过高）                                   │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  错误类型5：工具执行失败                                           │
│  ─────────────────────────────────────────────────────────────  │
│  触发场景：图片生成超时、模型服务不可用                            │
│  处理逻辑：                                                        │
│    1. 工具返回失败结果                                            │
│    2. Dify 推送错误事件                                           │
│    3. 占位元素变为错误状态（红色边框 + 错误图标）                  │
│    4. 显示具体错误原因                                            │
│    5. 支持单独重试该工具                                          │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  错误类型6：用户主动取消                                           │
│  ─────────────────────────────────────────────────────────────  │
│  触发场景：用户点击"取消"按钮                                      │
│  处理逻辑：                                                        │
│    1. 调用 sseConnection.close()                                 │
│    2. 调用后端取消接口                                            │
│       POST /api/aigc/stop-generate                               │
│       { task_id, scene_code, aigc_type }                         │
│    3. 消息状态标记为 "stop"                                       │
│    4. 移除占位元素                                                │
│    5. 显示："已取消生成"                                          │
└─────────────────────────────────────────────────────────────────┘
```

#### **核心容错代码**

```typescript
// packages/business-sdks/ai-chat/src/hook/use-message.ts

// 错误处理中心
const onError = (data) => {
  // 1. 网络错误
  if (data.event === 'network_error') {
    onSuccess({
      ...defaultAnswerMessage,
      content: NETWORK_ERROR_TIP,
      status: MESSAGE_STATUS.FINISHED,
      error: true,
    });
  }

  // 2. 认证错误
  if (data.code === 401) {
    login?.().then((success) => {
      if (!success) {
        // 用户取消登录
        onCancel();
        onSuccess({
          ...defaultAnswerMessage,
          content: '',
          status: MESSAGE_STATUS.STOP,
          error: true,
        });
      } else {
        // 登录成功，自动重试（由外层控制）
      }
    });
    return;
  }

  // 3. 内容违规
  if (data.code === PROHIBITION_CODE) {
    onSuccess({
      ...defaultAnswerMessage,
      content: PROHIBITION_TIP,
      status: MESSAGE_STATUS.FINISHED,
      error: true,
    });
    return;
  }

  // 4. 系统错误
  if (data.event === 'system_error') {
    onSuccess({
      ...defaultAnswerMessage,
      content: data.answer || SYSTEM_ERROR_TIP,
      status: MESSAGE_STATUS.FINISHED,
      error: true,
    });
  }

  // 5. 流结束
  if (data.event === 'message_end') {
    onSuccess({
      ...defaultAnswerMessage,
      content: content + ' ...', // 显示不完整标记
      status: MESSAGE_STATUS.STOP,
    });
  }
};

// 主动取消
function onCancel() {
  try {
    sseConnection?.close(); // 关闭流
    if (currentTaskId.current) {
      // 调用后端取消接口
      aiChatApi.stopGenerate({
        id: currentTaskId.current,
        scene_code: 'ai-chat',
        aigc_type: 'aigc',
      });
    }
  } catch (error) {
    console.error(error);
    // 即使取消失败也不影响用户体验
  }
}
```

---

### 10.8 关键技术亮点总结

| 亮点                 | 技术方案                       | 业界对比                     |
| -------------------- | ------------------------------ | ---------------------------- |
| **流式 AI 响应**     | SSE + 逐字显示                 | 多数产品：等待完成后显示     |
| **立即反馈**         | onUpdate 0ms 延迟 + 占位元素   | 多数产品：傻等 10-30s        |
| **深度思考可视化**   | R1 thinking 标签解析 + UI 展示 | 业界首创（DeepSeek R1独有）  |
| **历史消息智能裁剪** | 最近 30 组 + thinking 标签去除 | 多数产品：简单截断或全部发送 |
| **JSON 分段处理**    | buffer 缓存 + 序列解析         | 容易出现解析错误             |
| **工具生命周期追踪** | toolLifecycleTracker + 埋点    | 多数产品：缺乏完整追踪       |
| **优雅错误处理**     | 分类处理 + 友好提示 + 支持重试 | 多数产品：通用错误提示       |
| **主动取消支持**     | SSE close + 后端取消接口       | 多数产品：不支持取消         |

---

**文档版本**：v1.1
**最后更新**：2026-01-11
**维护者**：AI+ 编辑器团队
