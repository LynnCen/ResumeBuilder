# 10 - 核心代码实现

> **导航**：[📚 返回总目录](./README.md) | [⬅️ 上一篇：性能优化与错误处理](./08-性能优化与错误处理.md) | [➡️ 下一篇：总结与展望](./10-总结与展望.md)
>
> **所属**：AI+ 智能设计编辑器架构文档
>
> **说明**：以下代码展示关键逻辑的核心思想，而非完整实现

---

## 8.1 编辑器初始化（应用入口）

```typescript
// 简化示意：实际初始化过程
async function editorMain() {
  // 1. 导入基座
  const { installDesign } = await import('@design/design-foundation/agent');

  // 2. 一行代码启动编辑器
  await installDesign('#app', {
    // API配置
    apis: {
      baseURL: 'https://api.example.com',
      endpoints: {
        /* ... */
      },
    },

    // 环境配置
    env: {
      REGION: 'China', // 区域：国内/国外
      LOGIN_TYPE: 'phone', // 登录方式
    },

    // 权限配置（功能开关）
    permissions: {
      AI_CHAT: true, // AI聊天
      FILE_UPLOAD: true, // 文件上传
      // ...
    },

    // 插件配置（按需加载）
    extensionConfig: [
      // 异步导入，支持代码分割
      defineExtensionConfig(() => import('@design/extension-ai')),
    ],
  });
}

// 核心价值：
// ✓ 统一入口，标准化初始化流程
// ✓ 配置驱动，国内外版本只需改配置
// ✓ 异步加载，首屏体积小
```

---

## 8.2 聊天组件集成

```vue
<!-- 简化示意：聊天组件的使用方式 -->
<template>
  <ChatWrap :chatConfig="chatConfig" :editor="editor" @submit="handleSubmit" />
</template>

<script setup>
import { ChatWrap, getQingZhouConfig } from '@design/ai-chat-vue';

// 初始化聊天配置（提供回调函数）
const chatConfig = await getQingZhouConfig({
  // 必需回调
  getRepositoryId: () => currentWorkId, // 当前作品ID
  getUserId: () => currentUserId, // 当前用户ID

  // 可选回调
  tracker: windAPI, // 埋点工具
  login: () => showLoginModal(), // 登录
  upload: (file) => uploadToOSS(file), // 上传
});

// 处理用户提交
const handleSubmit = (params) => {
  // params: { skill, prompt, ratio, styleCode, attachments }
  console.log('用户发起生成:', params);
};
</script>

<!-- 核心价值： -->
<!-- ✓ 声明式使用，无需关心内部复杂度 -->
<!-- ✓ 通过回调函数对接业务逻辑 -->
<!-- ✓ 事件驱动，解耦画布和聊天 -->
```

---

## 8.3 SSE流式处理（核心逻辑）

```typescript
// 简化示意：SSE 消息处理的核心流程
class MessageHandler {
  handleSSEMessage(data: MessageType[], done: boolean) {
    data.forEach((item) => {
      // 根据消息类型分发处理
      switch (item.content.type) {
        case 'text':
          // AI的文本回复
          this.appendAssistantMessage(item.content.text);
          break;

        case 'function_call':
          // AI调用工具（如生成图片）
          this.trackToolStart(item); // 埋点
          this.createPlaceholder(); // 创建占位
          break;

        case 'function_response':
          // 工具执行结果
          const tool = this.parseTool(item.content.text);
          events.emit('addImage', tool); // 触发画布添加
          break;
      }
    });

    if (done) {
      // 流结束，保存记录
      this.saveConversation();
    }
  }
}

// 核心价值：
// ✓ 统一处理各种消息类型
// ✓ 实时流式更新UI
// ✓ 通过事件解耦业务逻辑
```

---

## 8.4 批量生成追踪（技术亮点）

```typescript
// 简化示意：批量生成的追踪机制
class MessageHandler {
  private consecutiveFunctionCalls = new Map();

  handleFunctionCall(item) {
    const toolName = item.toolName; // 如 'image'

    // 检测是否为连续调用（批量生成）
    const tracking = this.consecutiveFunctionCalls.get(toolName);

    if (tracking && this.isConsecutive(item, tracking)) {
      // 累加期望数量
      tracking.expectedResponses++;
    } else {
      // 新建追踪记录
      this.consecutiveFunctionCalls.set(toolName, {
        expectedResponses: 1,
        receivedResponses: 0,
        messageIds: new Set([item.messageId]),
      });
    }
  }

  handleFunctionResponse(item) {
    const toolName = item.toolName;
    const tracking = this.consecutiveFunctionCalls.get(toolName);

    if (tracking) {
      tracking.receivedResponses++;

      // 判断是否全部完成
      if (tracking.receivedResponses === tracking.expectedResponses) {
        this.onBatchCompleted(toolName); // 批量完成事件
      }
    }
  }
}

// 核心价值：
// ✓ 智能识别批量生成意图
// ✓ 实时追踪生成进度
// ✓ 避免重复处理和遗漏
```

---

## 8.5 占位元素管理（用户体验优化）

```typescript
// 简化示意：占位元素的创建和替换
class PlaceholderManager {
  create(type: 'image' | 'text') {
    // 1. 创建占位元素（视觉元素）
    const placeholder = {
      id: generateId(),
      type,
      element: this.createLoadingElement(), // 加载动画
    };

    // 2. 添加到画布
    const position = this.calculatePosition();
    editor.addElement(placeholder.element, position);

    // 3. 记录占位信息
    this.placeholders.set(placeholder.id, placeholder);

    return placeholder.id;
  }

  replace(placeholderId, realElement) {
    // 1. 获取占位元素
    const placeholder = this.placeholders.get(placeholderId);

    // 2. 继承位置
    realElement.transform = placeholder.element.transform;

    // 3. 移除占位，添加真实元素
    editor.removeElement(placeholder.element);
    editor.addElement(realElement);

    // 4. 清理记录
    this.placeholders.delete(placeholderId);
  }
}

// 核心价值：
// ✓ 立即反馈，无需等待
// ✓ 位置预留，避免跳动
// ✓ 优雅过渡，提升体验
```

---

## 8.6 事件驱动（解耦利器）

```typescript
// 简化示意：事件系统的使用
// 发布者（ChatPanel）
events.emit('addImage', {
  tools: [imageToolData],
  autoPosition: true,
});

// 订阅者1（PlaceholderManager）
events.on('addImage', (data) => {
  const placeholderId = this.create('image');
  // 创建占位，等待真实元素
});

// 订阅者2（ToolProcessor）
events.on('addImage', async (data) => {
  for (const tool of data.tools) {
    const processed = await this.processAiTool(tool);
    // 处理工具数据
  }
});

// 订阅者3（ElementAddService）
events.on('addImage', async (data) => {
  await this.addImageElement(data.tools[0]);
  // 添加到画布
});

// 核心价值：
// ✓ 一对多通信，无需互相引用
// ✓ 易于扩展，新增订阅者不影响发布者
// ✓ 便于测试，可单独测试每个模块
```

---

> **下一步**：查看 [总结与展望](./10-总结与展望.md) 了解架构价值和未来规划。
